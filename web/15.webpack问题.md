# ESLint

### 可组装的JavaScript和JSX检查工具



**为什么使用eslint**

借助 ESLint，可将 **静态代码分析** 和 **问题代码协助修复** 集成到 **编码**、**提交** 和 **打包** 过程中，及早发现并协助修复代码中：

- 有语法错误的部分
- 不符合约定的样式准则的部分
- 不符合约定的最佳实践的部分

在项目开发中获得如下收益：

- 在执行代码之前发现并修复语法错误，减少调试耗时和潜在 bug
- 保证项目的编码风格统一，提高可维护性
- 督促团队成员在编码时遵守约定的最佳实践，提高代码质量



eslint配置



相关参考：[ESLint 使用指南](https://juejin.im/post/5c92e11b5188251571729ef0)

​				   [ESLint——从零学起](https://www.cnblogs.com/wheatCatcher/p/11218924.html)

# Plugin和Loader的区别

【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。

【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。

# Webpack生命周期



![生命周期](https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg)

# webpack多页面配置

## 一、引子

Webpack 的entry支持多种类型，包括字符串、对象、数组。从作用上来说，包括了**单文件入口**和**多文件入口**两种方式。
单文件的用法如下：

```js
module.exports = {
    entry: 'path/to/my/entry/file.js'
};
// 或者使用对象方式
module.exports = {
    entry: {
        main: 'path/to/my/entry/file.js'
    }
};
```

单文件入口可以快速创建一个只有单一文件入口的情况，例如 library 的封装，但是单文件入口的方式相对来说比较简单，在扩展配置的时候灵活性较低。

多文件入口是使用对象语法来通过支持多个entry，多文件入口的对象语法相对于单文件入口，具有较高的灵活性，例如多页应用、页面模块分离优化。多文件入口的语法如下：

```js
module.exports = {
    entry: {
        home: 'path/to/my/entry/home.js',
        search: 'path/to/my/entry/search.js',
        list: 'path/to/my/entry/list.js'
    }
};
```

上面的语法将entry分成了 3 个独立的入口文件，这样会打包出来三个对应的 bundle。对于一个 HTML 页面，推荐只有一个 entry ，通过统一的入口，解析出来的依赖关系更方便管理和维护。

一个 webpack 的配置，可以包含多个entry**，**但是只能有一个output。对于不同的entry可以通过output.filename占位符语法来区分，比如：

```js
module.exports = {
    entry: {
        home: 'path/to/my/entry/home.js',
        search: 'path/to/my/entry/search.js',
        list: 'path/to/my/entry/list.js'
    },
    output: {
        filename: '[name].js', // 这个是 bundle 的名称
        path: __dirname + '/dist' // 此选项制定了输出的 bundle 存放的路径，比如dist、output等
    }
};
```

## 二、多页应用

多页应用，顾名思义最后我们打包生成的页面也是多个，即 HTML 是多个；多页应用不仅仅是页面多个，入口文件也是多个；多页应用可能页面之间页面结构是不同的，比如一个网站项目，典型的三个页面是：首页、列表页和详情页，肯定每个页面都不一样。

**多页面问题**

多页面就是指的多个 HTML 页面，这时候可以直接借助 html-webpack-plugin 插件来实现，我们只需要多次实例化一个 html-webpack-plugin 的实例即可。

下面是同一个 template，那么可以只修改 filename 输出不同名的 HTML 即可：

```js
const HtmlWebPackPlugin = require('html-webpack-plugin');

const indexPage = new HtmlWebPackPlugin({
    template: './src/index.html',
    filename: 'index.html'
});
const listPage = new HtmlWebPackPlugin({
    template: './src/index.html',
    filename: 'list.html'
});
module.exports = {
    mode: 'development',
    entry: {
        main: './src/index.js'
    },
    plugins: [indexPage, listPage]
};
```

对于页面结构不同的 HTML 页面的配置，使用不同的 template 即可。

```js
const HtmlWebPackPlugin = require('html-webpack-plugin');

const indexPage = new HtmlWebPackPlugin({
    template: './src/index.html',
    filename: 'index.html'
});
const listPage = new HtmlWebPackPlugin({
    template: './src/list.html',
    filename: 'list.html'
});
module.exports = {
    mode: 'development',
    entry: {
        main: './src/index.js'
    },
    plugins: [indexPage, listPage]
};
```

上面的多页面解决是多次实例化 html-webpack-plugin，根据传入的参数不同（主要是 filename 不同），打包出两个文件，但是这两个文件的特点是引入的 JavaScript 文件都是一样的，即都是main.js 。

如果我们的项目是一个由多个路由或页面组成的，但是代码中只有一个单独的 JavaScript 文件（一个单独的入口 chunk），这样会导致不管访问任何页面都会加载整站资源，让用户付出额外的流量。此外，如果这个用户经常只是访问其中的某个页面，但是当我们更改了其它页面的代码，Webpack 将会重新编译，那么整个 bundle 的文件名哈希值就会发生变化，最终导致用户重新下载整个网站的代码，造成不必要的浪费。
这时候合理的做法是将整个项目利用多页面打包方案进行划分，将代码按照页面进行拆分，这样用户访问某个页面的时候，实际下载的只是当前页面的代码，而不是整个网站的代码，浏览器也更好的缓存了这部分代码，当其他页面代码发生变化的时候，当前代码的哈希值不会失效，自然用户不会重复下载相同的代码了。

对于多入口，并且入口需要区分的情况，那么需要怎么处理呢？

**多入口问题**

需要借助 html-webpack-plugin 的两个参数了：chunks和excludeChunks。chunks 是当前页面包含的 chunk 有哪些，可以直接用 entry 的key 来命名，excludeChunks则是排除某些 chunks。
例如，现在有两个 entry，分别是index.js 和list.js，我们希望index.html跟index.js是一组，list.html跟list.js 是一组，那么 webpack.config.js 需要修改为：

```js
const HtmlWebPackPlugin = require('html-webpack-plugin');

module.exports = {
    mode: 'development',
    entry: {
        index: './src/index.js',
        list: './src/list.js'
    },
    plugins: [
        new HtmlWebPackPlugin({
           template: './src/index.html', 
           filename: 'index.html', 
           chunks: ['index']
        }),
        new HtmlWebPackPlugin({
           template: './src/list.html',
           filename: 'list.html', 
           chunks: ['list']})
    ]
};
```

## 三、代码实践

3.1.1 建一个如下目录结构的工程，保证 template 和实际的 entry 是固定的目录，并且名字都是对应的。代码见[github](https://link.zhihu.com/?target=https%3A//github.com/SageSanyue/webpackDemo/tree/master/multiPageApp)

```text
├── package.json
├── src
│   └── entry
│       ├── detail.js
│       ├── index.js
│       └── list.js
├── template
│   ├── detail.html
│   ├── index.html
│   └── list.html
└── webpack.simple.js
```

3.1.2 npm init初始化package.json，scripts中加入对应此webpack配置文件的相应指令:

```js
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
 +   "build:simple": "webpack --config webpack.simple.js"
  },
```


3.1.3 npm install下载各种依赖

```text
npm install webpack webpack-cli --save-dev
npm install html-webpack-plugin --save-dev
npm install @babel/core @babel/cli @babel/preset-env babel-loader --save-dev
```

3.1.4 配置webpack文件

```js
// webpack.simple.js手动写法
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
    mode: 'development',
    entry: {
        'index': './src/entry/index.js',
        'list': './src/entry/list.js',
        'detail': './src/entry/detail.js'
    },
    output: {
        filename: '[name].[hash].js',
        path: path.resolve(__dirname, 'dist')
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './template/index.html',
            filename: 'index.html',
            chunks: ['index']
        }),
        new HtmlWebpackPlugin({
            template: './template/list.html',
            filename: 'list.html',
            chunks: ['list']
        }),
        new HtmlWebpackPlugin({
            template: './template/detail.html',
            filename: 'detail.html',
            chunks: ['detail']
        })
    ],
    module: {
        rules: [{
            test: /\.js$/,
            exclude: /node_modules/,
            loader: 'babel-loader',
            options: {
                presets: ['@babel/preset-env']
            }
        }]
    }
}
```

3.1.5 执行 npm run build:simple命令，可以看到执行打包后得到的dist目录里对应的html文件引入了打好的对应js文件。

![img](https://pic4.zhimg.com/80/v2-fbf3a5f2bca3f4057134ed0bb1fa7deb_720w.jpg)

3.2 方法2:非手动匹配方法——借用globby模块指定
3.2.1 使用了 [globby](https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/globby) 这个 NPM 模块

```js
npm install globby --save-dev
```

3.2.2 删掉上种手动配置得到的dist文件夹，在项目中新建utils.js文件:

```js
const path = require('path');
const globby = require('globby');

const getEntry = (exports.getEntry = () => {
    // 异步方式获取所有的路径
    const paths = globby.sync('entry/*.js', {
        cwd: path.join(__dirname, './src')
    });
    const rs = {};
    paths.forEach(v => {
        // 计算 filename
        const name = path.basename(v, '.js');
        let p = path.join('./src', v);
        if (!p.startsWith('.')) { // 转成相对地址
            p = './' + p;
        }

        rs[name] = p;
    });
    return rs;
});

// 输出内容
console.log(getEntry());

const HtmlWebPackPlugin = require('html-webpack-plugin');

exports.getHtmlWebpackPlugins = () => {
    const entries = getEntry();
    return Object.keys(entries).reduce((plugins, filename) => {
        plugins.push(
            new HtmlWebPackPlugin({
                template: `./template/${filename}.html`,
                filename: `${filename}.html`,
                chunks: [filename]
            })
        );
        return plugins;
    }, []);
};
```

3.2.3 新建webpack.auto.js文件并配置:

```js
const {getEntry, getHtmlWebpackPlugins} = require('./utils');
const path = require('path')

module.exports = {
    mode: 'development',
    entry: getEntry(),
    plugins: [
        //...
        ...getHtmlWebpackPlugins()
    ],
    output: {
        filename: '[name].[hash].js',
        path: path.resolve(__dirname, 'dist')
    },
    module: {
        rules: [{
            test: /\.js$/,
            exclude: /node_modules/,
            loader: 'babel-loader',
            options: {
                presets: ['@babel/preset-env']
            }
        }]
    }
};
```

3.2.4 package.json中加入对应此webpack配置文件的相应指令：

```js
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build:simple": "webpack --config webpack.simple.js",
 +   "build:globby": "webpack --config webpack.auto.js"
  },
```

3.2.5 执行npm run build:globby命令，得到dist打包文件夹，可以看到globby遍历路径的方式与前一种人工配对的方式一样可以成功打包多页面应用。

![img](https://pic4.zhimg.com/80/v2-328fd238cfa128e6ed24d9bf247d9ca7_720w.jpg)

# webpack打包过程

webpack的打包流程是采用事件流的模式，其内部使用Tapable进行事件定义。

Tapable是一个类似于nodejs的EentEmitter的库，主要控制钩子函数的事件发布和事件订阅。而webpack内部定义着大量功能丰富的插件，我们在前面提到过插件的功能贯穿了整个webpack打包流程，这些插件都会注册在Tapable定义的事件上，在打包过程中会依次有序的触发这些事件以调用插件执行其功能。

webpack内部定义了两个核心对象：compiler和compilation。这两个对象都集成自Tapable类，以便在其内部定义事件调用插件

**Compiler：**Compiler是webpack编译打包的核心对象，webpack编译每次编译开始时会创建一个全局唯一的compiler对象，compiler对象再创建一个compilation对象来负责模块的打包流程。

**Compilation：**compilation对象是Compiler编译过程中由compiler对象创建的，其内部也定义了大量的事件钩子以便插件调用。compilation负责打包的整个流程：加载(loaded)，封存(sealed),优化(optimization)，分块(chunked)和重新创建(restored)。当采用非watch模式启动编译时，只会创建一次compilation对象，当使用watch模式时（通常使用webpack-dev-server调用底层代码进行监听），每次模块内容变动时都会创建一个新的compilation对象。

上面我们了解了webpack的核心对象，现在让我们来分析webpack的源码。通常阅读源码时我们需要从主模块来开始阅读，其主模块为/node_modules/webpack/lib/webpack.js文件。主模块的webpack方法内首先会检查我们的配置文件格式是否有误。当配置文件格式准确无误时，接下来便开始创建compiler对象

```js
    compiler = new Compiler(options.context);
```

在webpack方法的底部会判断是否由监听模式启动（通常我们会使用webpack-dev-server来启动监听模式），如果为监听模式，便会调用compiler对象的watch方法，反之便会调用run方法。

```js
    if (
      options.watch === true ||
      (Array.isArray(options) && options.some(o => o.watch))
    ) {
      const watchOptions = Array.isArray(options)
        ? options.map(o => o.watchOptions || {})
        : options.watchOptions || {};
      return compiler.watch(watchOptions, callback);
    }
    compiler.run(callback);
```

我们先不要急着离开这里。文件的下面导出了大量webpack内置的插件，这些插件内部会监听不同的事件。即上面所说的，webpack编译过程中会触发不同的事件，那是便是这些插件大显神通的时候了。

```js
#compiler.js
exportPlugins(exports, {
  AutomaticPrefetchPlugin: () => require("./AutomaticPrefetchPlugin"),
  BannerPlugin: () => require("./BannerPlugin"),
    ...
```

接下来让我们走进webpack的编译过程。

调用compiler实例的run方法时，会依次触发beforeRun和run两个钩子

beforeRun

compiler.run() 执行之前，添加一个钩子

run

正是启动一次新的编译

```js
#compiler.js method：run()  
this.hooks.beforeRun.callAsync(this, err => {
      if (err) return finalCallback(err);
      this.hooks.run.callAsync(this, err => {
        if (err) return finalCallback(err);
        this.readRecords(err => {
          if (err) return finalCallback(err);
          this.compile(onCompiled);
        });
      });
    });
```

在compiler.run方法内部会触发compiler的compile方法，compiler.compile方法内部会创建一个compilation对象

```js
#compiler.js method：compile()
const compilation = this.newCompilation(params);
```

创建完compilation对象过程中，会触发thisCompilation和compilation钩子。

thisCompilation

触发 compilation 事件之前执行。

compilation

表示一个compilation对象创建完成

```js
 #compiler.js method: newCompilation()  
 this.hooks.thisCompilation.call(compilation, params);
 this.hooks.compilation.call(compilation, params);
```

在compilation钩子执行过程中，会调用不同的loader来完成对文件的编译工作。同时也会触发一些文件转换的钩子事件。

buildModule

在模块构建开始之前触发

normalModuleLoader

普通模块loader钩子，会一个接一个的加载模块图中的所有模块，并使用acorn将文件转换成AST以供webpack进行分析

seal

所有的模块都通过loader转换完成时，开始生成chunk

创建完compilation对象，回到compiler的compile方法内部，触发make钩子。

make

开启模块编译过程，从entry入口开始不断递归依赖

```js
#compiler.js method：compile()
this.hooks.make.callAsync(compilation, err => {
```

编译过程结束，接下来调用compilation对象的finish方法，在finish方法内部会触发compilation对象的finishModule钩子，代表所有模块全部完成构建。

finishModule

所有模块全部完成构建

后面会调用compilation的seal方法，seal方法内部完成的功能比较多，会依次完成模块的优化，哈希化等工作。这里涉及了很多打包过程的细节，由于我们今天只探讨webpack的打包流程，便不对这些细节一一列举。

当所有的模块打包工作做好之后，便会触发compiler对象的afterCompile钩子，代表此次编译已经完成。

```js
#compiler.js method: compile()
this.hooks.afterCompile.callAsync(compilation, err => {
```

上述过程全部结束之后会根据开发者的配置文件出口配置将输出文件打包到相应的输出目录。

Webpack是一个及其庞大的项目，源码相对来说也非常复杂，这里只列出关键流程，帮助大家能够对webpack打包过程有一个比较清晰的认识。

### 简单描述流程如下：

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
3. 确定入口：根据配置中的     entry 找出所有的入口文件；
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
5. 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

# 优化webpack构建时间的小技巧

有几个小技巧可以是构建时间从一分半骤降至20秒，rebuild骤降到1秒左右。

### smp

在此之前，我们需要有一个量化的指标证明我们做的是有意义的。这时候 [speed-measure-webpack-plugin](https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/speed-measure-webpack-plugin)就派上用场。它可以测量各个插件和loader的使用时间，量化指标。

根据官网的教程，用smp包裹webpack配置后，执行构建，会得到如下的信息：



![img](https://pic1.zhimg.com/80/v2-2c0a70b8644937ab4cfebd710a2f0158_720w.jpg)



我们可以从中得到优化后的时间和具体每个插件和loaders所花时间。

### cache-loader

添加完SMP后，我们要处理的第一个问题就是初始化构建的时间(这里指的是首次构建之后w，ebpack再次构建所花费的时间)，这里引入我们所需的第一个loader：[cache-loader](https://link.zhihu.com/?target=https%3A//github.com/webpack-contrib/cache-loader)

`cache-loader`是一个将之前的结果缓存到硬盘(数据库)的loader，意味着下一次执行webpack的时候，会有很显著显著的提升。

demo如下：

```js
{
  rules: [
    {
      test: /\.jsx?$/,
      use: [
        'cache-loader',
        'babel-loader',
      ],
    },
    {
      test: /\.scss$/,
      use: [
        'style-loader',
        'cache-loader',
        'css-loader',
        'postcss-loader',
        'sass-loader',
      ],
    },
  ]
}
```

增加后，我们能过省去大约75秒的首次构建时间。接下来，让我们处理rebuild时间，更新devtool就能达到比较明显的效果。

### webpack source maps

在webpack的配置中，我们可以找到一个devtool的配置，根据[文档](https://link.zhihu.com/?target=https%3A//webpack.js.org/configuration/devtool/)所示，它可以让我们：

> 选择一种风格的source map去增强debugger能力。不过这个功能会影响build和rebuild的速度。

换句话说，改变这个配置，你会得到对应的source maps结果，并且更重要的是，它会影响你得到bundle的等待时间。

根据使用经验来合理配置devtool，我们可以改变devtool的值从最慢的source-map -> eval-sourcemap，这个操作让我们把时间从14秒减少到3.5秒。

```js
{
  devtool: process.env.NODE_ENV === 'development'
    ? 'eval-source-map'
    : 'source-map'
}
```

文档上还有很多值。你可以选择最适合你的哪一种。

### transpile

另外，现在浏览器已经支持了大部分的最新语法和api，在开发环境中，我们并不需要那种完美的打包方案，比如下面这样：

```js
module.exports = {
  presets: [
    [
      '@babel/preset-env',
      {
        targets: [
          'last 1 chrome version',
          'last 1 safari version',
          'last 1 firefox version',
        ].join(', '),
      },
    ],
  ],
  // ...
}
```

上面三个简单的技巧，可以显著的减少构件时间，提升开发体验。

# 如何对bundle体积进行监控和分析？

使用 `webpack-bundle-analyzer` 生成 `bundle` 的模块组成图，显示所占体积。

`bundlesize` 工具包可以进行自动化资源体积监控。

# 如何提高webpack的构建速度

1. 多入口情况下，使用`CommonsChunkPlugin`来提取公共代码
2. 通过`externals`配置来提取常用库
3. 利用`DllPlugin`和`DllReferencePlugin`预编译资源模块 通过`DllPlugin`来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过`DllReferencePlugin`将预编译的模块加载进来。
4. 使用`Happypack` 实现多线程加速编译
5. 使用`webpack-uglify-parallel`来提升`uglifyPlugin`的压缩速度。 原理上`webpack-uglify-parallel`采用了多核并行压缩来提升压缩速度
6. 使用`Tree-shaking`和`Scope Hoisting`来剔除多余代码

# 文件指纹是什么？怎么用？

文件指纹是打包后输出的文件名的后缀。

- `Hash`：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改
- `Chunkhash`：和     Webpack 打包的 chunk 有关，不同的     entry 会生出不同的 chunkhash
- `Contenthash`：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变

## 有哪些常见的Loader？你用过哪些Loader？

- `raw-loader`：加载文件原始内容（utf-8）
- `file-loader`：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)
- `url-loader`：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值时返回其 publicPath，小于阈值时返回文件 base64 形式编码 (处理图片和字体)
- `source-map-loader`：加载额外的     Source Map 文件，以方便断点调试
- `svg-inline-loader`：将压缩后的     SVG 内容注入代码中
- `image-loader`：加载并且压缩图片文件
- `json-loader` 加载 JSON 文件（默认包含）
- `handlebars-loader`: 将 Handlebars 模版编译成函数并返回
- `babel-loader`：把 ES6 转换成 ES5
- `ts-loader`: 将 TypeScript 转换成 JavaScript
- `awesome-typescript-loader`：将     TypeScript 转换成 JavaScript，性能优于 ts-loader
- `sass-loader`：将 CSS 代码注入 JavaScript 中，通过 DOM 操作去加载 CSS
- `css-loader`：加载 CSS，支持模块化、压缩、文件导入等特性
- `style-loader`：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS
- `postcss-loader`：扩展 CSS     语法，使用下一代 CSS，可以配合 autoprefixer     插件自动补齐 CSS3 前缀
- `eslint-loader`：通过     ESLint 检查 JavaScript 代码
- `tslint-loader`：通过     TSLint检查 TypeScript 代码
- `mocha-loader`：加载     Mocha 测试用例的代码
- `coverjs-loader`：计算测试的覆盖率
- `vue-loader`：加载 Vue.js 单文件组件
- `i18n-loader`: 国际化
- `cache-loader`: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里

# 有哪些常见的Plugin？你用过哪些Plugin？

- define-plugin：定义环境变量 (Webpack4 之后指定 mode 会自动配置)
- ignore-plugin：忽略部分文件
- html-webpack-plugin：简化 HTML 文件创建 (依赖于     html-loader)
- web-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用
- uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)
- terser-webpack-plugin: 支持压缩 ES6 (Webpack4)
- webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度
- mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)
- serviceworker-webpack-plugin：为网页应用增加离线缓存功能
- clean-webpack-plugin: 目录清理
- ModuleConcatenationPlugin: 开启 Scope Hoisting
- speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)
- webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)

# 聊一聊Babel原理

大多数JavaScript Parser遵循 `estree` 规范，Babel 最初基于 `acorn` 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：

- 解析：将代码转换成 AST

- - 词法分析：将代码(字符串)分割为token流，即语法单元成的数组
- 语法分析：分析token流(上面生成的数组)并生成 AST

- 转换：访问     AST 的节点进行变换操作生产新的 AST

- - Taro就是利用      babel 完成的小程序语法转换

- 生成：以新的     AST 为基础生成代码

