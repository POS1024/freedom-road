# Computer和watch的区别

### 一、computer

当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性。

需要注意的是，就算在data中没有直接声明出要计算的变量，也可以直接在computed中写入。

计算属性默认只有getter，可以在需要的时候自己设定setter：

是一个计算属性,类似于过滤器,对绑定到view的数据进行处理

### 二、watch

watch是一个观察的动作

watch和computed很相似，watch用于观察和监听页面上的vue实例，当然在大部分情况下我们都会使用computed，但如果要在数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择。watch为一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。直接引用文档例子

## **计算属性computed :**

1. 支持缓存，只有依赖数据发生改变，才会重新进行计算
2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化
3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值
4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed
5. 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

## **侦听属性watch：**

1. 不支持缓存，数据变，直接会触发相应的操作；
2. watch支持异步；
3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
4. 当一个属性发生变化时，需要执行对应的操作；一对多；
5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，

immediate：组件加载立即触发回调函数执行，

deep: 深度监听，为了发现**对象内部值**的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。

# MVVM模式和MVC模式的区别

## MVC模式

1、代码分成三层

- Model： 数据层。
- Controller： 控制层
- View： 视图层（一般指页面中的dom展示）

### MVC的优缺点

优点：

> 1、把业务逻辑全部分离到Controller中，模块化程度高。当业务逻辑变更的时候，不需要变更View和Model，只需要Controller换成另外一个Controller就行了（Swappable Controller）。
> 2、观察者模式可以做到多视图同时更新。

缺点：

> 1、Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，Controller业务逻辑的正确性是无法验证的：Controller更新Model的时候，无法对View的更新操作进行断言。
> 2、View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的

## MVVM（Model-View-ViewModel）

它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。

### MVVM的优缺点

优点：

> 1、提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。
> 2、简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。

缺点：

> 1、过于简单的图形界面不适用，或说牛刀杀鸡。
> 2、对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。
> 3、数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。

# NextTick原理

### 使用场景

在进行获取数据后，需要对新视图进行下一步操作或者其他操作时，发现获取不到 DOM

1.在Vue生命周期的created()钩子函数进行DOM操作一定要放到Vue.nextTick()的回调函数中。

在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题。

2.在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。

### 原理

在 Vue 中多么频繁地修改数据，最后 Vue 页面只会更新一次

被修改时，会通知所有收集到的 watcher 进行更新（watcher.update）

当数据变化后，把 watcher.update 函数存放进 nextTick 的 回调数组中，并且会做过滤。

通过 watcher.id 来判断 回调数组 中是否已经存在这个 watcher 的更新函数

不存在，才 push

之后 nextTick 遍历回调数组，便会执行了更新

vue在内部尝试对异步队列使用原生的Promise.then和MessageChannel 方法，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。





参考资料：https://zhuanlan.zhihu.com/p/69641232

# Vue 组件 data 为什么必须是函数

因为js本身的特性带来的，如果 `data` 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 `data` 作为一个函数返回一个对象，那么每一个实例的 `data` 属性都是独立的，不会相互影响了

# Vue3.0 VS Vue2.x 有哪些不同

## Vue3.0 新功能

- **[Composition API](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/composition-api-introduction.html)**----组合式 API，包括`setup()`等
- **[Reactivity API](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/reactivity.html%23what-is-reactivity)**----响应式系统 API，包括`ref()`等
- **[Teleport](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/teleport.html)**---内置了传送组件
- **[Fragments](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/migration/fragments.html)**---`template`里可以存在多个根DOM（或组件），Vue2.x 的时候只能存在1个
- **[Emits](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/component-custom-events.html)** 组件中添加了自定义事件参数
- `v-model` 的修改，可以传入参数，因此可以使用多个`v-model`，还可以自定义修饰符，移除了`.sync`修饰符。
- **`createRenderer` API from `@vue/runtime-core` to create custom renderers**

## 被移除的内容

- 移除了`keyCode`修饰符，可以用`kebab-case`名来代替（比如`.delete/.enter`)
- 移除了实例上的`$on`, `$off` 和 `$once`[方法](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/migration/keycode-modifiers.html)
- 移除了[过滤器](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/migration/filters.html)`Filters`，Vue3.0 建议使用 `computed` 来实现
- 移除了[Inline templates attributes](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/migration/inline-template-attribute.html)
- 移除了`.sync`修饰符

## API 参考/新增以及被废弃的 API

---【*加粗斜体代表新增，删除线*~~*代表移除（知乎不支持删除线，允悲），斜体代表有改动*】---

## 实例 API（从全局 API 拆分出来 的）

在 Vue 3 中，会全局改变 Vue 行为的 API 移到了实例（通过 `createApp` 创建）的 API 中。它们只会影响该实例。 如下：`**mount**`、`**provide**`、`**unmount**`、`*directive*`（自定义指令的生命周期钩子更名了）、`component`、`config`、`mixin`、`use`

## 全局 API

**`createApp`**、**`h`**（`render()`的别名）、**`defineComponent`**、**`defineAsyncComponent`**、**`resolveComponent`**（只能在渲染函数里使用）、**`resolveDirective`**（只能在渲染函数里使用）、**`withDirectives`**（只能在渲染函数里使用）、**`createRenderer`**（只能在渲染函数里使用）、`nextTick`、~~`extend`~~、~~`filter`~~、~~`compile`~~、~~`observable`~~（被`reactive`替代）、~~`version`~~、~~`set`~~

## 选项

### Data

**`emits`**、`data`、`props`、`computed`、`methods`、`watch`、~~`propsData`~~

### DOM

`template`、`render`、~~`el`~~、~~`renderError`~~

### 生命周期钩子

```js
beforeCreate`、`created`、`beforeMount`、`mounted`、`beforeUpdate`、`updated`、`activated`、`deactivated`、`beforeUnmount`（~~`beforeDestroy`~~）、`unmounted`（~~`destroyed`~~）、`errorCaptured`、`**renderTracked**`、`**renderTriggered**
```

### 资源

`directives`、`components`、~~`filters`~~

### 组合

`mixins`、`extends`、`provide / inject`、`**setup**`、~~`parent`~~

### 其他

`name`、`inheritAttrs`、~~`delimiters`~~、~~`functional`~~、~~`model`~~、~~`comments`~~

## 实例属性

`$data`、`$props`、`$el`、`$options`、`$parent`、`$root`、`$slots`、`$refs`、`$attrs`、~~`$children`~~、~~`$scopedSlots`~~、~~`$isServer`~~、~~`$listeners`~~

## 实例方法（生命周期也被合并到这里了）

`$watch`、`$emit`、`$forceUpdate`、`$nextTick`、~~`$set`~~（文档里没有找到移除 `set` 的描述，用 `$forceUpdate`吧）、~~`$delete`~~、~~`$mount`~~、~~`destroy`~~

## 指令

`v-text`、`v-html`、`v-show`、`v-if`、`v-else`、`v-else-if`、`v-for`、`v-on`、`v-bind`、`*v-model*`、`v-slot`、`v-pre`、`v-cloak`、`v-once`、`**v-is**`（本来是通过`is`实现）

## 特殊属性

`key`、`ref`、`is`、~~`slot`~~、~~`slot-scope`~~、~~`scope`~~（这3个在 Vue 2.6 以上就被废弃了）

## 内置的组件

```
component`、`transition`、`transition-group`、`keep-alive`、`slot`、`**teleport**
```

## 【新增】响应式系统 API（Reactivity API ）

### 基本响应式 APIs

**`reactive`**、**`readonly`**、**`isProxy`**、**`isReactive`**、**`isReadonly`**、**`toRaw`**、**`markRaw`**、**`shallowReactive`**、**`shallowReadonly`**

### refs

**`ref`**、**`unref`**、**`toRef`**、**`toRefs`**、**`isRef`**、**`customRef`**、**`shallowRef`**

### Computed and watch

**`computed`**、**`watchEffect`**、**`watch`**

## 【新增】组合式 API（Composition API ）

**`setup`**、**`onBeforeMount`**、**`onMounted`**、**`onBeforeUpdate`**、**`onUpdated`**、**`onBeforeUnmount`**、**`onUnmounted`**、**`onErrorCaptured`**、**`onRenderTracked`**、**`onRenderTriggered`**、**`provide`**、**`inject`**

以下是我对比 [Vue2.x](https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2) 版本文档的教程部分得出的一部分差异，欢迎补充或者提供修改建议（因为暂时还没找到中文版，所以只是自己的理解，已经在知识点上插入了文档的该部分链接，可以直接查看原文）。

## 基础用法

## 创建 Vue实例 的方法：

在 **Vue2.x** 中，通过 **[new Vue](https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/instance.html)** 创建 Vue 的实例，并且通过传入 **el参数** 进行挂载 DOM

```js
<!-- Vue2.x 创建实例 -->
var vm = new Vue({
  // 选项
})

<!-- Vue2.x 挂载DOM -->
var vm = new Vue({
  el: '#app',
  data: {a:1}
})
```

在 **Vue3.0** 中，通过 **[createApp](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/instance.html%23instance-lifecycle-hooks)** 方法创建 Vue 的实例，创建实例后可以把这个容器传给 **mount** 方法来挂载

```js
<!-- Vue3.0 创建实例 -->
Vue.createApp(/* options */)

<!-- Vue3.0 挂载DOM -->
Vue.createApp(/* options */).mount('#app')
```

## 生命周期

生命周期没有太大的改变，由于创建实例的方法改变了，因此有一些细微的差别。

值得注意的是：在 **[Vue2.x](https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/instance.html)** 中，销毁实例的两个钩子是 **beforeDestory** 以及 **destoryed**，而在 **[Vue3.0](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/instance.html%23instance-lifecycle-hooks)** 中这两个钩子的名字变更为 **beforeUnmount** 和 **unmounted**。

Vue2.x 生命周期

![img](https://pic4.zhimg.com/80/v2-2a7828efd6ca107aaaed51eca052c7eb_720w.jpg)



Vue3.0 生命周期



![img](https://pic3.zhimg.com/80/v2-3c713f00d5e436559b9a426b8a65e2b6_720w.jpg)



## Provide / inject

Vue3.0 在教程中添加了对`Provide / inject`的[描述](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/component-provide-inject.html)

![img](https://pic3.zhimg.com/80/v2-eacc7535decbb5695865c4b6883390fa_720w.jpg)



## 动态组件

Vue2.x 和 Vue3.0 都仍是采用通过给 Vue 的 元素加一个特殊的 [is](https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/components.html) 属性来实现

```js
<!-- 组件会在 `currentTabComponent` 改变时改变 -->
<component v-bind:is="currentTabComponent"></component>
```

但是对于解析 DOM 模板，诸如`<ul>`、`<table>`等限制内部元素的特殊情况，相比 **Vue2.x** 中是通过绑定 **is** 属性， **Vue3.0** 提供的是 **[v-is](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/component-basics.html%23listening-to-child-components-events)** 指令

```js
<!-- Vue2.x 使用 is 属性 -->
<table>
  <tr is="blog-post-row"></tr>
</table>
<!-- Vue3.0 使用 v-is 指令 -->
<table>
  <tr v-is="'blog-post-row'"></tr>
</table>
```

## 自定义事件

Vue2.x 和 Vue3.0 都仍是通过`$emit('myEvent')`[触发事件](https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/components-custom-events.html)，通过`v-on:myEvent`来监听事件，不同的是，Vue3.0 在组件中提供了 **[emits](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/component-custom-events.html%23event-names)** 属性来定义事件

```js
<!-- Vue3.0 自定义事件 -->
app.component('custom-form', {
  emits: ['in-focus', 'submit']
})
```

甚至你可以在自定义事件中添加校验，这时需要把 `emits` 设置为对象，并且为事件名分配一个函数，该函数接收传递给 `$emit` 调用的参数，并返回一个布尔值以指示事件是否有效

```js
<!-- Vue3.0 为自定义事件添加校验 -->
app.component('custom-form', {
  emits: {
    // No validation
    click: null,

    // Validate submit event
    submit: ({ email, password }) => {
      if (email && password) {
        return true
      } else {
        console.warn('Invalid submit event payload!')
        return false
      }
    }
  },
  methods: {
    submitForm() {
      this.$emit('submit', { email, password })
    }
  }
})
```

## 自定义组件的 `v-model`

在 [Vue2.x](https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/components-custom-events.html%23%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model) 中， `v-model` 默认会利用 `value` 作为 prop 名以及 `input` 作为触发的 event 名。对于特殊的场景，也可以通过 `model` 选项来指定 prop 名和 event 名（注意这时仍需在 props 里声明这个 prop）

```js
<!-- Vue2.0 自定义 v-model -->
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `
})
```

**请注意**，在 [Vue3.0](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/component-custom-events.html%23validate-emitted-events) 中， `v-model` 默认会利用 `modelValue` 作为 prop 名以及 `update:modelValue` 作为触发的 event 名。

支持给每个 `v-model` 传入一个**参数**，这样就可以在一个组件上同时使用多个 v-model

```js
<!-- Vue3.0 自定义 v-model 并且传入参数 -->
<my-component v-model:foo="bar" v-model:name="userName"></my-component>
```

甚至还可以为 v-model 设置**自定义修饰符**，默认是通过在props中定义 `modelModifiers` 对象来接受修饰符，因此你可以通过修饰符来设置你想要的不同的事件触发机制

```js
<!-- Vue3.0 自定义修饰符默认接收方式 -->
<div id="app">
  <my-component v-model.capitalize="myText"></my-component>
  {{ myText }}
</div>

const app = Vue.createApp({
  data() {
    return {
      myText: ''
    }
  }
})

app.component('my-component', {
  props: {
    modelValue: String,
    modelModifiers: {
      default: () => ({})
    }
  },
  methods: {
    emitValue(e) {
      let value = e.target.value
      if (this.modelModifiers.capitalize) {
        value = value.charAt(0).toUpperCase() + value.slice(1)
      }
      this.$emit('update:modelValue', value)
    }
  },
  template: `<input
    type="text"
    v-bind:value="modelValue"
    v-on:input="emitValue">`
})

app.mount('#app')
```

当然，对于传入了参数的 `v-model` ，则需要在props里面配置`arg + "Modifiers"`来接收这个带参数的 `v-model` 的修饰符

```js
<!-- Vue3.0 自定义参数的自定义修饰符 -->
<my-component v-model:foo.capitalize="bar"></my-component>

app.component('my-component', {
  props: ['foo', 'fooModifiers'],
  template: `
    <input type="text" 
      v-bind:value="foo"
      v-on:input="$emit('update:foo', $event.target.value)">
  `,
  created() {
    console.log(this.fooModifiers) // { capitalize: true }
  }
})
```

## 混入 (mixin)

Vue2.x [混入](https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/mixins.html)的方式 通过 `Vue.extend({mixins: [myMixin]})` 定义一个使用混入对象的组件

```js
// 定义一个混入对象
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}

// 定义一个使用混入对象的组件
var Component = Vue.extend({
  mixins: [myMixin]
})

var component = new Component() // => "hello from mixin!"
```

而 [Vue3.0](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/mixins.html%23basics) 则和创建一个实例相似，通过 `Vue.createApp({mixins: [myMixin]})` 定义一个使用混入对象的组件

```js
// 定义一个混入对象
const myMixin = {
  created() {
    this.hello()
  },
  methods: {
    hello() {
      console.log('hello from mixin!')
    }
  }
}

// 定义一个使用混入对象的组件
const app = Vue.createApp({
  mixins: [myMixin]
})

app.mount('#mixins-basic') // => "hello from mixin!"
```

## 自定义指令

**Vue2.x** 的指令定义对象包含 **[5](https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/custom-directive.html)** 个钩子：

- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
- `update`：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。
- `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。
- `unbind`：只调用一次，指令与元素解绑时调用。

**Vue3.0** 的指令对象包含 **[6](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/custom-directive.html%23intro)** 个钩子：

- `beforeMount`：指令第一次绑定到元素时调用。在这里可以进行**一次性**的初始化设置。
- `mounted`：当被绑定元素插入父节点时调用。
- `beforeUpdate`：在更新所在组件的VNode**之前**调用。
- `updated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。
- `beforeUnmount`：在绑定元素的父组件卸载之前调用。（对比 Vue2.x **新增**）
- `unmounted`：只调用一次，指令与元素解绑且父组件已卸载时调用。

在 Vue3.0 中，由于对片段的支持，组件可能会存在多个根节点，这时使用自定义指令可能会产生问题。自定义指令对象包含的钩子会被包装并作为 Vnode 生命周期钩子注入到 Vnode 的数据中。

```js
<!-- Vue3.0 自定义指令对象包含的钩子包装后 -->
{
  onVnodeMounted(vnode) {
    // call vDemo.mounted(...)
  }
}
```

当在组件中使用自定义指令时，这些`onVnodeXXX`钩子将作为无关属性直接传递给组件，可以像这样在模板中直接挂接到元素的生命周期中`（这里不太明白，之后试验过再来更新）`

```js
<div @vnodeMounted="myHook" />
```

当子组件在内部元素上使用 `v-bind="$attrs"` 时，它也将应用它上面的任何自定义指令。

## 内置的传送组件 [Teleport](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/teleport.html)

Vue3.0 内置`<teleport>`的组件可以传送一段模板到其他位置，

```js
<!-- Vue3.0 <teleport>传送组件 -->
<body>
  <div id="app" class="demo">
    <h3>Move the #content with the portal component</h3>
    <div>
      <teleport to="#endofbody">
        <p id="content">
          This should be moved to #endofbody.
        </p>
      </teleport>
      <span>This content should be nested</span>
    </div>
  </div>
  <div id="endofbody"></div>
</body>
```

如果`<teleport>`包含Vue组件，它将仍然是`<teleport>`父组件的逻辑子组件，也就是说，即使在不同的地方呈现子组件，它仍将是父组件的子组件，并将从父组件接收 `prop`。

**使用多个传送组件** 会采用累加的逻辑，像这样

```js
<teleport to="#modals">
  <div>A</div>
</teleport>
<teleport to="#modals">
  <div>B</div>
</teleport>

<!-- 结果 B 渲染在 A 后面 -->
<div id="modals">
  <div>A</div>
  <div>B</div>
</div>
```

## 渲染函数

Vue2.x 的[渲染函数](https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/render-function.html)的参数是`createElement`

Vue3.0 的[渲染函数](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/render-function.html)的参数`createVNode`（这个名字更接近它实际的意义，返回虚拟 DOM）

同样将`h`作为别名，在 Vue3.0 中可以直接通过 `Vue.h` 获取

```js
const app = Vue.createApp({})

app.component('anchored-heading', {
  render() {
    const { h } = Vue

    return h(
      'h' + this.level, // tag name
      {}, // props/attributes
      this.$slots.default() // array of children
    )
  },
  props: {
    level: {
      type: Number,
      required: true
    }
  }
})
```

**事件 & 按键修饰符** Vue2.x 对于 .passive、.capture 和 .once 这些事件修饰符，提供了相应的前缀可以用于 on：、 | 修饰符 | 前缀 |------|------------ | `.passive` | &
| `.capture` | !
| `.once` | ~ | `.capture.once`或 `.once.capture` | ~!

```js
<!-- Vue2.x 对修饰符使用前缀 -->
on: {
  '!click': this.doThisInCapturingMode,
  '~keyup': this.doThisOnce,
  '~!mouseover': this.doThisOnceInCapturingMode
}
```

而 Vue3.0 则是使用对象语法

```js
<!-- Vue3.0 对修饰符使用对象语法 -->
render() {
  return Vue.h('input', {
    onClick: {
      handler: this.doThisInCapturingMode,
      capture: true
    },
    onKeyUp: {
      handler: this.doThisOnce,
      once: true
    },
    onMouseOver: {
      handler: this.doThisOnceInCapturingMode,
      once: true,
      capture: true
    },
  })
}
```

## 插件

**[开发插件](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/plugins.html)** Vue3.0 仍需要暴露一个 `install`方法，传入两个参数，第一个参数是通过`Vue.createApp`构造的对象，第二个可选参数是用户传入的`options`

```js
// plugins/i18n.js
export default {
  install: (app, options) => {
  // Plugin code goes here
  }
}
```

插件中通过暴露出的`app.config.globalProperties`属性注册全局方法

```js
// plugins/i18n.js
<!-- 通过 app.config.globalProperties 全局注入 translate 方法 -->
export default {
  install: (app, options) => {
    app.config.globalProperties.$translate = (key) => {
      return key.split('.')
        .reduce((o, i) => { if (o) return o[i] }, i18n)
    }
  }
}
```

还可以通过`inject`来为用户提供方法或属性

```js
// plugins/i18n.js
<!-- 这样组件里就可以通过 inject 访问 i18n 和 options -->
export default {
  install: (app, options) => {
    app.config.globalProperties.$translate = (key) => {
      return key.split('.')
        .reduce((o, i) => { if (o) return o[i] }, i18n)
    }

    app.provide('i18n')
  }
}

<!-- 然后就可以通过 inject['i18n'] 把 i18n 注入组件并访问 -->
```

**使用插件** 仍然是通过 `use()` 方法，可以接受两个参数，第一个参数是要使用的插件，第二个参数可选，会传入到插件中去。

```js
import { createApp } from 'vue'
import App from './App.vue'
import i18nPlugin from './plugins/i18n'

const app = createApp(App)
const i18nStrings = {
  greetings: {
    hi: 'Hallo!'
  }
}

app.use(i18nPlugin, i18nStrings)
app.mount('#app')
```

## 响应式原理

## 响应式系统

众所周知，[Vue2.x](https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/reactivity.html) 是通过 `Object.defineProperty`结合订阅/发布模式实现的。

给 Vue 实例传入 `data` 时，Vue 将遍历`data` 对象所有的 `property`，并使用 `Object.defineProperty` 把这些属性全部转为 `getter`/`setter`，在属性被访问和修改时追踪到依赖。每个组件实例都对应一个 `watcher` 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。当依赖项的 `setter` 触发时，会通知 `watcher`，从而使它关联的组件重新渲染。



![img](https://pic3.zhimg.com/80/v2-28ace4b7d5f847bbfef5ea50e027f7f2_720w.jpg)

、 而 [Vue3.0](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/reactivity.html%23what-is-reactivity) 则是采用 ES6 的 `Proxy` 代理来拦截对目标对象的访问。 给 Vue 实例传入 `data` 时，Vue 会将其转换为`Proxy`。它能使 Vue 在访问或修改属性时执行**依赖追踪**以及**更改通知**。每个属性都被视为一个依赖项。 在初次渲染后，组件将追踪依赖（也就是它在渲染时访问过的属性）。换句话说，组件成为这些属性的**订阅者**。当代理拦截到 `set` 操作时，该属性将通知其订阅者重新渲染。

```js
const dinner = {
  meal: 'tacos'
}

const handler = {
  get(target, prop, receiver) {
    track(target, prop) // Track the function that changes it 依赖项跟踪
    return Reflect.get(...arguments)
  },
  set(target, key, value, receiver) {
    trigger(target, key) // Trigger the function so it can update the final value 更改通知
    return Reflect.set(...arguments)
  }
}

const proxy = new Proxy(dinner, handler)
console.log(proxy.meal)

// intercepted!
// tacos
```

值得注意的是，原始对象与代理对象是**不相等**的

```js
const obj = {}
const wrapped = new Proxy(obj, handlers)
console.log(obj === wrapped) // false
```

## 响应式基础原理 Reactivity Fundamentals

### 声明响应式状态`reactive`

`reactive`方法接收一个普通对象作为参数，然后返回该普通对象的响应式代理（等同于 Vue2.x 中的 `Vue.observable()` ）以创建一个响应式属性。响应式转换是“深层的”，返回的代理对象不等于原始对象。模板编译的过程中 `render` 方法用的就是这些响应式属性。

```js
import { reactive } from 'vue'

// reactive state
const state = reactive({
  count: 0
})
```

还可以创建只读的响应式属性，也是深层的，对象内部任何嵌套的属性也都是只读的。

```js
const original = reactive({ count: 0 })

const copy = readonly(original)

// mutating original will trigger watchers relying on the copy
original.count++

// mutating the copy will fail and result in a warning
copy.count++ // warning: "Set operation on key 'count' failed: target is readonly."
```

### 创建独立的响应式属性`refs`

`ref`方法接受一个原始值参数，同样也会返回一个响应式的可变 ref 对象。如果是原始类型的值，由于原始类型的值是按值传递而不是按引用传递，会像是把原始类型的值包装成了一个对象一样以保证响应式，但这个对象只包含唯一的属性`value`。而对于引用类型，则会调用 `reactive` 方法进行深层响应转换。

```js
import { ref } from 'vue'

const count = ref(0)
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

当一个`ref`作为在渲染上下文中返回的属性且在模板中被访问时，会自动解套内部的`value`，因此无需再使用`xx.value`的方式来访问，这样就像访问一个普通属性一样。要`注意`，自动解套 `value` 只发生在当嵌套响应式的**对象**中时，从数组或`Map`等原生集合类中访问时不会自动解套，仍需要`.value`。

```js
<template>
  <div>
    <span>{{ count }}</span>
    <button @click="count ++">Increment count</button>
  </div>
</template>

<script>
  import { ref } from 'vue'
  export default {
    setup() {
      const count = ref(0)
      return {
        count
      }
    }
  }
</script>
```

另外如果将一个新的`ref`赋值给现有的属性，那将替换掉旧的`ref`

```js
const otherCount = ref(2)

state.count = otherCount
console.log(state.count) // 2
console.log(count.value) // 1
```

## 计算

### `computed`方法

通过`computed`方法可以直接[创建一个计算值](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/reactivity-computed-watchers.html%23computed-values)，接收一个`getter`函数作为参数并且返回一个不可手动修改的响应式对象。

```js
const count = ref(1)
const plusOne = computed(() => count.value++)

console.log(plusOne.value) // 2

plusOne.value++ // error
```

或者可以传入一个带有`getter`和`setter`方法的对象来创建一个可以手动修改的响应式对象

```js
const count = ref(1)
const plusOne = computed({
  get: () => count.value + 1,
  set: val => {
    count.value = val - 1
  }
})

plusOne.value = 1
console.log(count.value) // 0
```

## 监听

### `watchEffect`方法

`watchEffect`[方法](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/reactivity-computed-watchers.html%23watcheffect)它可以侦听依赖，它会立即运行传入的函数，并且跟踪这个函数的依赖项，当依赖项更新时，立即再次执行这个函数。

```js
const count = ref(0)

watchEffect(() => console.log(count.value))
// -> logs 0

setTimeout(() => {
  count.value++
  // -> logs 1
}, 100)
```

当`watchEffect`在组件的`setup()`或生命周期钩子中被调用时，侦听器会自动链接到该组件的生命周期，并且在组件卸载时自动停止。或者可以通过显式调用`watchEffect`的返回值以停止侦听。

```js
const stop = watchEffect(() => {
  /* ... */
})
Vue3
// 之后
stop()
```

### Side Effect Invalidation 清除副作用

有时`watchEffect`中执行的方法可能是异步的，`watchEffect`传入的函数可以接收一个`onInvalidate`函数作为参数来注册清理失效时的回调，它将会在`watchEffect`重新执行时或者`watchEffect`被终止（如果在`setup()`或`生命周期钩子`中使用了`watchEffect`，则在组件卸载时）时执行。

```js
watchEffect(onInvalidate => {
  const token = performAsyncOperation(id.value)
  onInvalidate(() => {
    // id 改变时 或 停止侦听时
    // 取消之前的异步操作
    token.cancel()
  })
})
```

注意`setup()`将在组件挂载前调用，因此如果想要在`watchEffect`中使用 `DOM` （或者组件），请在挂载的钩子中声明`watchEffect`

```js
onMounted(() => {
  watchEffect(() => {
    // access the DOM or template refs
  })
})
```

还可以为`watchEffect`传入额外的对象作为参数。 比如通过设置`flush`来设置`watchEffect`是异步执行还是在组件更新前执行

```textjs
// 同步运行
watchEffect(
  () => {
    /* ... */
  },
  {
    flush: 'sync'
  }
)

// 组件更新前执行
watchEffect(
  () => {
    /* ... */
  },
  {
    flush: 'pre'
  }
)
```

`onTrack`（追踪依赖时调用）和`onTrigger`（依赖改变触发了`watchEffect`的方法时触发）参数可以用来调试`watchEffect`的行为

```js
watchEffect(
  () => {
    /* side effect */
  },
  {
    onTrigger(e) {
      debugger
    }
  }
)
```

`watch`相比`watchEffect`,`watch`是惰性的，更明确哪些状态的改变会触发侦听器重新运行，并且可以访问被侦听属性的变化前后的值。

```js
// 侦听一个 getter
const state = reactive({ count: 0 })
watch(
  () => state.count,
  (count, prevCount) => {
    /* ... */
  }
)

// 直接侦听一个 ref
const count = ref(0)
watch(count, (count, prevCount) => {
  /* ... */
})
// 侦听多个数据源
watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {
  /* ... */
})
```

## 组合式 API（Composition API）

在正常的业务中我们常常会抽离可复用的组件，比如过滤功能、搜索功能、业务列表等等。但是当某个组件组合得很庞大时，需要关注的逻辑列表（引入的组件）也会相应的增加，这可能导致难以阅读和理解，尤其对于那些最初没有编写它们的人。因此我们想要组合起与逻辑有关系的代码，这也时`Composition API` 的[用途](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/composition-api-introduction.html%23why-composition-api)。

```js
<!-- 没有 Composition API 时我们通常这样做 -->
<!-- 将逻辑关系标记为相同的数字 -->

// src/components/UserRepositories.vue

export default {
  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },
  props: {
    user: { type: String }
  },
  data () {
    return {
      repositories: [], // 1
      filters: { ... }, // 3
      searchQuery: '' // 2
    }
  },
  computed: {
    filteredRepositories () { ... }, // 3
    repositoriesMatchingSearchQuery () { ... }, // 2
  },
  watch: {
    user: 'getUserRepositories' // 1
  },
  methods: {
    getUserRepositories () {
      // using `this.user` to fetch user repositories
    }, // 2
    updateFilters () { ... }, // 3
  },
  mounted () {
    this.getUserRepositories() // 1
  }
}
```

## [setup 组件参数](https://link.zhihu.com/?target=https%3A//v3.vuejs.org/guide/composition-api-introduction.html%23setup-component-option)

`setup` 是一个新的组件参数，在组件内使用并且作为 `Composition API` 的入口点。

`setup`方法接受2个参数。 第一个参数是 `props` ，它在 `setup` 内部也是响应式的（注意不要对 `props` 直接使用解构赋值，这样会破坏响应式，但是可以使用 `toRefs`来实现安全的解构）。

```js
// MyBook.vue

import { toRefs } from 'vue'

setup(props) {
    const { title } = toRefs(props)

    console.log(title.value)
}
```

第二个参数是 `context` ，它是一个普通的对象（不是响应式的）并且暴露出3个组件属性。

```js
// MyBook.vue

export default {
  setup(props, context) {
    // Attributes (Reactive Property)
    console.log(context.attrs)

    // Slots (Reactive Property)
    console.log(context.slots)

    // Emit Events (Method)
    console.log(context.emit)
  }
}
```

`setup`会在组件实例创建前，props初始化后被执行，因此只能访问 `props` 、`attrs` 、`slots` 、`emit`，而无权访问组件内部的 `data`、`computed`、 `methods`。注意`setup()`内部的`this`不会是Vue的实例的引用。

`setup`可以返回一个对象，它的所有属性都将暴露给其他的组件选项（ `computed` 的属性、 `methods` 、生命周期钩子等）以及组件模板。也可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态：

`Composition API` 也包含了类似组件参数的生命周期钩子函数，但会以前缀为 `onXXX` 这样的名字，像是 `mounted` 对应的是 `onMounted`，接受一个回调，这个回调会在组件的钩子被调用时执行。 | Options API | `setup` 里的钩子 | | ----------------- | ------------------------ | | `beforeCreate` | 不需要 | | `created` | 不需要 | | `beforeMount` | `onBeforeMountonMounted` | | `mounted` | `onMounted` | | `beforeUpdate` | `onBeforeUpdate` | | `updated` | `onUpdated` | | `beforeUnmount` | `onBeforeUnmount` | | `unmounted` | `onUnmounted` | | `errorCaptured` | `onErrorCaptured` | | `renderTracked` | `onRenderTracked` | | `renderTriggered` | `onRenderTriggered` | 由于 `setup` 是围绕 `beforeCreate` 和 `created` 生命周期钩子运行的，也就是说将在这两个钩子中编写的任何代码都应该直接在 `setup` 中编写。

`Composition API` 还包含 `watch` 方法，接受3个参数，第一个参数是一个我们要真侦听的响应式对象或者包含`getter`的函数，第二个参数是一个回调，第三个参数是可选的配置选项。

还有前文提到的 `Composition API` 的 `computed` 方法可以在组件外部创建一个计算属性

因此我们可以把上面的栗子重写成这样，无论何时我们调用 `getUserRepositories` 方法，`repositories` 都会响应式地进行改变，视图也将更新。

```js
// src/composables/useUserRepositories.js

import { fetchUserRepositories } from '@/api/repositories'
import { ref, onMounted, watch, toRefs } from 'vue'

export default function useUserRepositories(user) {
  // 数据列表（创建一个响应式对象）
  const repositories = ref([])

  // 更新数据列表的方法
  const getUserRepositories = async () => {
    repositories.value = await fetchUserRepositories(user.value)
  }

  onMounted(getUserRepositories)

  // 在 user 上设置一个侦听器
  watch(user, getUserRepositories)

  // 返回列表和方法，以在其他组件选项中访问它们
  return {
    repositories,
    getUserRepositories
  }
}


// src/components/UserRepositories.vue
// 在组件中引入 useUserRepositorie）， useRepositoryNameSearch和 useRepositoryFilters
import { toRefs } from 'vue'
import useUserRepositories from '@/composables/useUserRepositories'
import useRepositoryNameSearch from '@/composables/useRepositoryNameSearch'
import useRepositoryFilters from '@/composables/useRepositoryFilters'

export default {
  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },
  props: {
    user: { type: String }
  },
  setup(props) {
    const { user } = toRefs(props)

    const { repositories, getUserRepositories } = useUserRepositories(user)

    const {
      searchQuery,
      repositoriesMatchingSearchQuery
    } = useRepositoryNameSearch(repositories)

    const {
      filters,
      updateFilters,
      filteredRepositories
    } = useRepositoryFilters(repositoriesMatchingSearchQuery)

    return {
      // 只关心过滤后的结果，因此可以以 repositories 这样的名称暴露出去
      repositories: filteredRepositories,
      getUserRepositories,
      searchQuery,
      filters,
      updateFilters
    }
  }
}
```

在`setup`中还可以使用 `provide` / `inject` ，甚至可以 `provide` 一个响应式状态，注意因为单向数据流，所以不要在 `inject` 时注入为响应式状态，而是在`provide`时就提供为响应式状态。

```js
import { ref, reactive } from 'vue'

// in provider
setup() {
  const book = reactive({
    title: 'Vue 3 Guide',
    author: 'Vue Team'
  })
  const year = ref('2020') // 也可以提供一个响应式状态，尽量在provide时注入为响应式状态

  provide('book', book)
  provide('year', year) // 如果要提供多个值，可以之后再次调用 provide
}

// in consumer
setup() {
  const book = inject('book', 'Eloquent Javasctipt') /* 可选的参数默认值 */
  const year = inject('year') 

  return { book, year }
}
```

在 `setup` 中， 响应式 `refs` 和模板的 `refs` 是统一的，为了获得对模板内元素或组件实例的引用，可以在 `setup` 声明一个 ref 并返回它。像这样我们将 `root` 暴露在渲染上下文中并通过 `ref="root"` 将绑定到 `div` 作为其 `ref` 。在虚拟 DOM 算法中如果虚拟节点的 ref 对应上了渲染上下文的 ref，那么就会把虚拟节点对应的元素或者组件实例分配给这个 ref，这是在虚拟 DOM 挂载或修改时执行的，因此模板 ref 仅在渲染初始化后才能访问。

```js
<template>
  <div ref="root">This is a root element</div>
  <div v-for="(item, i) in list" :ref="el => { divs[i] = el }">
    {{ item }}
  </div>
</template>

<script>
  import { ref, onMounted } from 'vue'

  export default {
    setup() {
      const root = ref(null)
      const divs = ref([])

      onMounted(() => {
        // 在初始化后 DOM 元素将会被分配给 ref
        console.log(root.value) // <div>This is a root element</div>
      })
      // 在每次更新前重置引用
      onBeforeUpdate(() => {
        divs.value = []
      })

      return {
        root,
        divs
      }
    }
  }
</script>
```

## 响应式系统工具集

### `unref`

如果参数是一个 `ref` 则返回它的 `value`，否则返回参数本身。它是 `val = isRef(val) ? val.value : val` 的语法糖。

```text
function useFoo(x: number | Ref<number>) {
  const unwrapped = unref(x) // unwrapped 一定是 number 类型
}
```

### `toRef`

`toRef` 可以用来为一个 reactive 对象的属性创建一个 ref。这个 ref 可以被传递并且能够保持响应性。当您要将一个 prop 中的属性作为 ref 传给组合逻辑函数时，toRef 就派上了用场。

```js
const state = reactive({
  foo: 1,
  bar: 2,
})

const fooRef = toRef(state, 'foo')

fooRef.value++
console.log(state.foo) // 2

state.foo++
console.log(fooRef.value) // 3
```

### `toRefs`

把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应。当想要从一个组合逻辑函数中返回响应式对象时，用 toRefs 是很有效的，该 API 让消费组件可以 解构 / 扩展（使用 ... 操作符）返回的对象，并不会丢失响应性。

### `isRef`

检查一个值是否为一个 ref 对象。

### `isProxy`

检查一个对象是否是由 `reactive` 或者 `readonly` 方法创建的代理。

### `isReactive`

检查一个对象是否是由 `reactive` 创建的响应式代理。如果这个代理是由 `readonly` 创建的，但是又被 `reactive` 创建的另一个代理包裹了一层，那么同样也会返回 `true`。

### `isReadonly`

检查一个对象是否是由 `readonly` 创建的只读代理。

```js
const state = reactive({
  foo: 1,
  bar: 2,
})

const stateAsRefs = toRefs(state)
/*
stateAsRefs 的类型如下:

{
  foo: Ref<number>,
  bar: Ref<number>
}
*/

// ref 对象 与 原属性的引用是 "链接" 上的
state.foo++
console.log(stateAsRefs.foo) // 2

stateAsRefs.foo.value++
console.log(state.foo) // 3
```

## 高级响应式系统 API

### `customRef`

`customRef` 用于自定义一个 `ref`，可以显式地控制依赖追踪和触发响应，接受一个工厂函数，两个参数分别是用于追踪的 `track` 与用于触发响应的 `trigger`，并返回一个一个带有 `get` 和 `set` 属性的对象 这是一个使用自定义 ref 实现带防抖功能的 v-model的栗子

```js
<input v-model="text" />

function useDebouncedRef(value, delay = 200) {
  let timeout
  return customRef((track, trigger) => {
    return {
      get() {
        track()
        return value
      },
      set(newValue) {
        clearTimeout(timeout)
        timeout = setTimeout(() => {
          value = newValue
          trigger()
        }, delay)
      },
    }
  })
}

export default {
  setup() {
    return {
      text: useDebouncedRef('hello'),
    }
  },
}
```

### `markRaw`

显式标记一个对象为“永远不会转为响应式代理”，函数返回这个对象本身。

### `shallowReactive`

只为某个对象的私有（第一层）属性创建浅层的响应式代理，不会对“属性的属性”做深层次、递归地响应式代理，而只是保留原样。

### `shallowReadonly`

只为某个对象的自有（第一层）属性创建浅层的只读响应式代理，同样也不会做深层次、递归地代理，深层次的属性并不是只读的。

### `shallowRef`

创建一个 `ref` ，将会追踪它的 `.value` 更改操作，但是并不会对变更后的 `.value` 做响应式代理转换（即变更不会调用 `reactive`）

### `toRaw`

返回由 `reactive` 或 `readonly` 方法转换成响应式代理的普通对象。这是一个还原方法，可用于临时读取，访问不会被代理/跟踪，写入时也不会触发更改。不建议一直持有原始对象的引用。请谨慎使用。

------

以上是对比教程上的内容找出的差异，最重要的就是 `Composition API` 和 `Reactivity` 也是我觉得最难的部分。另外 Vue3.0 的文档仍处于开发中，后续可能还会有一些改动，请以文档为准，还没有直接上手进行开发，因此没有提出太多个人见解，仅作为与 Vue2.x 的对比。


# Vue组件间通信6种方式

组件是 vue.js 最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系：



![img](https://pic3.zhimg.com/80/v2-b0f41044f63d939dddae9448326dfada_720w.jpg)



如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。

针对不同的使用场景，如何选择行之有效的通信方式？这是我们所要探讨的主题。本文总结了 vue 组件间通信的几种方式，如 props、`$emit`/`$on`、vuex、`$parent` / `$children`、`$attrs`/`$listeners`和 provide/inject，以通俗易懂的实例讲述这其中的差别及使用场景，希望对小伙伴有些许帮助。

### **方法一、`props`/`$emit`**

父组件 A 通过 props 的方式向子组件 B 传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。

### **1. 父组件向子组件传值**

接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件 Users.vue 中如何获取父组件 App.vue 中的数据 `users:["Henry","Bucky","Emily"]`

```html
//App.vue父组件
<template>
  <div id="app">
    <users v-bind:users="users"></users>//前者自定义名称便于子组件调用，后者要传递数据名
  </div>
</template>
<script>
import Users from "./components/Users"
export default {
  name: 'App',
  data(){
    return{
      users:["Henry","Bucky","Emily"]
    }
  },
  components:{
    "users":Users
  }
}
//users子组件
<template>
  <div class="hello">
    <ul>
      <li v-for="user in users">{{user}}</li>//遍历传递过来的值，然后呈现到页面
    </ul>
  </div>
</template>
<script>
export default {
  name: 'HelloWorld',
  props:{
    users:{           //这个就是父组件中子标签自定义名字
      type:Array,
      required:true
    }
  }
}
</script>
```

**总结：父组件通过 props 向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed**

### **2. 子组件向父组件传值（通过事件形式）**

接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。



![img](https://pic2.zhimg.com/80/v2-640ee6bf412899d531f5d4192b91d885_720w.png)



```html
// 子组件
<template>
  <header>
    <h1 @click="changeTitle">{{title}}</h1>//绑定一个点击事件
  </header>
</template>
<script>
export default {
  name: 'app-header',
  data() {
    return {
      title:"Vue.js Demo"
    }
  },
  methods:{
    changeTitle() {
      this.$emit("titleChanged","子向父组件传值");//自定义事件  传递值“子向父组件传值”
    }
  }
}
</script>
// 父组件
<template>
  <div id="app">
    <app-header v-on:titleChanged="updateTitle" ></app-header>//与子组件titleChanged自定义事件保持一致
   // updateTitle($event)接受传递过来的文字
    <h2>{{title}}</h2>
  </div>
</template>
<script>
import Header from "./components/Header"
export default {
  name: 'App',
  data(){
    return{
      title:"传递的是一个值"
    }
  },
  methods:{
    updateTitle(e){   //声明这个函数
      this.title = e;
    }
  },
  components:{
   "app-header":Header,
  }
}
</script>
```

**总结：子组件通过 events 给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。**

### **方法二、`$emit`/`$on`**

**这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级**。当我们的项目比较大时，可以选择更好的状态管理解决方案 vuex。

### **1.具体实现方式：**

```js
    var Event=new Vue();
    Event.$emit(事件名,数据);
    Event.$on(事件名,data => {});
```

### **2.举个例子**

假设兄弟组件有三个，分别是 A、B、C 组件，C 组件如何获取 A 或者 B 组件的数据

```html
<div id="itany">
  <my-a></my-a>
  <my-b></my-b>
  <my-c></my-c>
</div>
<template id="a">
  <div>
    <h3>A组件：{{name}}</h3>
    <button @click="send">将数据发送给C组件</button>
  </div>
</template>
<template id="b">
  <div>
    <h3>B组件：{{age}}</h3>
    <button @click="send">将数组发送给C组件</button>
  </div>
</template>
<template id="c">
  <div>
    <h3>C组件：{{name}}，{{age}}</h3>
  </div>
</template>
<script>
var Event = new Vue();//定义一个空的Vue实例
var A = {
  template: '#a',
  data() {
    return {
      name: 'tom'
    }
  },
  methods: {
    send() {
      Event.$emit('data-a', this.name);
    }
  }
}
var B = {
  template: '#b',
  data() {
    return {
      age: 20
    }
  },
  methods: {
    send() {
      Event.$emit('data-b', this.age);
    }
  }
}
var C = {
  template: '#c',
  data() {
    return {
      name: '',
      age: ""
    }
  },
  mounted() {//在模板编译完成后执行
   Event.$on('data-a',name => {
       this.name = name;//箭头函数内部不会产生新的this，这边如果不用=>,this指代Event
   })
   Event.$on('data-b',age => {
       this.age = age;
   })
  }
}
var vm = new Vue({
  el: '#itany',
  components: {
    'my-a': A,
    'my-b': B,
    'my-c': C
  }
});
</script>
```



![img](https://pic2.zhimg.com/v2-dc8554136ed432f1f1f760ac0d071be9_b.jpg)



`$on` 监听了自定义事件 data-a 和 data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。

### **方法三、vuex**



![img](https://pic3.zhimg.com/80/v2-d5e3226d81d48374b57d525e6a94f6fa_720w.jpg)



### **1. 简要介绍 Vuex 原理**

Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 进行，Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action，但 Action 也是无法直接修改 State 的，还是需要通过 Mutation 来修改 State 的数据。最后，根据 State 的变化，渲染到视图上。

### **2. 简要介绍各模块在流程中的功能：**

- Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。
- dispatch：操作行为触发方法，是唯一能执行 action 的方法。
- actions：**操作行为处理模块,由组件中的`$store.dispatch('action 名称', data1)`来触发。然后由 commit()来触发 mutation 的调用 , 间接更新 state**。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了 Promise 的封装，以支持 action 的链式触发。
- commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。
- mutations：**状态改变操作方法，由 actions 中的`commit('mutation 名称')`来触发**。是 Vuex 修改 state 的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。
- state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。
- getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。

### **3. Vuex 与 localStorage**

vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，**具体做法应该在 vuex 里数据改变的时候把数据拷贝一份保存到 localStorage 里面，刷新之后，如果 localStorage 里有保存的数据，取出来再替换 store 里的 state。**

```js
let defaultCity = "上海"
try {   // 用户关闭了本地存储功能，此时在外层加个try...catch
  if (!defaultCity){
    defaultCity = JSON.parse(window.localStorage.getItem('defaultCity'))
  }
}catch(e){}
export default new Vuex.Store({
  state: {
    city: defaultCity
  },
  mutations: {
    changeCity(state, city) {
      state.city = city
      try {
      window.localStorage.setItem('defaultCity', JSON.stringify(state.city));
      // 数据改变的时候把数据拷贝一份保存到localStorage里面
      } catch (e) {}
    }
  }
})
```

这里需要注意的是：由于 vuex 里，我们保存的状态，都是数组，而 localStorage 只支持字符串，所以需要用 JSON 转换：

```js
JSON.stringify(state.subscribeList);   // array -> string
JSON.parse(window.localStorage.getItem("subscribeList"));    // string -> array
```

### **方法四、`$attrs`/`$listeners`**

### **1. 简介**

多级组件嵌套需要传递数据时，通常使用的方法是通过 vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此 Vue2.4 版本提供了另一种方法----`$attrs`/`$listeners`

- `$attrs`：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 interitAttrs 选项一起使用。
- `$listeners`：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件

接下来我们看个跨级通信的例子：

```html
// index.vue
<template>
  <div>
    <h2>浪里行舟</h2>
    <child-com1
      :foo="foo"
      :boo="boo"
      :coo="coo"
      :doo="doo"
      title="前端工匠"
    ></child-com1>
  </div>
</template>
<script>
const childCom1 = () => import("./childCom1.vue");
export default {
  components: { childCom1 },
  data() {
    return {
      foo: "Javascript",
      boo: "Html",
      coo: "CSS",
      doo: "Vue"
    };
  }
};
</script>
// childCom1.vue
<template class="border">
  <div>
    <p>foo: {{ foo }}</p>
    <p>childCom1的$attrs: {{ $attrs }}</p>
    <child-com2 v-bind="$attrs"></child-com2>
  </div>
</template>
<script>
const childCom2 = () => import("./childCom2.vue");
export default {
  components: {
    childCom2
  },
  inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性
  props: {
    foo: String // foo作为props属性绑定
  },
  created() {
    console.log(this.$attrs); // { "boo": "Html", "coo": "CSS", "doo": "Vue", "title": "前端工匠" }
  }
};
</script>
// childCom2.vue
<template>
  <div class="border">
    <p>boo: {{ boo }}</p>
    <p>childCom2: {{ $attrs }}</p>
    <child-com3 v-bind="$attrs"></child-com3>
  </div>
</template>
<script>
const childCom3 = () => import("./childCom3.vue");
export default {
  components: {
    childCom3
  },
  inheritAttrs: false,
  props: {
    boo: String
  },
  created() {
    console.log(this.$attrs); // { "boo": "Html", "coo": "CSS", "doo": "Vue", "title": "前端工匠" }
  }
};
</script>
// childCom3.vue
<template>
  <div class="border">
    <p>childCom3: {{ $attrs }}</p>
  </div>
</template>
<script>
export default {
  props: {
    coo: String,
    title: String
  }
};
</script>
```



![img](https://pic2.zhimg.com/80/v2-9c747e25cf01e48326cb8c7840d6fded_720w.jpg)



如上图所示`$attrs`表示没有继承数据的对象，格式为{属性名：属性值}。Vue2.4 提供了`$attrs` , `$listeners` 来传递数据与事件，跨级组件之间的通讯变得更简单。

简单来说：`$attrs`与`$listeners` 是两个对象，`$attrs` 里存放的是父组件中绑定的非 Props 属性，`$listeners`里存放的是父组件中绑定的非原生事件。

### **方法五、provide/inject**

### **1. 简介**

Vue2.2.0 新增 API,这对选项需要一起使用，**以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效**。一言而蔽之：祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 **provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系**。

### **2. 举个例子**

假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件

```js
// A.vue
export default {
  provide: {
    name: '浪里行舟'
  }
}
// B.vue
export default {
  inject: ['name'],
  mounted () {
    console.log(this.name);  // 浪里行舟
  }
}
```

可以看到，在 A.vue 里，我们设置了一个 **provide: name**，值为 浪里行舟，它的作用就是将 **name** 这个变量提供给它的所有子组件。而在 B.vue 中，通过 `inject` 注入了从 A 组件中提供的 **name** 变量，那么在组件 B 中，就可以直接通过 **this.name** 访问这个变量了，它的值也是 浪里行舟。这就是 provide / inject API 最核心的用法。

需要注意的是：**provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的**----vue 官方文档 所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的，仍然是 浪里行舟。

### **3. provide 与 inject 怎么实现数据响应式**

一般来说，有两种办法：

- provide 祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如 props，methods
- 使用 2.6 最新 API Vue.observable 优化响应式 provide(推荐)

我们来看个例子：孙组件 D、E 和 F 获取 A 组件传递过来的 color 值，并能实现数据响应式变化，即 A 组件的 color 变化后，组件 D、E、F 不会跟着变（核心代码如下：）



![img](https://pic3.zhimg.com/80/v2-eccada48e96ef2937d7aa436801c6f82_720w.jpg)



```js
// A 组件
<div>
      <h1>A 组件</h1>
      <button @click="() => changeColor()">改变color</button>
      <ChildrenB />
      <ChildrenC />
</div>
......
  data() {
    return {
      color: "blue"
    };
  },
  // provide() {
  //   return {
  //     theme: {
  //       color: this.color //这种方式绑定的数据并不是可响应的
  //     } // 即A组件的color变化后，组件D、E、F不会跟着变
  //   };
  // },
  provide() {
    return {
      theme: this//方法一：提供祖先组件的实例
    };
  },
  methods: {
    changeColor(color) {
      if (color) {
        this.color = color;
      } else {
        this.color = this.color === "blue" ? "red" : "blue";
      }
    }
  }
  // 方法二:使用2.6最新API Vue.observable 优化响应式 provide
  // provide() {
  //   this.theme = Vue.observable({
  //     color: "blue"
  //   });
  //   return {
  //     theme: this.theme
  //   };
  // },
  // methods: {
  //   changeColor(color) {
  //     if (color) {
  //       this.theme.color = color;
  //     } else {
  //       this.theme.color = this.theme.color === "blue" ? "red" : "blue";
  //     }
  //   }
  // }
// F 组件
<template functional>
  <div class="border2">
    <h3 :style="{ color: injections.theme.color }">F 组件</h3>
  </div>
</template>
<script>
export default {
  inject: {
    theme: {
      //函数式组件取值不一样
      default: () => ({})
    }
  }
};
</script>
```

虽说 provide 和 inject 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！

### **方法六、`$parent` / `$children`与 `ref`**

- `ref`：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例
- `$parent` / `$children`：访问父 / 子实例

需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 `ref`来访问组件的例子：

```js
// component-a 子组件
export default {
  data () {
    return {
      title: 'Vue.js'
    }
  },
  methods: {
    sayHello () {
      window.alert('Hello');
    }
  }
}
// 父组件
<template>
  <component-a ref="comA"></component-a>
</template>
<script>
  export default {
    mounted () {
      const comA = this.$refs.comA;
      console.log(comA.title);  // Vue.js
      comA.sayHello();  // 弹窗
    }
  }
</script>
```

不过，**这两种方法的弊端是，无法在跨级或兄弟间通信**。

```html
// parent.vue
<component-a></component-a>
<component-b></component-b>
<component-b></component-b>
```

我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。

### **总结**

常见使用场景可以分为三类：

- 父子通信： 父向子传递数据是通过 props，子向父是通过 events（`$emit`）；通过父链 / 子链也可以通信（`$parent` / `$children`）；ref 也可以访问组件实例；provide / inject API；`$attrs/$listeners`
- 兄弟通信： Bus；Vuex
- 跨级通信： Bus；Vuex；provide / inject API、`$attrs/$listeners`

# css只在当前组件起作用

在style标签中写入scoped即可 例如：<style scoped></style>

# vue-router 使用params与query传参有什么区别

`vue-router` 可以通过 `params` 与 `query` 进行传参

```js
// 传递
this.$router.push({path: './xxx', params: {xx:xxx}})
this.$router.push({path: './xxx', query: {xx:xxx}})
 
// 接收
this.$route.params
 
this.$route.query
```

- `params` 是路由的一部分,必须要有。`query` 是拼接在 `url` 后面的参数，没有也没关系
- params 不设置的时候，刷新页面或者返回参数会丢，query 则不会有这个问题

# vue2.0生命周期

Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。

**beforecreate** **:**
完成实例初始化，初始化非响应式变量
this指向创建的实例；
可以在这加个loading事件；
data computed watch methods上的方法和数据均不能访问

**created**
实例创建完成
完成数据(data props computed)的初始化 导入依赖项。
可访问data computed watch methods上的方法和数据
未挂载DOM,不能访问$el,$ref为空数组
可在这结束loading，还做一些初始化，实现函数自执行,
可以对data数据进行操作，可进行一些请求，请求不易过多，避免白屏时间太长。
若在此阶段进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中

**berofeMount**
有了el,编译了template|/outerHTML
能找到对应的template,并编译成render函数

**mounted**
完成创建vm.$el，和双向绑定，
完成挂载DOM 和渲染;可在mounted钩子对挂载的dom进行操作
即有了DOM 且完成了双向绑定 可访问DOM节点,$ref
可在这发起后端请求，拿回数据，配合路由钩子做一些事情；
可对DOM 进行操作

**beforeUpdate**
数据更新之前
可在更新前访问现有的DOM,如手动移除添加的事件监听器；

**updated :**
完成虚拟DOM的重新渲染和打补丁；
组件DOM 已完成更新；
可执行依赖的dom 操作
注意：不要在此函数中操作数据，会陷入死循环的。

**activated:**
在使用vue-router时有时需要使用<keep-alive></keep-alive>来缓存组件状态，这个时候created钩子就不会被重复调用了，
如果我们的子组件需要在每次加载的时候进行某些操作，可以使用activated钩子触发

**deactivated**
for keep-alive 组件被移除时使用

**beforeDestroy****：**
在执行app.$destroy()之前
可做一些删除提示，如：你确认删除XX吗？
可用于销毁定时器，解绑全局时间 销毁插件对象

**destroyed** ：

当前组件已被删除，销毁监听事件 组件 事件 子实例也被销毁 这时组件已经没有了，你无法操作里面的任何东西了。


# vue3.0 响应式原理

## 一 基于proxy的Observer



**1 什么是proxy**

*Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。*



proxy是es6新特性，为了对目标的作用主要是通过handler对象中的拦截方法拦截目标对象target的某些行为（如属性查找、赋值、枚举、函数调用等）。



```js
/* target: 目标对象，待要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 */
/* handler: 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 proxy 的行为。 */ 
const proxy = new Proxy(target, handler);
```



**2 为什么要用proxy，改用proxy之后的利与弊**



> \> 3.0 将带来一个基于 Proxy 的 observer 实现，它可以提供覆盖语言 (JavaScript——译注) 全范围的响应式能力，消除了当前 Vue 2 系列中基于 Object.defineProperty 所存在的一些局限，这些局限包括：1 对属性的添加、删除动作的监测； 2 对数组基于下标的修改、对于 .length 修改的监测； 3 对 Map、Set、WeakMap 和 WeakSet 的支持；；



vue2.0 用*Object.defineProperty* 作为响应式原理的实现，但是会有它的局限性，比如 **无法监听数组基于下标的修改，不支持 Map、Set、WeakMap 和 WeakSet等缺陷** ，所以改用了proxy解决了这些问题，这也意味着vue3.0将放弃对低版本浏览器的兼容（兼容版本ie11以上）。



**3 proxy中hander对象的基本用法**



vue3.0 响应式用到的捕获器（接下来会重点介绍）

handler.has() -> in 操作符的捕捉器。 (vue3.0 用到)

handler.get() -> 属性读取 操作的捕捉器。 (vue3.0 用到)

handler.set() -> 属性设置 操作的捕捉器。(vue3.0 用到)

handler.deleteProperty() -> delete 操作符 的捕捉器(vue3.0 用到)

handler.ownKeys() -> Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。(vue3.0 用到)。



vue3.0 响应式没用到的捕获器（有兴趣的同学可以研究一下）



handler.getPrototypeOf() -> Object.getPrototypeOf 方法的捕捉器。

handler.setPrototypeOf() -> Object.setPrototypeOf方法的捕捉器。

handler.isExtensible() -> Object.isExtensible 方法的捕捉器。

handler.preventExtensions() -> Object.preventExtensions 方法的捕捉器。

handler.getOwnPropertyDescriptor()-> Object.getOwnPropertyDescriptor 方法的捕捉器。

handler.defineProperty() -> Object.defineProperty方法的捕捉器。

handler.apply() -> 函数调用操作 的捕捉器。

handler.construct() -> new 操作符 的捕捉器。



***① has捕获器***

has(target, propKey)

target:目标对象

propKey:待拦截属性名

作用: 拦截判断target对象是否含有属性propKey的操作

拦截操作：propKey in proxy 不包含for...in循环

对应Reflect: Reflect.has(target, propKey)

例子：

```js
const handler = {
    has(target, propKey){
        /*
        * 做你的操作
        */
        return propKey in target
    }
}
const proxy = new Proxy(target, handler)
```



***② get捕获器***

get(target, propKey, receiver)

target:目标对象

propKey:待拦截属性名

receiver: proxy实例

返回： 返回读取的属性

作用：拦截对象属性的读取

拦截操作：proxy[propKey]或者点运算符

对应Reflect： Reflect.get(target, propertyKey[, receiver])

例子：



```js
const handler = {
    get: function(obj, prop) {
        return prop in obj ? obj[prop] : '没有此水果';
    }
}

const foot = new Proxy({}, handler)
foot.apple = '苹果'
foot.banana = '香蕉';

console.log(foot.apple, foot.banana);    /* 苹果 香蕉 */
console.log('pig' in foot, foot.pig);    /* false 没有此水果 */
```

特殊情况



```js
const person = {};
Object.defineProperty(person, 'age', {
  value: 18, 
  writable: false,
  configurable: false
})
const proxPerson = new Proxy(person, {
  get(target,propKey) {
    return 20
    //应该return 18;不能返回其他值，否则报错
  }
})
console.log( proxPerson.age ) /* 会报错 */
```



***③ set捕获器***



set(target,propKey, value,receiver)

target:目标对象

propKey:待拦截属性名

value:新设置的属性值

receiver: proxy实例

返回：严格模式下返回true操作成功；否则失败，报错

作用： 拦截对象的属性赋值操作

拦截操作： proxy[propkey] = value

对应Reflect： Reflect.set(obj, prop, value, receiver)

```js
let validator = {
  set: function(obj, prop, value) {
    if (prop === 'age') {
      if (!Number.isInteger(value)) { /* 如果年龄不是整数 */
        throw new TypeError('The age is not an integer')
      }
      if (value > 200) {  /* 超出正常的年龄范围 */
        throw new RangeError('The age seems invalid')
      }
    }
    obj[prop] = value
    // 表示成功
    return true
  }
}
let person = new Proxy({}, validator)
person.age = 100
console.log(person.age)  // 100
person.age = 'young'     // 抛出异常: Uncaught TypeError: The age is not an integer
person.age = 300         // 抛出异常: Uncaught RangeError: The age seems invalid````
```

当对象的属性writable为false时，该属性不能在拦截器中被修改



```js
const person = {};
Object.defineProperty(person, 'age', {
    value: 18,
    writable: false,
    configurable: true,
});

const handler = {
    set: function(obj, prop, value, receiver) {
        return Reflect.set(...arguments);
    },
};
const proxy = new Proxy(person, handler);
proxy.age = 20;
console.log(person) // {age: 18} 说明修改失败
```



***④ deleteProperty 捕获器\***



deleteProperty(target, propKey)

target:目标对象

propKey:待拦截属性名

返回：严格模式下只有返回true, 否则报错

作用： 拦截删除target对象的propKey属性的操作

拦截操作： delete proxy[propKey]

对应Reflect： Reflect.delete(obj, prop)

```js
var foot = { apple: '苹果' , banana:'香蕉'  }
var proxy = new Proxy(foot, {
  deleteProperty(target, prop) {
    console.log('当前删除水果 :',target[prop])
    return delete target[prop]
  }
});
delete proxy.apple
console.log(foot)

/*
运行结果：
'当前删除水果 : 苹果'
{  banana:'香蕉'  }
*/
```



特殊情况： 属性是不可配置属性时，不能删除

```js
var foot = {  apple: '苹果' }
Object.defineProperty(foot, 'banana', {
   value: '香蕉', 
   configurable: false
})
var proxy = new Proxy(foot, {
  deleteProperty(target, prop) {
    return delete target[prop];
  }
})
delete proxy.banana /* 没有效果 */
console.log(foot)
```

***⑤ownKeys 捕获器\***

ownKeys(target)

target：目标对象

返回： 数组（数组元素必须是字符或者Symbol,其他类型报错）

作用： 拦截获取键值的操作

拦截操作：

1 Object.getOwnPropertyNames(proxy)

2 Object.getOwnPropertySymbols(proxy)

3 Object.keys(proxy)

4 for...in...循环

对应Reflect：Reflect.ownKeys()



```js
var obj = { a: 10, [Symbol.for('foo')]: 2 };
Object.defineProperty(obj, 'c', {
    value: 3, 
    enumerable: false
})
var p = new Proxy(obj, {
  ownKeys(target) {
    return [...Reflect.ownKeys(target), 'b', Symbol.for('bar')]
  }
})
const keys = Object.keys(p)  // ['a']
// 自动过滤掉Symbol/非自身/不可遍历的属性

/* 和Object.keys()过滤性质一样，只返回target本身的可遍历属性 */
for(let prop in p) { 
  console.log('prop-',prop) /* prop-a */
}

/* 只返回拦截器返回的非Symbol的属性，不管是不是target上的属性 */
const ownNames = Object.getOwnPropertyNames(p)  /* ['a', 'c', 'b'] */

/* 只返回拦截器返回的Symbol的属性，不管是不是target上的属性*/
const ownSymbols = Object.getOwnPropertySymbols(p)// [Symbol(foo), Symbol(bar)]

/*返回拦截器返回的所有值*/
const ownKeys = Reflect.ownKeys(p)
// ['a','c',Symbol(foo),'b',Symbol(bar)]
```



## 二 vue3.0 如何建立响应式



vue3.0 建立响应式的方法有两种：

第一个就是运用composition-api中的reactive直接构建响应式，composition-api的出现我们可以在.vue文件中，直接用setup()函数来处理之前的大部分逻辑，也就是说我们没有必要在 export default{ } 中在声明生命周期 ， data(){} 函数，watch{} , computed{} 等 ，取而代之的是我们在setup函数中，用vue3.0 reactive watch 生命周期api来到达同样的效果，这样就像react-hooks一样提升代码的复用率，逻辑性更强。

第二个就是用传统的 data(){ return{} } 形式 ,vue3.0没有放弃对vue2.0写法的支持，而是对vue2.0的写法是完全兼容的，提供了*applyOptions* 来处理options形式的vue组件。但是options里面的data , watch , computed等处理逻辑，还是用了composition-api中的API对应处理。

**1 composition-api reactive**

Reactive 相当于当前的 Vue.observable () API，经过reactive处理后的函数能变成响应式的数据，类似于option api里面的vue处理data函数的返回值。

我们用一个todoList的demo试着尝尝鲜。

```js
const { reactive , onMounted } = Vue
setup(){
    const state = reactive({
        count:0,
        todoList:[]
    })
    /* 生命周期mounted */
    onMounted(() => {
       console.log('mounted')
    })
    /* 增加count数量 */
    function add(){
        state.count++
    } 
    /* 减少count数量 */
    function del(){
        state.count--
    }
    /* 添加代办事项 */
    function addTodo(id,title,content){
        state.todoList.push({
            id,
            title,
            content,
            done:false
        })
    }
    /* 完成代办事项 */
    function complete(id){
        for(let i = 0; i< state.todoList.length; i++){
            const currentTodo = state.todoList[i] 
            if(id === currentTodo.id){
                state.todoList[i] = {
                    ...currentTodo,
                    done:true
                } 
                break
            }
        }
    }
    return {
        state,
        add,
        del,
        addTodo,
        complete
    }
}
```





**2 options data**

options形式的和vue2.0并没有什么区别

```js
export default {
    data(){
        return{
            count:0,
            todoList:[] 
        }
    },
    mounted(){
        console.log('mounted')
    }
    methods:{
        add(){
            this.count++
        },
        del(){
            this.count--
        },
        addTodo(id,title,content){
           this.todoList.push({
               id,
               title,
               content,
               done:false
           })
        },
        complete(id){
            for(let i = 0; i< this.todoList.length; i++){
                const currentTodo = this.todoList[i] 
                if(id === currentTodo.id){
                    this.todoList[i] = {
                        ...currentTodo,
                        done:true
                    } 
                    break
                }
            }
        }
    }
}
```

## 三 响应式原理初探

**不同类型的Reactive**

vue3.0可以根据业务需求引进不同的API方法。这里需要

***① reactive***

建立响应式reactive，返回proxy对象，这个reactive可以深层次递归，也就是如果发现展开的属性值是引用类型的而且被引用，还会用reactive递归处理。而且属性是可以被修改的。

***② shallowReactive***

建立响应式shallowReactive，返回proxy对象。和reactive的区别是只建立一层的响应式，也就是说如果发现展开属性是引用类型也不会递归。

***③ readonly***

返回的proxy处理的对象，可以展开递归处理，但是属性是只读的，不能修改。可以做props传递给子组件使用。

***④ shallowReadonly***

返回经过处理的proxy对象，但是建立响应式属性是只读的，不展开引用也不递归转换，可以这用于为有状态组件创建props代理对象。



**储存对象与proxy**

上文中我们提及到。用Reactive处理过并返回的对象是一个proxy对象，假设存在很多组件，或者在一个组件中被多次reactive，就会有很多对proxy对象和它代理的原对象。为了能把proxy对象和原对象建立关系，vue3.0采用了WeakMap去储存这些对象关系。WeakMaps 保持了对键名所引用的对象的弱引用，即垃圾回收机制不将该引用考虑在内。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。



```js
const rawToReactive = new WeakMap<any, any>()
const reactiveToRaw = new WeakMap<any, any>()
const rawToReadonly = new WeakMap<any, any>() /* 只读的 */
const readonlyToRaw = new WeakMap<any, any>() /* 只读的 */
```



vue3.0 用readonly来设置被拦截器拦截的对象能否被修改，可以满足之前的props不能被修改的单向数据流场景。

我们接下来重点讲一下接下来的四个weakMap的储存关系。

***rawToReactive***

键值对 ： { [targetObject] : obseved }

target（键）:目标对象值(这里可以理解为**reactive**的第一个参数。)

obsered（值）:经过proxy代理之后的proxy对象。

***reactiveToRaw***

reactiveToRaw 储存的刚好与 rawToReactive的键值对是相反的。

键值对 { [obseved] : targetObject }

***rawToReadonly\***

键值对 ： { [target] : obseved }

target（键）：目标对象。

obsered（值）:经过proxy代理之后的只读属性的proxy对象。

***readonlyToRaw***

储存状态与rawToReadonly刚好相反。



**reactive入口解析**

接下来我们重点从reactive开始讲。

reactive({ ...object }) 入口



```js
export function reactive(target: object) {
  if (readonlyToRaw.has(target)) {
    return target
  }
  return createReactiveObject(
    target,                   /* 目标对象 */
    rawToReactive,            /* { [targetObject] : obseved  }   */
    reactiveToRaw,            /* { [obseved] : targetObject }  */
    mutableHandlers,          /* 处理 基本数据类型 和 引用数据类型 */
    mutableCollectionHandlers /* 用于处理 Set, Map, WeakMap, WeakSet 类型 */
  )
}
```

reactive函数的作用就是通过createReactiveObject方法产生一个proxy,而且针对不同的数据类型给定了不同的处理方法。

***createReactiveObject\***

之前说到的createReactiveObject，我们接下来看看createReactiveObject发生了什么。



```js
const collectionTypes = new Set<Function>([Set, Map, WeakMap, WeakSet])
function createReactiveObject(
  target: unknown,
  toProxy: WeakMap<any, any>,
  toRaw: WeakMap<any, any>,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>
) {
  /* 判断目标对象是否被effect */
  /* observed 为经过 new Proxy代理的函数 */
  let observed = toProxy.get(target) /* { [target] : obseved  } */
  if (observed !== void 0) { /* 如果目标对象已经被响应式处理，那么直接返回proxy的observed对象 */
    return observed
  }
  if (toRaw.has(target)) { /* { [observed] : target  } */
    return target
  }
  /* 如果目标对象是 Set, Map, WeakMap, WeakSet 类型，那么 hander函数是 collectionHandlers 否侧目标函数是baseHandlers */
  const handlers = collectionTypes.has(target.constructor)
    ? collectionHandlers
    : baseHandlers
   /* TODO: 创建响应式对象  */
  observed = new Proxy(target, handlers)
  /* target 和 observed 建立关联 */
  toProxy.set(target, observed)
  toRaw.set(observed, target)
  /* 返回observed对象 */
  return observed
}
```



通过上面源码创建proxy对象的大致流程是这样的：

①首先判断目标对象有没有被proxy响应式代理过，如果是那么直接返回对象。

②然后通过判断目标对象是否是[ Set, Map, WeakMap, WeakSet ]数据类型来选择是用***collectionHandlers*** ， 还是***baseHandlers***->就是reactive传进来的mutableHandlers作为proxy的hander对象。

③最后通过真正使用new proxy来创建一个observed ，然后通过rawToReactive reactiveToRaw 保存 target和observed键值对。



大致流程图：



![img](https://pic1.zhimg.com/80/v2-49068c6ad24d09b3ce7b60733cdb7d20_720w.jpg)



## 四 拦截器对象baseHandlers -> mutableHandlers



之前我们介绍过baseHandlers就是调用reactive方法createReactiveObject传进来的mutableHandlers对象。

我们先来看一下mutableHandlers对象

mutableHandlers

**拦截器的作用域**



```js
export const mutableHandlers: ProxyHandler<object> = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
}
```



vue3.0 用到了以上几个拦截器。

①get,对数据的读取属性进行拦截，包括 target.点语法 和 target[]

②set，对数据的存入属性进行拦截 。

③deleteProperty delete操作符进行拦截。

vue2.0不能对对象的delete操作符进行属性拦截。



例子 ：



```js
delete object.a
```

是无法监测到的。

vue3.0proxy中deleteProperty 可以拦截 delete 操作符，这就表述vue3.0响应式可以监听到属性的删除操作。

④has，对 in 操作符进行属性拦截。

vue2.0不能对对象的in操作符进行属性拦截。

例子



```js
a in object
```

has 是为了解决如上问题。这就表示了vue3.0可以对 in 操作符*进行拦截。

⑤ownKeys Object.keys(proxy) ,for...in...循环 ,Object.getOwnPropertySymbols(proxy) ， Object.getOwnPropertyNames(proxy)拦截器

例子

```js
Object.keys(object)
```

说明vue3.0可以对以上这些方法进行拦截。

## 五 组件初始化阶段



如果我们想要弄明白整个响应式原理。那么组件初始化，到初始化过程中composition-api的reactive处理data，以及编译阶段对data属性进行依赖收集是分不开的。vue3.0提供了一套从初始化，到render过程中依赖收集，到组件更新,到组件销毁完整响应式体系，我们很难从一个角度把东西讲明白，所以在正式讲拦截器对象如何收集依赖，派发更新之前，我们看看effect做了些什么操作。

**1 effect -> 新的渲染watcher**

vue3.0用effect副作用钩子来代替vue2.0watcher。我们都知道在vue2.0中，有渲染watcher专门负责数据变化后的从新渲染视图。vue3.0改用effect来代替watcher达到同样的效果。



我们先简单介绍一下mountComponent流程，后面的文章会详细介绍mount阶段的

1 mountComponent 初始化mountComponent

```js
  // 初始化组件
  const mountComponent: MountComponentFn = (
    initialVNode,
    container,
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    optimized
  ) => {
    /* 第一步: 创建component 实例   */
    const instance: ComponentInternalInstance = (initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    ))

    /* 第二步 ： TODO:初始化 初始化组件,建立proxy , 根据字符窜模版得到 */
    setupComponent(instance)
    /* 第三步：建立一个渲染effect，执行effect */
    setupRenderEffect(
      instance,     // 组件实例
      initialVNode, //vnode  
      container,    // 容器元素
      anchor,
      parentSuspense,
      isSVG,
      optimized
    )   
  }
```



上面是整个mountComponent的主要分为了三步，我们这里分别介绍一下每个步骤干了什么：

***① 第一步: 创建component 实例 。***

***② 第二步：初始化组件,建立proxy ,根据字符窜模版得到render函数。生命周期钩子函数处理等等***

***③ 第三步：建立一个渲染effect，执行effect。***



从如上方法中我们可以看到，在setupComponent已经构建了响应式对象，但是还没有初始化收集依赖。



**2 setupRenderEffect 构建渲染effect**



```js
 const setupRenderEffect: SetupRenderEffectFn = (
    instance,
    initialVNode,
    container,
    anchor,
    parentSuspense,
    isSVG,
    optimized
  ) => {
    /* 创建一个渲染 effect */
    instance.update = effect(function componentEffect() {
      //...省去的内容后面会讲到
    },{ scheduler: queueJob })
  }
```

为了让大家更清楚的明白响应式原理，我这只保留了和响应式原理有关系的部分代码。

***setupRenderEffect的作用***

① 创建一个effect，并把它赋值给组件实例的update方法，作为渲染更新视图用。

② componentEffect作为回调函数形式传递给effect作为第一个参数



**3 effect做了些什么**

```js
export function effect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions = EMPTY_OBJ
): ReactiveEffect<T> {
  const effect = createReactiveEffect(fn, options)
  /* 如果不是懒加载 立即执行 effect函数 */
  if (!options.lazy) {
    effect()
  }
  return effect
}
```

effect作用如下

① 首先调用。createReactiveEffect.

② 如果不是懒加载 立即执行 由createReactiveEffect创建出来的ReactiveEffect函数。

**4 ReactiveEffect**



```js
function createReactiveEffect<T = any>(
  fn: (...args: any[]) => T, /**回调函数 */
  options: ReactiveEffectOptions
): ReactiveEffect<T> {
  const effect = function reactiveEffect(...args: unknown[]): unknown {
    try {
        enableTracking()
        effectStack.push(effect) //往effect数组中里放入当前 effect
        activeEffect = effect //TODO: effect 赋值给当前的 activeEffect
        return fn(...args) //TODO:    fn 为effect传进来 componentEffect
      } finally {
        effectStack.pop() //完成依赖收集后从effect数组删掉这个 effect
        resetTracking() 
        /* 将activeEffect还原到之前的effect */
        activeEffect = effectStack[effectStack.length - 1]
    }
  } as ReactiveEffect
  /* 配置一下初始化参数 */
  effect.id = uid++
  effect._isEffect = true
  effect.active = true
  effect.raw = fn
  effect.deps = [] /* TODO:用于收集相关依赖 */
  effect.options = options
  return effect
}
```

createReactiveEffect



createReactiveEffect的作用主要是配置了一些初始化的参数，然后包装了之前传进来的fn重要的一点是把当前的effect赋值给了activeEffect,这一点非常重要，和收集依赖有着直接的关系

**总结**

我们这里个响应式初始化阶段进行总结

***① setupComponent创建组件，调用composition-api,处理options（构建响应式）得到Observer对象。***

***② 创建一个渲染effect，里面包装了真正的渲染方法componentEffect，添加一些effect初始化属性。***

***③ 然后立即执行effect，然后将当前渲染effect赋值给activeEffect***



最后我们用一张图来解释一下整个流程。

![img](https://pic1.zhimg.com/80/v2-b2eaca60979a28c78a8bceab6a557f3c_720w.jpg)



**六 依赖收集，get做了些什么？**

**1 回归mutableHandlers中的get方法**

1 不同类型的get

```js
/* 深度get */
const get = /*#__PURE__*/ createGetter()
/* 浅get */
const shallowGet = /*#__PURE__*/ createGetter(false, true)
/* 只读的get */
const readonlyGet = /*#__PURE__*/ createGetter(true)
/* 只读的浅get */
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)
```



上面我们可以知道，对于之前讲的四种不同的建立响应式方法，对应了四种不同的get,下面是一一对应关系。

reactive ---------> get

shallowReactive --------> shallowGet

readonly ----------> readonlyGet

shallowReadonly ---------------> shallowReadonlyGet

四种方法都是调用了createGetter方法，只不过是参数的配置不同，我们这里那第一个get方法做参考，接下来探索一下createGetter。

**createGette**r

```js
function createGetter(isReadonly = false, shallow = false) {
  return function get(target: object, key: string | symbol, receiver: object) {
    const res = Reflect.get(target, key, receiver)
    /* 浅逻辑 */
    if (shallow) {
      !isReadonly && track(target, TrackOpTypes.GET, key)
      return res
    }
    /* 数据绑定 */
    !isReadonly && track(target, TrackOpTypes.GET, key)
    return isObject(res)
      ? isReadonly
        ?
          /* 只读属性 */
          readonly(res)
          /*  */
        : reactive(res)
      : res
  }
}
```



这就是createGetter主要流程，特殊的数据类型和re*我们暂时先不考虑。

这里用了一些流程判断，我们用流程图来说明一下这个函数主要做了什么？

![img](https://pic1.zhimg.com/80/v2-5f0e1481b429873a7a7b3bbf8620d8c4_720w.jpg)



我们可以得出结论：

***在vue2.0的时候。响应式是在初始化的时候就深层次递归处理了\***

但是

与vue2.0不同的是,即便是深度响应式我们也只能在获取上一级get之后才能触发下一级的深度响应式。

比如



```js
setup(){
 const state = reactive({ a:{ b:{} } })
 return {
     state
 }
}
```

在初始化的时候，只有a的一层级建立了响应式，b并没有建立响应式，而当我们用state.a的时候，才会真正的将b也做响应式处理，也就是说我们访问了上一级属性后，下一代属性才会真正意义上建立响应式

这样做好处是，

1 初始化的时候不用递归去处理对象，造成了不必要的性能开销。

2 有一些没有用上的state，这里就不需要在深层次响应式处理。



**2 track->依赖收集器**

我们先来看看track源码：

track做了些什么



```js
/* target 对象本身 ，key属性值  type 为 'GET' */
export function track(target: object, type: TrackOpTypes, key: unknown) {
  /* 当打印或者获取属性的时候 console.log(this.a) 是没有activeEffect的 当前返回值为0  */
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    /*  target -map-> depsMap  */
    targetMap.set(target, (depsMap = new Map()))
  }
  let dep = depsMap.get(key)
  if (!dep) {
    /* key : dep dep观察者 */
    depsMap.set(key, (dep = new Set()))
  }
   /* 当前activeEffect */
  if (!dep.has(activeEffect)) {
    /* dep添加 activeEffect */
    dep.add(activeEffect)
    /* 每个 activeEffect的deps 存放当前的dep */
    activeEffect.deps.push(dep)
  }
}
```

里面主要引入了两个概念 targetMap和 depsMap

targetMap

键值对 proxy : depsMap

proxy ： 为reactive代理后的 Observer对象 。

depsMap ：为存放依赖dep的 map 映射。

depsMap

键值对：key : deps

key 为当前get访问的属性名，

deps 存放effect的set数据类型。

我们知道track作用大致是，首先根据 proxy对象，获取存放deps的depsMap，然后通过访问的属性名key获取对应的dep,然后将当前激活的effect存入当前dep收集依赖。

主要作用

***①找到与当前proxy 和 key对应的dep。\***

***②dep与当前activeEffect建立联系，收集依赖。\***



为了方便理解，targetMap 和 depsMap的关系，下面我们用一个例子来说明：

例子：

父组件A



```js
<div id="app" >
  <span>{{ state.a }}</span>
  <span>{{ state.b }}</span>
<div>
<script>
const { createApp, reactive } = Vue

/* 子组件 */
const Children ={
    template="<div> <span>{{ state.c }}</span> </div>",
    setup(){
       const state = reactive({
          c:1
       })
       return {
           state
       }
    }
}
/* 父组件 */
createApp({
   component:{
       Children
   } 
   setup(){
       const state = reactive({
           a:1,
           b:2
       })
       return {
           state
       }
   }
})mount('#app')

</script>
```



我们用一幅图表示如上关系：

![img](https://pic1.zhimg.com/80/v2-9301bda574505e9f6a0b53d269f46404_720w.jpg)

**渲染effect函数如何触发get**



我们在前面说过，创建一个渲染renderEffect，然后把赋值给activeEffect，最后执行renderEffect ，在这个期间是怎么做依赖收集的呢，让我们一起来看看,update函数中做了什么，我们回到之前讲的componentEffect逻辑上来

```js
function componentEffect() {
    if (!instance.isMounted) {
        let vnodeHook: VNodeHook | null | undefined
        const { el, props } = initialVNode
        const { bm, m, a, parent } = instance
        /* TODO: 触发instance.render函数，形成树结构 */
        const subTree = (instance.subTree = renderComponentRoot(instance))
        if (bm) {
          //触发 beforeMount声明周期钩子
          invokeArrayFns(bm)
        }
        patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
        )
        /* 触发声明周期 mounted钩子 */
        if (m) {
          queuePostRenderEffect(m, parentSuspense)
        }
        instance.isMounted = true
      } else {
        // 更新组件逻辑
        // ......
      }
}
```

这边代码大致首先会通过renderComponentRoot方法形成树结构，这里要注意的是，我们在最初mountComponent的setupComponent方法中，已经通过编译方法compile编译了template模版的内容，state.a state.b等抽象语法树，最终返回的render函数在这个阶段会被触发，在render函数中在模版中的表达式 state.a state.b 点语法会被替换成data中真实的属性，这时候就进行了真正的依赖收集，触发了get方法。接下来就是触发生命周期 beforeMount ,然后对整个树结构重新patch,patch完毕后，调用mounted钩子

**依赖收集流程总结**



***① 首先执行renderEffect ，赋值给activeEffect ，调用renderComponentRoot方法，然后触发render函数。***

***② 根据render函数，解析经过compile，语法树处理过后的模版表达式，访问真实的data属性，触发get。***

***③ get方法首先经过之前不同的reactive，通过track方法进行依赖收集。***

***④ track方法通过当前proxy对象target,和访问的属性名key来找到对应的dep。***

***⑤ 将dep与当前的activeEffect建立起联系。将activeEffect压入dep数组中，（此时的dep中已经含有当前组件的渲染effect,这就是响应式的根本原因）如果我们触发set，就能在数组中找到对应的effect，依次执行。***



最后我们用一个流程图来表达一下依赖收集的流程。

![img](https://pic3.zhimg.com/80/v2-aaa2e421a2c9ac965efb6de4d31d9c12_720w.jpg)

## 七 set 派发更新



接下来我们set部分逻辑。

```js
const set = /*#__PURE__*/ createSetter()
/* 浅逻辑 */
const shallowSet = /*#__PURE__*/ createSetter(true)
```

set也是分两个逻辑，set和shallowSet,两种方法都是由createSetter产生，我们这里主要以set进行剖析。

**createSetter创建set**



```js
function createSetter(shallow = false) {
  return function set(
    target: object,
    key: string | symbol,
    value: unknown,
    receiver: object
  ): boolean {
    const oldValue = (target as any)[key]
    /* shallowSet逻辑 */

    const hadKey = hasOwn(target, key)
    const result = Reflect.set(target, key, value, receiver)
    /* 判断当前对象，和存在reactiveToRaw 里面是否相等 */
    if (target === toRaw(receiver)) {
      if (!hadKey) { /* 新建属性 */
        /*  TriggerOpTypes.ADD -> add */
        trigger(target, TriggerOpTypes.ADD, key, value)
      } else if (hasChanged(value, oldValue)) {
        /* 改变原有属性 */
        /*  TriggerOpTypes.SET -> set */
        trigger(target, TriggerOpTypes.SET, key, value, oldValue)
      }
    }
    return result
  }
}
```

createSetter的流程大致是这样的

***① 首先通过toRaw判断当前的proxy对象和建立响应式存入reactiveToRaw的proxy对象是否相等。\***

***② 判断target有没有当前key,如果存在的话，改变属性，执行trigger(target, TriggerOpTypes.SET, key, value, oldValue)。\***

***③ 如果当前key不存在，说明是赋值新属性，执行trigger(target, TriggerOpTypes.ADD, key, value)\***



**trigger**



```js
/* 根据value值的改变，从effect和computer拿出对应的callback ，然后依次执行 */
export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
  oldTarget?: Map<unknown, unknown> | Set<unknown>
) {
  /* 获取depssMap */
  const depsMap = targetMap.get(target)
  /* 没有经过依赖收集的 ，直接返回 */
  if (!depsMap) {
    return
  }
  const effects = new Set<ReactiveEffect>()        /* effect钩子队列 */
  const computedRunners = new Set<ReactiveEffect>() /* 计算属性队列 */
  const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {
    if (effectsToAdd) {
      effectsToAdd.forEach(effect => {
        if (effect !== activeEffect || !shouldTrack) {
          if (effect.options.computed) { /* 处理computed逻辑 */
            computedRunners.add(effect)  /* 储存对应的dep */
          } else {
            effects.add(effect)  /* 储存对应的dep */
          }
        }
      })
    }
  }

  add(depsMap.get(key))

  const run = (effect: ReactiveEffect) => {
    if (effect.options.scheduler) { /* 放进 scheduler 调度*/
      effect.options.scheduler(effect)
    } else {
      effect() /* 不存在调度情况，直接执行effect */
    }
  }

  //TODO: 必须首先运行计算属性的更新，以便计算的getter
  //在任何依赖于它们的正常更新effect运行之前，都可能失效。

  computedRunners.forEach(run) /* 依次执行computedRunners 回调*/
  effects.forEach(run) /* 依次执行 effect 回调（ TODO: 里面包括渲染effect ）*/
}
```

我们这里保留了trigger的核心逻辑

***① 首先从targetMap中，根据当前proxy找到与之对应的depsMap。***

***② 根据key找到depsMap中对应的deps，然后通过add方法分离出对应的effect回调函数和computed回调函数。***

***③ 依次执行computedRunners 和 effects 队列里面的回调函数，如果发现需要调度处理,放进scheduler事件调度***

值得注意的的是：

![img](https://pic4.zhimg.com/80/v2-45e04ae58220ca4d495cb44b751a0d97_720w.jpg)

renderEffect，还有通过effectAPI建立的effect，以及通过watch形成的effect。我们这里只考虑到渲染effect。至于后面的情况会在接下来的文章中和大家一起分享。

我们用一幅流程图说明一下set过程。

## 八 总结

我们总结一下整个数据绑定建立响应式大致分为三个阶段



***1 初始化阶段： 初始化阶段通过组件初始化方法形成对应的proxy对象，然后形成一个负责渲染的effect。***

***2 get依赖收集阶段：通过解析template，替换真实data属性，来触发get,然后通过stack方法，通过proxy对象和key形成对应的deps，将负责渲染的effect存入deps。（这个过程还有其他的effect，比如watchEffect存入deps中 ）。***

***3 set派发更新阶段：当我们 this[key] = value 改变属性的时候，首先通过trigger方法，通过proxy对象和key找到对应的deps，然后给deps分类分成computedRunners和effect,然后依次执行，如果需要调度的，直接放入调度。***


# vuex中的commit和dispatch的区别

dispatch：含有异步操作，例如向后台提交数据，写法： this.$store.dispatch('action方法名',值)

commit：同步操作，写法：this.$store.commit('mutations方法名',值)


# **vue中 key 值的作用？**

当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。


# **vue中使用v-for时为什么不能用index作为key？**

**key的作用：主要是为了高效的更新虚拟DOM** 。

**vue中使用v-for时用index作为key会出现以下问题：**

1. **更新DOM的时候会出现性能问题**
2. **会发生一些状态bug**

**举个栗子：**

```html
<template>
	<div v-for="(item, index) in list" :key="index" >{{item.name}}</div>
</template>
const list = [
    {
        id: 1,
        name: "Person1"
    },
    {
        id: 2,
        name: "Person2"
    },
    {
        id: 3,
        name: "Person3"
    },
    {
        id:4,
        name:"Person4"
    }
];
```

此时，删除 “Person4” 是正常的，但是如果我删除 “Person2” 就会出现问题。

**删除前**

| key  | id   | index | name    |
| ---- | ---- | ----- | ------- |
| 0    | 1    | 0     | Person1 |
| 1    | 2    | 1     | Person2 |
| 2    | 3    | 2     | Person3 |
| 3    | 4    | 3     | Person4 |

**删除后**

| key  | id   | index | name    |
| ---- | ---- | ----- | ------- |
| 0    | 1    | 0     | Person1 |
| 1    | 3    | 1     | Person3 |
| 2    | 4    | 2     | Person4 |

这个时候，除了 Person1 之外，剩下的 Person3、Person4，因为被发现与相应 `key` 的绑定关系有变化，所以被重新渲染，这会影响性能。
如果此时 `list` 的 `item` 是 select 的选项，其中 Person3 是选中的，这个时候 Person2 被删除了，用 index 作为 key 就会变成是 Person4 选中的了，这就产生了bug。

如果使用唯一id作为key，删除 Person2 后，剩下的元素因为与 `key` 的关系没有发生变化，都不会被重新渲染，从而达到提升性能的目的。此时，`list` 的 `item` 作为 select 的选项，也不会出现上面所描述的bug。


# vue之template模板解析



虚拟DOM构建经历

template编译成AST语法树

再转换为render函数

最终返回一个VNode(VNode就是Vue的虚拟DOM节点) 。

### 什么是AST

在Vue的mount过程中，template会被编译成AST语法树，AST是指抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式。

可以看出：在options中，vue默认先使用render函数，如果没有提供render函数，则会使用template模板，最后再使用el，通过解析模板编译AST，最终转化为render。

# **vue常用的修饰符？**

### **事件修饰符**

.prevent: 提交事件不再重载页面；

.stop: 阻止单击事件冒泡；

.self: 当事件发生在该元素本身而不是子元素的时候会触发；

.capture: 事件侦听，事件发生的时候会调用

### **按键修饰符**

为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：

- `.enter`
- `.tab`
- `.delete` (捕获“删除”和“退格”键)
- `.esc`
- `.space`
- `.up`
- `.down`
- `.left`
- `.right`

### `.sync` 修饰符

是一个重要的语法糖，它可以快速实现组件间的通信

如果不适用 `.sync` ,就需要在 父组件中完整的写出

```js
<Child :money="total" v-on:update:money="total = $event"/>
```

如果使用语法糖

```js
<Child :money.sync="total"/>
```

### .native 修饰符

在组件上去监听事件时，我们监听的是组件的自动触发的自定义事件,想要触发原生事件加入.native 修饰符


### vue项目中引入typescript



1. **什么是typescript**

​        <font color=red>TypeScript</font> 是 `JavaScript` 的强类型版本。然后在编译期去掉类型和特有语法，生成纯粹的 `JavaScript` 代码。由于最终在浏览器中运行的仍然是 `JavaScript`，所以<font color=red>TypeScript</font>并不依赖于浏览器的支持，也并不会带来兼容性问题。

​        <font color=red>TypeScript</font>是 `JavaScript` 的超集，这意味着他支持所有的 `JavaScript` 语法。并在此之上对 `JavaScript` 添加了一些扩展，如 `class` / `interface` / `module` 等。这样会大大提升代码的可阅读性。

​		与此同时，<font color=red>TypeScript</font>也是 `JavaScript ES6` 的超集，`在vue3.0中也将采用 `<font color=red>TypeScript</font>进行开发。这更是充分说明了这是一门面向未来并且脚踏实地的语言。

2. **为什么要接入typescript**

   javascript由于自身的弱类型，使用起来非常灵活。这也就为大型项目、多人协作开发埋下了很多隐患。如果是自己的私有业务倒无所谓，主要是对外接口和公共方法，对接起来非常头疼。主要表现在几方面：

- 参数类型没有校验，怎么传都有，有时会出现一些由于类型转换带来的未知问题。
- 接口文档不规范，每次都要通过读代码才能知道传什么，怎么传
- 接口编写符合规范，但是公共库中有大量的处理类型校验的代码

  这就非常不利于工程标准化。于是我们决定引入typescript进行代码层面的强校验。

3. **原有vue项目接入ts主要包含下面几大步骤**：

    1) 安装typescript相关npm包

    2) 修改webpack和ts配置文件

    3) 项目公共库和vue文件改造



具体可以看下面的参考链接

相关参考:	[vue-typescript入门](https://www.jianshu.com/p/8ba2cdbfabd7)

​					[github参考项目](https://github.com/biaochenxuying/blog-vue-typescript)

​					[原有vue项目接入typescript](https://www.cnblogs.com/fundebug/p/10042983.html)

​					[Vue全家桶+TypeScript使用总结](https://www.jianshu.com/p/6c064270691f)

​					[typescript教程](https://ts.xcatliu.com/)

# 什么是vuex

**Vuex** 是一个专为 Vue.js 应用程序开发的状态管理模式，多个组件之前的状态传递和管理。这个状态我们可以理解为在data中的属性，需要共享给其他组件使用的部分。

vuex中，有默认的五种基本的对象：

state：存储状态（变量）

getters：对数据获取之前的再次编译，可以理解为state的计算属性。我们在组件中使用 $sotre.getters.fun()

mutations：修改状态，并且是同步的。在组件中使用$store.commit('',params)。这个和我们组件中的自定义事件类似。

actions：异步操作。在组件中使用是$store.dispath('')

modules：store的子模块，为了开发大型项目，方便状态管理而使用的。这里我们就不解释了，用起来和上面的一样。

### vuex中为什么把异步操作封装在action，把同步操作放在mutations？

actions 和 mutations 并不是为了解决**竞态问题**（两个异步请求，哪个回调先执行的问题），而是为了能用 devtools 追踪状态变化。事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行。异步竞态怎么处理那是用户自己的事情。vuex 真正限制你的只有 mutation 必须是同步的这一点（在 redux 里面就好像 reducer 必须同步返回下一个状态一样）。同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。其实我有个点子一直没时间做，那就是把记录下来的 mutations 做成类似 rx-marble 那样的时间线图，对于理解应用的异步状态变化很有帮助。


# 关于vue rem适配布局方案

## PostCSS的插件

> 作用：用于自动将像素单元生成rem单位
> **记以下三种**

- [postcss-plugin-px2rem](https://www.npmjs.com/package/postcss-plugin-px2rem)
- [postcss-pxtorem](https://www.npmjs.com/package/postcss-pxtorem)
- [postcss-px2rem](https://www.npmjs.com/package/postcss-px2rem)

> 任选一种，最近大家推荐第一种（在配置上多了配置选项上有 `exclude` 属性，可配置是否对 某个文件夹下的所有css文件不进行转换），之前我用的第二种（也是目前使用最多的）
> 都有可以配置`selectorBlackList: []` 要忽略并保留为px的选择器
> 还有个小技巧 -- 如果个别地方不想转化px。可以简单的使用大写的 `PX` 或 `Px` 。

#### 使用方法

1. 选择你要用的插件安装依赖： `npm i postcss-plugin-px2rem -D`或 `npm i postcss-pxtorem -D` 或 `npm i postcss-px2rem -D`
2. 配置方法

> 换算单位 **pc端一般基数为37.5，移动端一般为16或者32**

- 用`vue init webpack projectName` 创建的项目，postcss配置文件在根目录下 `.postcssrc.js`
  （该文件为使用vue init自动创建的文件）

```js
module.exports = {
  "plugins": {
    "postcss-import": {},
    "postcss-url": {},
    "autoprefixer": {},
    // 新增
    /**
     * postcss-plugin-px2rem 配置
     * 详见官方文档
    */
    'postcss-plugin-px2rem': {
        // rootValue: 100, //换算基数， 默认100  ，这样的话把根标签的字体规定为1rem为50px,这样就可以从设计稿上量出多少个px直接在代码中写多上px了。 
        // unitPrecision: 5, //允许REM单位增长到的十进制数字。
        //propWhiteList: [],  //默认值是一个空数组，这意味着禁用白名单并启用所有属性。
        // propBlackList: [], //黑名单
        exclude: /(node_module)/,  //默认false，可以（reg）利用正则表达式排除某些文件夹的方法，例如/(node_module)/ 。如果想把前端UI框架内的px也转换成rem，请把此属性设为默认值
        // selectorBlackList: [], //要忽略并保留为px的选择器
        // ignoreIdentifier: false,  //（boolean/string）忽略单个属性的方法，启用ignoreidentifier后，replace将自动设置为true。
        // replace: true, // （布尔值）替换包含REM的规则，而不是添加回退。
        mediaQuery: false,  //（布尔值）允许在媒体查询中转换px。
        minPixelValue: 3 //设置要替换的最小像素值(3px会被转rem)。 默认 0
    }

    /**
     * postcss-pxtorem 配置
     * 详见官方文档
    */
    'postcss-pxtorem': {
      rootValue: 37.5,    // 换算的基数 默认100，作用 设计稿上元素宽375px,最终页面会换算成 10rem
      selectorBlackList  : ['weui','mu'], // 忽略转换正则匹配项（选择器）
      propList: ['*']
    }

    /**
     * postcss-px2rem配置
     * 详见官方文档
    */
    'postcss-px2rem': {
      remUnit: 30   // 换算的基数
    }

  }
}
```

- 用vue-cli3.0中 `vue create projectName` 创建的项目， 没有了build和config文件夹，postcss配置文件在根目录下 `postcss.config.js` (该文件为使用vue-cli3自动创建的文件)

```js
module.exports = {
  plugins: {
    autoprefixer: {
      browsers: ['Android >= 4.0', 'iOS >= 7']
    },

    /**
     * postcss-plugin-px2rem 配置
     * 详见官方文档
    */
    'postcss-plugin-px2rem': {
        // rootValue: 32, 
        // unitPrecision: 5, 
        // propWhiteList: [],  
        // propBlackList: [], 
        exclude: /(node_module)/,  
        // selectorBlackList: [], 
        // ignoreIdentifier: false, 
        // replace: true, 
        mediaQuery: false,  
        minPixelValue: 3 
    }

    /**
     * postcss-pxtorem 配置
     * 详见官方文档
    */
    'postcss-pxtorem': {
      rootValue: 37.5,  
      selectorBlackList  : ['weui','mu'], 
      propList: ['*']
    }

    /**
     * postcss-px2rem配置
     * 详见官方文档
    */
    'postcss-px2rem': {
      remUnit: 30   // 换算的基数
    }


  }
}
```

> 个人习惯，有人喜欢所有的配置都放到了vue.config.js（vue-cli3.0默认没有此文件，需要你创建一个）中
> （一般会在里面配置有代理跨域）

```js
module.exports = {
  //反向代理的配置
  devServer: {
    proxy: {
      '/api': {
          target: 'http://m.maoyan.com', //目标地址
          // ws: true, //// 是否启用websockets
          changeOrigin: true, //开启代理：在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题
          pathRewrite: {'^/api': '/'}    //这里重写路径
      }
    }
  },
}
```

- postcss配置如下

```js
module.exports = {
  /**
   * 反向代理的配置 
  */
  lintOnSave: true,
   css: {
        loaderOptions: {
            postcss: {
                plugins: [
                  /**
                   * postcss-plugin-px2rem 配置
                   * 详见官方文档
                  */
                  require('postcss-plugin-px2rem')({
                        // rootValue: 100, 
                        // unitPrecision: 5, 
                        //propWhiteList: [],  
                        // propBlackList: [], 
                        exclude: /(node_module)/,  
                        // selectorBlackList: [], 
                        // ignoreIdentifier: false,  
                        // replace: true,
                        mediaQuery: false, 
                        minPixelValue: 3 
                    }),
                 /**
                   * postcss-pxtorem 配置
                   * 详见官方文档
                  */
                  require('postcss-pxtorem')({
                        rootValue : 1, 
                        selectorBlackList  : ['weui','mu'], 
                        propList   : ['*'],
                    }),
                 /**
                   * postcss-pxtorem 配置
                   * 详见官方文档
                  */
                  require('postcss-px2rem')({ 
                        remUnit: 30
                  }), // 换算的基数
                ]
            }
        }
   }
}
```

### 也可以通过自己写js的方式实现

src目录下，新建 utils/rem.js 输入如下代码

web适配方案

> 以下为pc版本 **pc设计稿调整为1080** 若为移动版，**移动端web 设计稿调整为750**

```js
// 基准大小 
const baseSize = 32
// 设置 rem 函数 
function setRem() {
  // 当前页面宽度相对于 1080 宽的缩放比例，可根据自己需要修改。 
  const scale = document.documentElement.clientWidth / 1080
  // 设置页面根节点字体大小 
  document.documentElement.style.fontSize = (baseSize * Math.min(scale, 2)) + 'px'
}
// 初始化 
setRem()
// 改变窗口大小时重新设置 rem 
window.onresize = function () { setRem() }
```

或

```js
// 设置 rem 函数
function setRem () {

    // 320 默认大小16px; 320px = 20rem ;每个元素px基础上/16
    let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth;
    //得到html的Dom元素
    let htmlDom = document.getElementsByTagName('html')[0];
    //设置根元素字体大小
    htmlDom.style.fontSize= htmlWidth/20 + 'px';
}
// 初始化
setRem();
// 改变窗口大小时重新设置 rem
window.onresize = function () {
    setRem()
}
```

- 最后在main.js中引入rem.js `import './libs/rem.js';`

# 关于vue vw适配布局方案

#### 安装postcss-px-to-viewport

```
npm install postcss-px-to-viewport
```

#### 根目录新建postcss.config.js文件

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```js
//postcss.config.js文件
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      unitToConvert: 'px', //需要转换的单位，默认为"px"
      viewportWidth: 375, // 视窗的宽度，对应的是我们设计稿的宽度
      viewportHeight: 1334,//视窗的高度，根据375设备的宽度来指定，一般指定667，也可以不配置
      unitPrecision: 13, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除）
      propList: ['*'], // 能转化为vw的属性列表
      viewportUnit: 'vw', // 指定需要转换成的视窗单位，建议使用vw
      fontViewportUnit: 'vw', //字体使用的视口单位
      selectorBlackList: ['.ignore-', '.hairlines'], //指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名
      minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值
      mediaQuery: false, // 允许在媒体查询中转换`px`
      replace: true, //是否直接更换属性值，而不添加备用属性
      exclude: [
        /RightBar/,
        /gotop.vue/,
      ], //忽略某些文件夹下的文件或特定文件，例如 'node_modules' 下的文件
      landscape: false, //是否添加根据 landscapeWidth 生成的媒体查询条件 @media (orientation: landscape)
      landscapeUnit: 'vw', //横屏时使用的单位
      landscapeWidth: 1134 //横屏时使用的视口宽度
    }
  }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)


**目标：**基于vue的，pc前端页面适配

**步骤：**在百度上找到两种实现方式：

1、[Vue项目中使用vw实现移动端适配](https://www.cnblogs.com/kdcg/p/9106463.html)

2、[Vue rem适配布局方案](https://www.jianshu.com/p/1d913261d56f)

分别验证两种方式是否可行，先看一下两种方式的实现原理：

1、vw的方式进行适配，根据视口viewport动态计算，根据[CSS3规范](https://drafts.csswg.org/css-values-3/#viewport-relative-lengths)，视口单位主要包括以下4个：

- vw : 1vw 等于视口宽度的1%
- vh : 1vh 等于视口高度的1%
- vmin : 选取 vw 和 vh 中最小的那个
- vmax : 选取 vw 和 vh 中最大的那个
- **IE**：自 **IE10** 起（包括 **Edge**）到现在还只是部分支持（不支持 **vmax**，同时 **vm** 代替 **vmin**）

视口viewport即浏览器可视区域大小
我们可以这样理解 100vw = window.innerwidth, 100vh = window.innerheight

对于设计稿的尺寸转换为vw单位，我们使用Sass函数编译[·](http://caibaojian.com/vw-vh.html)

```css
//iPhone 6尺寸作为设计稿基准
$vm_base: 375; 
@function vw($px) {
    @return ($px / 375) * 100vw;
}
```

2、rem是相对于根元素的字体大小的单位，也就是html的font-size大小，浏览器默认的字体大小是16px，所以默认的1rem=16px，我们可以根据设备宽度动态设置根元素的font-size，使得以rem为单位的元素在不同终端上以相对一致的视觉效果呈现。

3、两者对比

1）vw没有根元素大小的限制，浏览器默认最小字体12px，所以rem计算会有一定限制。

2）rem需要在html页面引入计算js，需要依赖js控制。

3）vm兼容性没有全部支持，但基本满足使用。



**实现方式：**最后选择vw的方式进行适配

**第一步：**在html页面设置，禁止用户放大缩小，在不同的像素下都是使用1倍的像素值

```html
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
```

```html
meta[name="viewport"]里各参数的含义为：
 
　　width: 设置layout viewport 的宽度，为一个正整数，或字符串”width-device”。
 
　　initial-scale: 设置页面的初始缩放值，为一个数字，可以带小数。
 
　　minimum-scale: 允许用户的最小缩放值，为一个数字，可以带小数。
 
　　maximum-scale: 允许用户的最大缩放值，为一个数字，可以带小数。
 
　　height: 设置layout viewport 的高度，这个属性对我们并不重要，很少使用。
 
　　user-scalable: 是否允许用户进行缩放，值为“no”或“yes”。
```

##### 第二步：安装插件

为了实现vw兼容方案，我们需要安装如下插件：

- postcss-import [相关配置](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fpostcss%2Fpostcss-import)
  主要功有是解决`@import`引入路径问题。使用这个插件，可以很轻易的使用本地文件、`node_modules`或者`web_modules`的文件。这个插件配合`postcss-url`使引入文件变得更轻松。
- postcss-url [相关配置](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fpostcss%2Fpostcss-url)
  主要用来处理文件，比如图片文件、字体文件等引用路径的处理。
- postcss-px-to-viewport [相关配置](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fevrone%2Fpostcss-px-to-viewport)
  主要用来把`px`单位转换为`vw`、`vh`、`vmin`或者`vmax`这样的视窗单位，也是`vw`适配方案的核心插件之一。
- postcss-viewport-units [相关配置](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fspringuper%2Fpostcss-viewport-units)
  主要是给CSS的属性添加`content`的属性，给`vw`、`vh`、`vmin`和`vmax`做适配的操作，这是实现vw布局必不可少的一个插件。
- postcss-cssnext [相关配置](https://links.jianshu.com/go?to=https%3A%2F%2Fcssnext.io%2Ffeatures%2F%23automatic-vendor-prefixes)
  该插件可以让我们使用CSS未来的特性，其会对这些特性做相关的兼容性处理。
- cssnano [相关配置](https://links.jianshu.com/go?to=https%3A%2F%2Fcssnano.co%2Fguides%2Fgetting-started%2F)
  主要用来压缩和清理CSS代码。在Webpack中，`cssnano`和[`css-loader`](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fcss-loader)捆绑在一起，所以不需要自己加载它。
- postcss-write-svg [相关配置](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fjonathantneal%2Fpostcss-write-svg)
  主要用来处理移动端1px的解决方案
- postcss-aspect-ratio-mini [相关配置](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fyisibl%2Fpostcss-aspect-ratio-mini)
  主要用来处理元素容器宽高比

**安装命令**

```js
npm i postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano cssnano-preset-advanced --S  
```

##### 第三步：插件配置

找到postcss的配置文件，在工程的根目录中**postcss.config.js**或者**.postcssrc.js**文件

```js
module.exports = {
  "plugins": {
  	"autoprefixer": {},
    "postcss-import": {},
    "postcss-url": {},
    "postcss-aspect-ratio-mini": {},
    "postcss-write-svg": {
      utf8: false
    },
    "postcss-cssnext": {},
    "postcss-px-to-viewport": {
      viewportWidth: 1920,     //  视窗的宽度，对应的是我们设计稿的宽度，移动端一般是750，如果是pc端那就是类似1920这样的尺寸
      viewportHeight: 1080,    // 视窗的高度，移动端一般指定1334，也可以不配置
      unitPrecision: 1,       // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除）
      viewportUnit: 'vw',    // 指定需要转换成的视窗单位，建议使用vw
      fontViewportUnit: 'vw',
      selectorBlackList: ['.ignore', '.hairlines'],  // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名
      minPixelValue: 1,      // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值
      mediaQuery: false      // 允许在媒体查询中转换`px`
    },
    "postcss-viewport-units":{},
    "cssnano": {
      preset: "advanced", 
    	autoprefixer: false, 
      "postcss-zindex": false
    }
  }
}
```

# 如何优雅的只在当前页面中覆盖ui库中组件的样式

下面说下优雅的解决方式：通过深度选择器解决。例如修改上图中组件里的van-ellipsis类的样式，可以这样做：

```css
.van-tabs /deep/ .van-ellipsis { color:blue};
```

编译后的结果就是：

```css
.van-tabs[v-data-23d425f8] .van-ellipsis {
	color:blue
}
```

这样就不会给van-ellipsis也添加[data-v-23d425f8]属性了。至此你可以愉快的修改第三方组件的样式了。当然了这里的深度选择器/deep/是因为我用的less语言，如果你没有使用less/sass等，可以用>>>符号。


# 简单手写双向绑定原理

## 双向绑定原理

```js
<input type="text" oninput="evtInput()" id="input"/>
<p id="text"></p>
// 1、定义对象vue,其中有个属性：name
let vue = { name: "123" };

function evtInput() {
  // 页面数据发生变化如何通知到JS
  vue.name = document.getElementById("input").value;
  document.getElementById("text").innerHTML = vue.name;
  console.log("页面上的数据发生了变化：", vue.name);
}

// 2. 拦截对象vue的元素name，重新处理get和set方法。
// JS数据变化如何通知到页面
Object.defineProperty(vue, "name", {
  // 当获取name元素值时，get方法被执行。
  get: function() {
    console.log("get方法被执行");
    return "456";
  },
  // 当重新赋值name值时，set方法被执行。
  set: function(v) {
    document.getElementById("input").value = v;
    document.getElementById("text").innerHTML = v;
    console.log("set方法被执行，js数据变化通知到页面，新的值为：", v);
  }
});
```


# 聊一聊Diff算法

## **传统Diff算法**

> 处理方案: 循环递归每一个节点

*传统diff*

![img](https://pic1.zhimg.com/80/v2-dbd46841ee44beb0577c82f5c2e49b5c_720w.jpg)

如上所示, 左侧树a节点依次进行如下对比:

> a->e、a->d、a->b、a->c、a->a

之后左侧树其它节点b、c、d、e亦是与右侧树每个节点对比, 算法复杂度能达到O(n^2)

查找完差异后还需计算最小转换方式，这其中的原理我没仔细去看，最终达到的算法复杂度是O(n^3)

> 将两颗树中所有的节点一一对比需要O(n²)的复杂度，在对比过程中发现旧节点在新的树中未找到，那么就需要把旧节点删除，删除一棵树的一个节点(找到一个合适的节点放到被删除的位置)的时间复杂度为O(n),同理添加新节点的复杂度也是O(n),合起来diff两个树的复杂度就是O(n³)

### **Vue优化Diff**

> vue2.0加入了virtual dom，和react拥有相同的 diff 优化原则

![img](https://pic4.zhimg.com/80/v2-e6be71e8ff79fc576111b761f297bccb_720w.jpg)

差异就在于, diff的过程就是调用patch函数，就像打补丁一样修改真实dom

- patchVnode
- updateChildren

updateChildren是vue diff的核心
过程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx>EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较

![img](https://pic2.zhimg.com/80/v2-cb2617306eb25e8def4a38b807e42abd_720w.jpg)

### **Vue 2.x vs Vue 3.x**

Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅

Vue3.x借鉴了 ivi算法和 inferno算法。在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。


# 聊聊keep-alive组件的使用及其实现原理

## **keep-alive**



keep-alive是Vue.js的一个内置组件。它能够将不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。

它提供了include与exclude两个属性，允许组件有条件地进行缓存。

**用法**

```html
<keep-alive>
    <component></component>
</keep-alive>
```

这里的component组件会被缓存起来。

**生命钩子**

keep-alive提供了两个生命钩子，分别是activated与deactivated。

因为keep-alive会将组件保存在内存中，并不会销毁以及重新创建，所以不会重新调用组件的created等方法，需要用activated与deactivated这两个生命钩子来得知当前组件是否处于活动状态。
