# http2.0和http3.0和https对比

## **一、HTTP协议**

HTTP协议是HyperText Transfer Protocol（超文本传输协议）的缩写，它是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。伴随着计算机网络和浏览器的诞生，HTTP1.0也随之而来，处于计算机网络中的应用层，HTTP是建立在TCP协议之上，所以**HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性**，例如tcp建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。

## **HTTP/2 新特性**

### **1. 二进制传输**

HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。**HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码**。

接下来我们介绍几个重要的概念：

- 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；

- 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。

- 帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等

- ![img](https://pic4.zhimg.com/80/v2-13652bf03136b73af83d01f0b07f6ee3_720w.jpg)



HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。



### **2. 多路复用**

在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。

### **3. Header 压缩**

在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节

### **4. Server Push**

Server Push即服务端能通过push的方式将客户端需要的内容预先推送过去，也叫“cache push”。

## **HTTP/3 新特性**

### **1. HTTP/3简介**

虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。

上文提到 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。

因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。

那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。

基于这个原因，**Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上**，HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。

### 那么Quic是什么？

Quic(QuickUDP Internet Connections)是一种新的传输方式，与TCP相比，它减少了延迟。表面上，Quic非常类似于在UDP上实现的TCP+TLS+HTTP/2。由于TCP是在操作系统内核和中间件固件中实现的，因此对TCP进行重大更改几乎是不可能的。然而，由于Quic是构建在UDP之上的，所以它没有受到这样的限制。

**Quic在现有TCP+TLS+HTTP 2上的关键特性包括**

- 大大缩短连接建立时间
- 改进的拥塞控制
- 无线头阻塞的多路复用
- 前向纠错
- 连接迁移

## HTTPS

HTTPS 是最流行的 HTTP 安全形式，由网景公司首创，所有主要的浏览器和服务器都支持此协议。 使用 HTTPS 时，所有的 HTTP 请求和响应数据在发送之前，都要进行加密。加密可以使用 SSL 或 TLS。

- 对称加密：

- - 加密和解密都是用同一个密钥

- 非对称加密：

- - 加密用公开的密钥，解密用私钥
- (私钥只有自己知道，公开的密钥大家都知道)

- 数字签名：

- - 验证传输的内容**是对方发送的数据**
- 发送的数据**没有被篡改过**

- 数字证书（Certificate Authority）简称CA

- - 认证机构证明是**真实的服务器发送的数据**。



私钥：放在服务器。

公钥：放在互联网上， 所有人都可以拿到的加密的字符串。这个字符串用来加密我们传输的信息。使用公钥加密的数据传输到服务器上之后，只有服务器通过私钥进行解密，才能把公钥加密过的数据给解密出来。任何人都拿不到私钥，因为私钥只放在服务器上。不会放到互联网上进行传输。

公钥和私钥，在握手的时候进行传输。

HTTPS传输的过程

![img](https://pic4.zhimg.com/80/v2-b4966edb67956d7643e2dac0154ed733_720w.jpg)

1、客户端先生成一个随机数，传输给服务端，中间会带上客户端支持的加密套件。

2、服务端拿到这个随机数之后，先保存，也生成一个随机数，会伴随着一个证书，也就是公钥，传输给客户端。

3、客户端收到服务端传来的随机数和公钥，也保存下，然后生成一个预主秘钥，也就是第三个随机数，这个随机数用公钥加密了，传输给服务器。

4、服务端收到加密的预主秘钥，使用私钥进行解密，拿到预主秘钥，客户端和服务端同时对这三个随机数进行算法的操作，生成一个主秘钥。后期传输的数据都是通过这个主秘钥进行加密的。

HTTPS默认使用的端口：443

需要第三方权威机构来颁发安全证书。

#  vue.config.js基础配置

```js
const path = require('path')
const UglifyPlugin = require('uglifyjs-webpack-plugin')
module.exports = {
  publicPath: './', // 基本路径
  outputDir: 'dist', // 输出文件目录
  lintOnSave: false, // eslint-loader 是否在保存的时候检查
  // see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md
  // webpack配置
  chainWebpack: (config) => {
  },
  configureWebpack: (config) => {
    if(process.env.NODE_ENV === 'production') {
      // 为生产环境修改配置...
      config.mode = 'production'
      // 将每个依赖包打包成单独的js文件
      let optimization = {
        runtimeChunk: 'single',
        splitChunks: {
          chunks: 'all',
          maxInitialRequests: Infinity,
          minSize: 20000,
          cacheGroups: {
            vendor: {
              test: /[\\/]node_modules[\\/]/,
              name (module) {
                // get the name. E.g. node_modules/packageName/not/this/part.js
                // or node_modules/packageName
                const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1]
                // npm package names are URL-safe, but some servers don't like @ symbols
				return npm.${packageName.replace('@', '')}
				  }
            }
          }
        },
        minimizer: [new UglifyPlugin({
          uglifyOptions: {
            compress: {
              warnings: false,
              drop_console: true, // console
              drop_debugger: false,
              pure_funcs: ['console.log'] // 移除console
            }
          }
        })]
      }
      Object.assign(config, {
        optimization
      })
    } else {
      // 为开发环境修改配置...
      config.mode = 'development'
    }
    Object.assign(config, {
      // 开发生产共同配置
      resolve: {
        alias: {
          '@': path.resolve(__dirname, './src'),
          '@c': path.resolve(__dirname, './src/components'),
          '@p': path.resolve(__dirname, './src/pages')
        } // 别名配置
      }
    })
  },
  productionSourceMap: false, // 生产环境是否生成 sourceMap 文件
  // css相关配置
  css: {
    extract: true, // 是否使用css分离插件 ExtractTextPlugin
    sourceMap: false, // 开启 CSS source maps?
    loaderOptions: {
      css: {}, // 这里的选项会传递给 css-loader
      postcss: {} // 这里的选项会传递给 postcss-loader
    }, // css预设器配置项
    modules: false // 启用 CSS modules for all css / pre-processor files.
  },
  parallel: require('os').cpus().length > 1, // 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。
  pwa: {}, // PWA 插件相关配置 see https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa
  // webpack-dev-server 相关配置
  devServer: {
    open: process.platform === 'darwin',
    host: '0.0.0.0', // 允许外部ip访问
    port: 2333, // 端口
    https: false, // 启用https
    overlay: {
      warnings: true,
      errors: true
    }, // 错误、警告在页面弹出
    proxy: {
      '/api': {
        target: 'http://www.baidu.com/api',
        changeOrigin: true, // 允许websockets跨域
        // ws: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    } // 代理转发配置，用于调试环境
  },
  // 第三方插件配置
  pluginOptions: {}
}
```



https://www.cnblogs.com/tuziling/p/10818395.html

# vue动态主题切换（elementui+webpack-theme-color-replacer）

利用webpack-theme-color-replacer插件，为elementui实现了在运行时动态切换主题色的功能，无需在页面进行scss的编译，提升了切换速度。

### 一、安装webpack-theme-color-replacer

```js
npm install webpack-theme-color-replacer
```

### 二、基于vue/cli3脚手架的配置文件vue.config.js

```js
//引入插件
const ThemeColorReplacer = require('webpack-theme-color-replacer');
//动态切换elementui主题，需要用到
const forElementUI = require('webpack-theme-color-replacer/forElementUI');
//所有主题的颜色变量都放在这里
var { themeColor } = require('./src/utils/theme_common.js');

//主题切换插件配置
configureWebpack: {
    plugins: [
        //生成仅包含颜色的替换样式（主题色等）
        new ThemeColorReplacer({
            fileName: 'static/css/theme-colors.[contenthash:8].css',
            matchColors: [...forElementUI.getElementUISeries('#409EFF'), ...themeColor['#409EFF']],
            changeSelector: forElementUI.changeSelector,
            isJsUgly: process.env.NODE_ENV !== 'development',
        })
    ]
},
```

theme_common.js主题颜色文件

```js
//默认主题颜色数组
const defaultThemeArray = ['#409EFF', '#606266', '#ffffff', '#f2f2f2', '#c0c4cc', '#67c23a', '#ecf5ff',
	'#ebeef5', '#fafafa', '#909399', '#e6a23c'
];
//绿色主题
const greenThemeArray = ['#09900f', '#606266', '#ffffff', '#f2f2f2', '#c0c4cc', '#67c23a', '#ecf5ff',
	'#ebeef5', '#fafafa', '#909399', '#e6a23c'
];
//根据需求，自己定义相应的数据结构
exports.themeColor = {
	"#409EFF": defaultThemeArray,
	"#000000": defaultThemeArray,
	"#ffffff": defaultThemeArray,
	"#09900f": greenThemeArray,
}
```

### 三、主题切换方法theme_color_client.js

```js
import client from 'webpack-theme-color-replacer/client'
import forElementUI from 'webpack-theme-color-replacer/forElementUI'
import {themeColor} from '@/utils/theme_common.js'

//默认主题颜色
export let curColor = "#409EFF";

// 动态切换主题色
export function changeThemeColor(newColor) {
    var options = {
        newColors: [...forElementUI.getElementUISeries(newColor), ...themeColor[newColor]],
    }
    return client.changer.changeColor(options, Promise)
        .then(t => {
            curColor = newColor
            localStorage.setItem('theme_color', curColor)
        });
}

export function initThemeColor() {
    const savedColor = localStorage.getItem('theme_color')
    if (savedColor) {
        curColor = savedColor
        changeThemeColor(savedColor)
    }
}
```

### 四、主题切换初始化

在main.js文件中初始化主题

```js
// 主题换肤
import { initThemeColor } from './utils/theme_color_client.js'

initThemeColor();
```

### 五、主题切换下拉框组件

```vue
<template>
	<el-select v-model="mainColor" @change="changeColor">
		<el-option label="蓝色" value="#409EFF"></el-option>
		<el-option label="黑色" value="#000000"></el-option>
		<el-option label="白色" value="#ffffff"></el-option>
		<el-option label="绿色" value="#09900f"></el-option>
	</el-select>
</template>

<script>
    import { changeThemeColor, curColor } from '@/utils/theme_color_client.js'
    export default {
        data() {
            return {
                mainColor: curColor,
            };
        },
        methods: {
            changeColor(newColor) {
                changeThemeColor(newColor)
                    .then(t => console.log('主题色切换成功~'))
            }
        },
    }
</script>
```

### 按照自己工程的架构，颜色可以由scss变量统一管理common.css

```css
//默认主题
$default-them-color:#409EFF;//默认主题颜色
$default-text-color:#606266;//默认文字颜色
$default-theme-white-color:#ffffff;//默认主题白色
$default-page-bg-color:#f2f2f2;//默认页面背景颜色
$default-disabled-color:#c0c4cc;//禁用时的颜色
$default-upload-success-icon-color:#67c23a;//文件上传成功图标颜色
$default-menu-active-bg-color:#ecf5ff;//菜单激活选中时的背景颜色
$default-table-info-color:#ebeef5;//表格边框颜色
$default-table-header-color:#fafafa;//表格表头颜色
$default-message-info-color:#909399;//消息提示框文字颜色
$default-message-info-icon-color:#e6a23c;//消息提示框图标颜色
```

在main.js中配置可以进行全局引用

```js
//设置scss变量全局引用
const oneOfsMap = config.module.rule('scss').oneOfs.store;
oneOfsMap.forEach(item => {
	item.use('sass-resources-loader')
		.loader('sass-resources-loader')
		.options({
			resources: path.resolve(__dirname, 'src/assets/styles/common.scss'),
		})
		.end()
});
```


# 《模块化系列》彻底理清 AMD,CommonJS,CMD,UMD,ES6

本文你将学到:

1. Rollup 是什么
2. CommonJS、AMD、CMD、UMD、ES6 分别的介绍
3. ES6 模块与 CommonJS 模块的区别
4. 模块演进的产物 —— Tree Shaking
5. Tree Shaking 应该注意什么

本文所有例子都存放于 [https://github.com/hua1995116/packaging-example](https://link.zhihu.com/?target=https%3A//github.com/hua1995116/packaging-example)

## 引言

今天在使用 rollup 打包的时候遇到了一个问题

```bash
Error: 'Map' is not exported by node_modules/immutable/dist/immutable.js
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  global.Immutable = factory();
```

发现 `immutable` 是以 UMD 的形式暴露。查阅资料后发现 Rollup 并不支持 CommonJS 和 AMD 的打包方式，想要成功引入 commonJS 的模块，必须要加载插件 [https://github.com/rollup/plugins/tree/master/packages/commonjs](https://link.zhihu.com/?target=https%3A//github.com/rollup/plugins/tree/master/packages/commonjs)。 当然并不是对所有的 CommonJS 都自动支持，只针对类似于静态的写法才能导出，例如针动态模块导出，以及隐式地导出将无法自动导出，这样的场景下需要手动指定导出模块。以上的例子就是一个动态的方式，只有当 `factory` 函数执行了才能知道导出的模块，需要手动指定。

```js
commonjs({
  namedExports: {
    // left-hand side can be an absolute path, a path
    // relative to the current directory, or the name
    // of a module in node_modules
    'immutable': ['Map']
  }
});
```

当然上述只是我写这篇文章的一个起因，就是因为我对这一块的迷惑，所以使得我想重新复习一下这一块知识，上面将的可能你完全听不懂我在说什么，没有关系，下面开始切入正题。

## Rollup 是什么？

因为在最一开始，是我引入了这个概念，所以由我出来填坑，当然对这个工具非常熟悉的朋友可以跳过。不熟悉的朋友你只需要知道，这个是一个打包 ES Module 的工具。

> Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中，而不是以前的特殊解决方案，如 CommonJS 和 AMD。ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数，而你的项目不必携带其他未使用的代码。ES6 模块最终还是要由浏览器原生实现，但当前 Rollup 可以使你提前体验。

## CommonJS

[CommonJS规范](https://link.zhihu.com/?target=http%3A//wiki.commonjs.org/wiki/CommonJS)

`CommonJS` 主要运行于服务器端，该规范指出，一个单独的文件就是一个模块。 Node.js为主要实践者，它有四个重要的环境变量为模块化的实现提供支持：`module`、`exports`、`require`、`global`。`require` 命令用于输入其他模块提供的功能，`module.exports`命令用于规范模块的对外接口，输出的是一个值的拷贝，输出之后就不能改变了，会缓存起来。

```js
// 模块 a.js
const name = 'qiufeng'

module.exports = {
    name,
    github: 'https://github.com/hua1995116'
}
// 模块 b.js
// 引用核心模块或者第三方包模块，不需要写完整路径
const path = require('path');
// 引用自定义模块可以省略.js
const { name, github } = require('./a');

console.log(name, github, path.basename(github));
// 输出 qiufeng https://github.com/hua1995116 hua1995116
```

代码地址: [https://github.com/hua1995116/packaging-example/tree/master/modules-introduction/CommonJS](https://link.zhihu.com/?target=https%3A//github.com/hua1995116/packaging-example/tree/master/modules-introduction/CommonJS)

`CommonJS` 采用同步加载模块，而加载的文件资源大多数在本地服务器，所以执行速度或时间没问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。

## AMD

[AMD规范](https://link.zhihu.com/?target=https%3A//github.com/amdjs/amdjs-api/wiki/AMD)

AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。其中 RequireJS 是最佳实践者。

模块功能主要的几个命令：`define`、`require`、`return`和`define.amd`。`define`是全局函数，用来定义模块,`define(id?, dependencies?, factory)`。require命令用于输入其他模块提供的功能，return命令用于规范模块的对外接口，define.amd属性是一个对象，此属性的存在来表明函数遵循AMD规范。

```js
// model1.js
define(function () {
    console.log('model1 entry');
    return {
        getHello: function () {
            return 'model1';
        }
    };
});
// model2.js
define(function () {
    console.log('model2 entry');
    return {
        getHello: function () {
            return 'model2';
        }
    };
});
// main.js
define(function (require) {
    var model1 = require('./model1');
    console.log(model1.getHello());
    var model2 = require('./model2');
    console.log(model2.getHello());
});
<script src="https://cdn.bootcss.com/require.js/2.3.6/require.min.js"></script>
<script>
    requirejs(['main']);
</script>
// 输出结果  
// model1 entry
// model2 entry
// model1
// model2
```

代码地址: [https://github.com/hua1995116/packaging-example/tree/master/modules-introduction/AMD](https://link.zhihu.com/?target=https%3A//github.com/hua1995116/packaging-example/tree/master/modules-introduction/AMD)

在这里，我们使用define来定义模块，return来输出接口， require来加载模块，这是AMD官方推荐用法。

## CMD

[CMD规范](https://link.zhihu.com/?target=https%3A//github.com/cmdjs/specification/blob/master/draft/module.md)

CMD(Common Module Definition - 通用模块定义)规范主要是Sea.js推广中形成的，一个文件就是一个模块，可以像Node.js一般书写模块代码。主要在浏览器中运行，当然也可以在Node.js中运行。

它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。

不懂 `依赖就近、延迟执行` 的可以比较下面和上面的例子。

```js
// model1.js
define(function (require, exports, module) {
    console.log('model1 entry');
    exports.getHello = function () {
        return 'model1';
    }
});
// model2.js
define(function (require, exports, module) {
    console.log('model2 entry');
    exports.getHello = function () {
        return 'model2';
    }
});
// main.js
define(function(require, exports, module) {
    var model1 = require('./model1'); //在需要时申明
    console.log(model1.getHello());
    var model2 = require('./model2'); //在需要时申明
    console.log(model2.getHello());
});
<script src="https://cdn.bootcss.com/seajs/3.0.3/sea.js"></script>
<script>
    seajs.use('./main.js')
</script>
// 输出 
// model1 entry
// model1
// model2 entry
// model2
```

[https://github.com/hua1995116/packaging-example/tree/master/modules-introduction/CMD](https://link.zhihu.com/?target=https%3A//github.com/hua1995116/packaging-example/tree/master/modules-introduction/CMD)

总结: 对比和 AMD 的写法就可以看出 AMD 和 CMD 的区别。虽然现在 CMD 已经凉了。但是 CMD 更加接近于 CommonJS 的写法，但是 AMD 更加接近于浏览器的异步的执行方式。

## UMD

[UMD文档](https://link.zhihu.com/?target=https%3A//github.com/umdjs/umd)

UMD(Universal Module Definition - 通用模块定义)模式，该模式主要用来解决CommonJS模式和AMD模式代码不能通用的问题，并同时还支持老式的全局变量规范。

示例展示

```js
// bundle.js
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.myBundle = factory());
}(this, (function () { 'use strict';

    var main = () => {
        return 'hello world';
    };

    return main;

})));
// index.html
<script src="bundle.js"></script>
<script>
  console.log(myBundle());
</script>
```

1. 判断`define为`函数，并且是否存在`define.amd`，来判断是否为AMD规范,
2. 判断`module`是否为一个对象，并且是否存在`module.exports`来判断是否为`CommonJS`规范
3. 如果以上两种都没有，设定为原始的代码规范。

代码地址：[https://github.com/hua1995116/packaging-example/tree/master/modules-introduction/UMD](https://link.zhihu.com/?target=https%3A//github.com/hua1995116/packaging-example/tree/master/modules-introduction/UMD)

## ES Modules

[ES Modules 文档](https://link.zhihu.com/?target=http%3A//es6.ruanyifeng.com/%23docs/module-loader)

ES modules（ESM）是 JavaScript 官方的标准化模块系统。

1. 它因为是标准，所以未来很多浏览器会支持，可以很方便的在浏览器中使用。(浏览器默认加载不能省略.js)
2. 它同时兼容在node环境下运行。
3. 模块的导入导出，通过`import`和`export`来确定。 可以和Commonjs模块混合使用。
4. ES modules 输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝
5. ES modules 模块编译时执行，而 CommonJS 模块总是在运行时加载

使用方式

```js
// index.js
import { name, github } from './demo.js';

console.log(name(), github());

document.body.innerHTML = `<h1>${name()} ${github()}</h1>`
export function name() {
    return 'qiufeng';
}

export function github() {
    return 'https://github.com/hua1995116';
}
<script src="./index.js" type="module"></script>
```

代码地址: [https://github.com/hua1995116/packaging-example/tree/master/modules-introduction/ES-Modules](https://link.zhihu.com/?target=https%3A//github.com/hua1995116/packaging-example/tree/master/modules-introduction/ES-Modules)

详细可以查看 [深入理解 ES6 模块机制](https://link.zhihu.com/?target=https%3A//juejin.im/entry/5a879e28f265da4e82635152)

### CommonJS 的值拷贝

```js
// a.js
const b = require('./b');
console.log(b.age);
setTimeout(() => {
  console.log(b.age);
  console.log(require('./b').age);
}, 100);
// b.js
let age = 1;
setTimeout(() => {
  age = 18;
}, 10);
module.exports = {
  age
}
// 执行：node a.js
// 执行结果：
// 1
// 1
// 1
```

CommonJS 主要有执行主要有以下两个特点

1. CommonJS 模块中 require 引入模块的位置不同会对输出结果产生影响，并且会生成值的拷贝
2. CommonJS 模块重复引入的模块并不会重复执行，再次获取模块只会获得之前获取到的模块的缓存

### ES modules 的值的引用

```js
// a.js
import { age } from './b.js';

console.log(age);
setTimeout(() => {
    console.log(age);
    import('./b.js').then(({ age }) => {
        console.log(age);
    })
}, 100);

// b.js
export let age = 1;

setTimeout(() => {
    age = 2;
}, 10);
// 打开 index.html
// 执行结果：
// 1
// 2
// 2
```

### 动态加载和静态编译区别？

举个例子如下:

动态加载，只有当模块运行后，才能知道导出的模块是什么。

```js
var test = 'hello'
module.exports = {
  [test + '1']: 'world'
}
```

静态编译, 在编译阶段就能知道导出什么模块。

```js
export function hello() {return 'world'}
```

关于 ES6 模块编译时执行会导致有以下两个特点：

1. import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行。
2. export 命令会有变量声明提前的效果。

**import 优先执行:**

```js
// a.js
console.log('a.js')
import { age } from './b.js';

// b.js
export let age = 1;
console.log('b.js 先执行');

// 运行 index.html 执行结果:
// b.js 先执行
// a.js
```

虽然 import 顺序比较靠后，但是 由于 import 提升效果会优先执行。

**export 变量声明提升:**

```js
// a.js
import { foo } from './b.js';
console.log('a.js');
export const bar = 1;
export const bar2 = () => {
  console.log('bar2');
}
export function bar3() {
  console.log('bar3');
}

// b.js
export let foo = 1;
import * as a from './a.js';
console.log(a);

// 运行 node --experimental-modules a.js 执行结果:
// [Module] {
//  bar: <uninitialized>,
//  bar2: <uninitialized>,
//  bar3: [Function: bar3]
}
```

代码地址：[https://github.com/hua1995116/packaging-example/tree/master/modules-introduction/CommonJS-vs-ESModules](https://link.zhihu.com/?target=https%3A//github.com/hua1995116/packaging-example/tree/master/modules-introduction/CommonJS-vs-ESModules)

从上述例子中可以看出，a 模块引用了 b 模块，b 模块也引用了 a 模块，export 声明优先于其他内容。由于变量和函数的提升不一样，此处不做过多介绍。

**此处有一个小插曲**，我一开始用浏览器进行执行的结果为:

```bash
{
  bar: 1
  bar2: () => { console.log('bar2'); }
  bar3: ƒ bar3()
}
a.js
```

让我一度觉得是不是 export 有什么特殊的声明提升？因为我发现`深入理解 ES6 模块机制`一文中是使用的 `babel-node`, 是否是因为环境不一样导致的。因此我使用了 node `v12.16.0`,进行测试 `node --experimental-modules a.js`, 发现结果与 `深入理解 ES6 模块机制` 中结果一致，后来想到 `console.log` 的显示问题，`console.log` 常常会有一些异步的显示。后来我经过测试发现确实是 `console.log` 搞的鬼

```
console.log(a);` -> `console.log(JSON.stringify(a))
```

会出现一个 `Uncaught ReferenceError: bar is not defined` 的错误，是因为 `bar` 未初始化导致。后续也会将这个 `console` 的表现形式报告给 `chromium`。

## Tree shaking

介绍完了，各个模块的标准后，为什么又将这个 Tree shaking 呢？因为模块化的一次又一次地变更，让我们的模块系统变得越来越好，而 Tree shaking 就是得益 ES modules 的发展的产物。

这个概念是Rollup提出来的。Rollup推荐使用ES2015 Modules来编写模块代码，这样就可以使用Tree-shaking来对代码做静态分析消除无用的代码，可以查看Rollup网站上的REPL示例，代码打包前后之前的差异，就会清晰的明白Tree-shaking的作用。

1. 没有使用额外的模块系统，直接定位import来替换export的模块
2. 去掉了未被使用的代码

tree shaking 的实际例子

```js
// main.js
import * as utils from './utils';

const array = [1,2,3,1,2,3]

console.log(utils.arrayUnique(array));
```

代码地址：[https://github.com/hua1995116/packaging-example/tree/master/modules-introduction/Tree-Shaking](https://link.zhihu.com/?target=https%3A//github.com/hua1995116/packaging-example/tree/master/modules-introduction/Tree-Shaking)

`Tree shaking` 和 没有`Tree shaking` 打包对比。



![img](https://pic1.zhimg.com/80/v2-0ed4097bd945b6a20e1ad1fdf7cffa0c_720w.jpg)



没有 Tree-shaking 的情况下，会将 utils 中的所有文件都进行打包，使得体积暴增。

ES Modules 之所以能 Tree-shaking 主要为以下四个原因（摘自尤雨溪在知乎的回答）:

1. `import` 只能作为模块顶层的语句出现，不能出现在 function 里面或是 if 里面。
2. `import` 的模块名只能是字符串常量。
3. 不管 `import` 的语句出现的位置在哪里，在模块初始化的时候所有的 `import` 都必须已经导入完成。
4. `import binding` 是 `immutable` 的，类似 const。比如说你不能 import { a } from ‘./a’ 然后给 a 赋值个其他什么东西。

## tree shaking 应该注意什么

### 副作用

没错，就是副作用，那么什么是副作用呢，请看下面的例子。

```js
// effect.js
console.log(unused());
export function unused() {
    console.log(1);
}
// index.js
import {unused} from './effect';
console.log(42);
```

此例子中 `console.log(unused());` 就是副作用。在 `index.js` 中并不需要这一句 `console.log`。而 `rollup` 并不知道这个全局的函数去除是否安全。因此在打包地时候你可以显示地指定`treeshake.moduleSideEffects` 为 false，可以显示地告诉 `rollup` 外部依赖项没有其他副作用。

不指定的情况下的打包输出。 `npx rollup index.js --file bundle.js`

```js
console.log(unused());

function unused() {
    console.log(1);
}

console.log(42);
```

指定没有副作用下的打包输出。`npx rollup index.js --file bundle-no-effect.js --no-treeshake.moduleSideEffects`

```js
console.log(42);
```

代码地址： [https://github.com/hua1995116/packaging-example/tree/master/modules-introduction/Tree-Shaking-Effect](https://link.zhihu.com/?target=https%3A//github.com/hua1995116/packaging-example/tree/master/modules-introduction/Tree-Shaking-Effect)

当然以上只是副作用的一种，详情其他几种看查看 [https://rollupjs.org/guide/en/](https://link.zhihu.com/?target=https%3A//rollupjs.org/guide/en/)

## 结语

CommonJS 同步加载， AMD 异步加载， UMD = CommonJS + AMD , ES Module 是标准规范, 取代 UMD，是大势所趋。 Tree-shaking 牢记副作用。






# 什么是前端工程化？



![img](https://pic4.zhimg.com/80/v2-c4050cd0668ae0e487557ade3e338ca5_720w.jpg?source=1940ef5c)

![img](https://pic1.zhimg.com/50/v2-58400269d9247f458b55edfc17eb5b01_hd.jpg?source=1940ef5c)

![img](https://pic1.zhimg.com/80/v2-58400269d9247f458b55edfc17eb5b01_720w.jpg?source=1940ef5c

# 从输入URL到浏览器显示页面发生了什么

### 1、输入网址

当你开始输入网址比如www.cnblogs.com时游览器就可以在书签或者历史记录里面去搜索相关的网址推荐给你。

### 2、游览器查找域名的IP地址

① 请求发起后，游览器首先会解析这个域名，首先它会查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。

② 如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS(域名分布系统)服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。

③查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询

④根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程

⑤本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址

⑥最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

![img](https://images2017.cnblogs.com/blog/1171046/201712/1171046-20171226173034151-855747573.jpg)

### 3、建立TCP链接

在拿到域名对应的IP地址后，会以随机端口（1024~~65535）向WEB服务器程序80端口发起TCP的连接请求，这个连接请求进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接，对于客户端与服务器的TCP链接，必然要说的就是『三次握手』。

![img](https://img2018.cnblogs.com/blog/1171046/201904/1171046-20190409190539159-883745097.png)

三次握手

客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。

通俗化之后就是：

客户端：老弟我要跟你链接

服务端：好的，同意了

客户端：好嘞

### 4、游览器向WEB服务器发起Http请求

建立TCP连接之后，发起HTTP请求，请求一般分为三部分

请求方法URI协议/版本

请求头(Request Header)

请求正文

下面是一个完整的请求

![img](https://img-blog.csdn.net/20180519235118178?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsZXhzaGk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

详细的就不描述了，网上很多说明的。

###  5、服务器端处理

服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。

![img](https://img2018.cnblogs.com/blog/1171046/201904/1171046-20190409191054591-1163748805.png)

### 6、关闭TCP链接

为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。

![img](https://img2018.cnblogs.com/blog/1171046/201904/1171046-20190409191208891-688664454.png)

上图可以通俗化：

客户端：老弟，我这边没数据要传了，咱们关闭链接吧

服务端：好的，接收到了，我看看我这边还有没有要传的

服务端：我这边也没有了，关闭吧

客户端：好嘞

### 7、游览器解析资源

对于获取到的HTML、CSS、JS、图片等等资源。

浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。

在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题，关于JS阻塞相关问题，这里不过多阐述,后面会单独开篇讲解。

![img](https://user-gold-cdn.xitu.io/2018/2/22/161bb3c9b220f8cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

webkit渲染流程

### 8、游览器布局渲染

根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：repaint和reflow。

##### repaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。

##### reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。

有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。
有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。


前端其他方案



#### H5的离线缓存技术

HTML5的离线存储是**基于**一个新建的**.appcache文件的缓存机制(**不是存储技术)，通过这个文件上的解析清单离线存储资源；把需要离线存储在本地的文件列在一个manifest配置文件中

```html
<html lang="en" manifest="cache.manifest">
```

manifest文件可以保存为任意的扩展名，但**mime-type 必须是 text/cache-manifest**。



#### 骨架屏



page-skeleton-webpack-plugin  插件

Page Skeleton 是一款 webpack 插件，该插件的目的是根据你项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中。

https://github.com/ElemeFE/page-skeleton-webpack-plugin/blob/master/docs/i18n/zh_cn.md

# 四种常见的 POST 提交数据方式对应的content-type取值（enctype）

# Content-Type ：

仅POST方法的Content-Type值等于下列之一才算作简单请求：

- text/plain
- multipart/form-data
- application/x-www-form-urlencoded

### application/x-www-form-urlencoded

这应该是最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：

```
POST http://www.example.com HTTP/1.1 
Content-Type: application/x-www-form-urlencoded;charset=utf-8 
12
```

title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3
首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。
很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。

### multipart/form-data

这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值。直接来看一个请求示例：

```
POST http://www.example.com HTTP/1.1 
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA 

------WebKitFormBoundaryrGKCBY7qhFd3TrwA 
Content-Disposition: form-data; name="text" 

title 
------WebKitFormBoundaryrGKCBY7qhFd3TrwA 
Content-Disposition: form-data; name="file"; filename="chrome.png" 
Content-Type: image/png 

PNG ... content of chrome.png ... 
------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 
12345678910111213
```

这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 mutipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。关于 mutipart/form-data 的详细定义，请前往 rfc1867 查看。

这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。

上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段原生 form 表单也只支持这两种方式。但是随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。

### application/json

application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。

JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。

Google 的 AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码：

```js
    var data = {'title':'test', 'sub' : [1,2,3]}; 
    $http.post(url, data).success(function(result) { 
        ... 
    }); 
1234
```

最终发送的请求是：

```js
    POST http://www.example.com HTTP/1.1 
    Content-Type: application/json;charset=utf-8 
    
    {"title":"test","sub":[1,2,3]} 
1234
```

这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。一些 php 框架已经开始这么做了。

当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。如有需要，可以参考这篇文章。

### text/xml

我的博客之前提到过 XML-RPC（XML Remote Procedure Call）。它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的：

```
POST http://www.example.com HTTP/1.1 
Content-Type: text/xml 
12
    <!--?xml version="1.0"?--> 
    <methodcall> 
        <methodname>examples.getStateName</methodname> 
        <params> 
            <param> 
                <value><i4>41</i4></value> 
             
        </params> 
    </methodcall> 
123456789
```

XML-RPC 协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如 WordPress 的 XML-RPC Api，搜索引擎的 ping 服务等等。JavaScript 中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。不过，我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。

## HTML 标签的 enctype 属性

在下面的例子中，表单数据会在未编码的情况下进行发送：

```html
<form action="form_action.asp" enctype="text/plain">
  <p>First name: <input type="text" name="fname" /></p>
  <p>Last name: <input type="text" name="lname" /></p>
  <input type="submit" value="Submit" />
</form>
12345
```

定义和用法：

enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。

默认地，表单数据会编码为 “application/x-www-form-urlencoded”。就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为 ASCII HEX 值）。

| 值                                | 描述                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| application/x-www-form-urlencoded | 在发送前编码所有字符（默认）                                 |
| multipart/form-data               | 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 |
| text/plain                        | 空格转换为 “+” 加号，但不对特殊字符编码。                    |


在提交git的时候提示设置邮箱

设置方法是在项目所在目录右键选择 git  bash命令工具，输入：

**git config  user.name 你的目标用户名；**

**git config  user.email 你的目标邮箱名;**


# 如何用不到200行代码写一款属于自己的js类库

### 前言

JavaScript 的核心是支持面向对象的，同时它也提供了强大灵活的 OOP 语言能力。本文将使用面向对象的方式，来教大家用原生js写出一个类似jQuery这样的类库。我们将会学到如下知识点：

- 闭包：减少变量污染，缩短变量查找范围
- 自执行函数在对象中的运用
- extend的实现原理
- 如何实现跨浏览器的事件监听
- 原型链与继承

### 类库设计思路



![img](https://user-gold-cdn.xitu.io/2019/7/5/16bbde3dca4bfb96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### API介绍和效果展示

1. 事件绑定 Xuery.on(eventName, fn) 案例如下：

```js
Xuery('#demo').on('click', function(e){
    alert('hello world!')
})
复制代码
```

1. 访问和设置css Xuery.css(string|object, ?[string]) 案例如下：

```js
// 访问css
Xuery('#demo').css('width')
// 设置css
Xuery('#demo').css('width', '1024px')
// 设置css
Xuery('#demo').css({
    width: '1024px',
    height: '1024px'
})
复制代码
```

1. 访问和设置属性 Xuery.attr(string|object, ?[string]) 案例如下：

```js
// 访问attr
Xuery('#demo').attr('title')
// 设置attr
Xuery('#demo').attr('title', '1024px')
// 设置attrs
Xuery('#demo').attr({
    title: '1024px',
    name: '1024px'
})
复制代码
```

1. 访问和设置html 案例如下：

```js
// 访问
Xuery('#demo').html()
// 设置
Xuery('#demo').html('前端学习原生框架')
复制代码
```

还有其他几个常用的API在这里就不介绍了，大家可以在我的github上查看，或者基于这套基础框架，去扩展属于自己的js框架。

### 核心源码

以下源码相关功能我做了注释，建议大家认真阅读，涉及到原型链和构造函数的指向的问题，是实现上述调用方式的核心，又不懂可以在评论区交流沟通。

```js
/**
 * 链模式实现自己的js类库
 */
(function(win, doc){
    var Xuery = function(selector, context) {
        return new Xuery.fn.init(selector, context)
    };

    Xuery.fn = Xuery.prototype = {
    constructor: Xuery,
    init: function(selector, context) {
        // 设置元素长度
        this.length = 0;
        // 默认获取元素的上下文document
        context = context || document;
        // id选择符，则按位非将-1转化为0
        if(~selector.indexOf('#')) {
        this[0] = document.getElementById(selector.slice(1));
        this.length = 1;
        }else{
        // 在上下文中选择元素
        var doms = context.getElementsByTagName(selector),
        i = 0,
        len = doms.length;
        for(; i<len; i++){
            this[i] = doms[i];
        }
        }
        this.context = context;
        this.selector = selector;
        return this
    },
    // 增强数组
    push: [].push,
    sort: [].sort,
    splice: [].splice
    };

    // 方法扩展
    Xuery.extend = Xuery.fn.extend = function(){
    // 扩展对象从第二个参数算起
    var i = 1,
    len = arguments.length,
    target = arguments[0],
    j;
    if(i === len){
        target = this;
        i--;
    }
    // 将参数对象合并到target
    for(; i<len; i++){
        for(j in arguments[i]){
        target[j] = arguments[i][j];
        }
    }
    return target
    }

    // 扩展事件方法
    Xuery.fn.extend({
    on: (function(){
        if(document.addEventListener){
        return function(type, fn){
            var i = this.length -1;
            for(; i>=0;i--){
            this[i].addEventListener(type, fn, false)
            }
            return this
        }
        // ie浏览器dom2级事件
        }else if(document.attachEvent){
        return function(type, fn){
            var i = this.length -1;
            for(; i>=0;i--){
            this[i].addEvent('on'+type, fn)
            }
            return this
        }
        // 不支持dom2的浏览器
        }else{
        return function(type, fn){
            var i = this.length -1;
            for(; i>=0;i--){
            this[i]['on'+type] = fn;
            }
            return this
        }
        }
    })()
    })

    // 将‘-’分割线转换为驼峰式
    Xuery.extend({
    camelCase: function(str){
        return str.replace(/\-(\w)/g, function(all, letter){
        return letter.toUpperCase();
        })
    }
    })

    // 设置css
    Xuery.fn.extend({
    css: function(){
        var arg = arguments,
        len = arg.length;
        if(this.length < 1){
        return this
        }
        if(len === 1) {
        if(typeof arg[0] === 'string') {
            if(this[0].currentStyle){
            return this[0].currentStyle[arg[0]];
            }else{
            return getComputedStyle(this[0], false)[arg[0]]
            }
        }else if(typeof arg[0] === 'object'){
            for(var i in arg[0]){
            for(var j=this.length -1; j>=0; j--){
                this[j].style[Xuery.camelCase(i)] = arg[0][i];
            }
            }
        }
        }else if(len === 2){
        for(var j=this.length -1; j>=0; j--){
            this[j].style[Xuery.camelCase(arg[0])] = arg[1];
        }
        }
        return this
    }
    })

    // 设置属性
    Xuery.fn.extend({
    attr: function(){
        var arg = arguments,
        len = arg.length;
        if(len <1){
        return this
        }
        if(len === 1){
        if(typeof arg[0] === 'string'){
            return this[0].getAttribute(arg[0])
        }else if(typeof arg[0] === 'object'){
            for(var i in arg[0]){
            for(var j=this.length -1; j>= 0; j--){
                this[j].setAttribute(i, arg[0][i])
            }
            }
        }
        }
        else if(len === 2){
        for(var j=this.length -1; j>=0; j--){
            this[j].setAttribute(arg[0], arg[1]);
        }
        }
        return this
    }
    })

    // 获取或者设置元素内容
    Xuery.fn.extend({
    html: function(){
        var arg = arguments,
        len = arg.length;
        if(len === 0){
        return this[0] && this[0].innerHTML
        }else{
        for(var i=this.length -1; i>=0; i--){
            this[i].innerHTML = arg[0];
        }
        }
        return this
    }
    })

    Xuery.fn.init.prototype = Xuery.fn;
    window.Xuery = Xuery;
})(window, document);
        
```


**Constructor**：构造函数，节点下的对象都是由构造函数创建而来。

**Distance**：与根节点的距离。

**Objects Count**：对象个数及百分占比。

**Shallow size**：对象的直接内存总数，直接内存是指对象自身占用的内存大小。

**Retained size**：对象的最大保留内存，保留内存是指对象被删除后可以释放的那部分内存。

下面解释一下部分类名称所代表的意思：[·](http://caibaojian.com/chrome-profiles.html)

- (compiled code) — 未知，估计是程序代码区
- (closure) — 闭包(array) — 未知
- Object — JS对象类型(system) — 未知
- (string) — 字符串类型，有时对象里添加了新属性，属性的名称也会出现在这里
- Array — JS数组类型cls — 游戏大厅特有的继承类
- Window — JS的window对象
- Quark.DisplayObjectContainer — Quark引擎的显示容器类
- Quark.ImageContainer — Quark引擎的图片类
- Quark.Text — Quark引擎的文本类
- Quark.ToggleButton — Quark引擎的开关按钮类



**Heap Snapshot**可以查看堆快照，进而发现内存泄露问题。

Summary 总览视图：按构造函数分组。用于捕捉对象及其使用的内存。对于定位DOM内存泄露特别有用。

Comparison 对比视图：对比两个快照。用于对比不同操作之后的堆快照，查看内存的释放及引用计数，来分析内存是否泄露及其原因。

Containment 内容视图：查看堆内容。更适合查看对象结构，有助于分析对象的引用情况。适用于分析闭包以及深入分析对象。

Statistics 统计视图：总览堆的统计信息。

**Heap Allocations**可以持续的记录堆分配的情况，显示了对象在什么时候被创建、什么时候存在内存泄漏等。

我们可以重复执行某个动作，如果最后有不少蓝色柱被保留，这些蓝色柱就是潜在的内存泄露问题。



总结出以下几种常见的情况：[·](http://caibaojian.com/chrome-profiles.html)

1. 闭包上下文绑定后没有释放；
2. 观察者模式在添加通知后，没有及时清理掉；
3. 定时器的处理函数没有及时释放，没有调用clearInterval方法；
4. 视图层有些控件重复添加，没有移除；
5. DOM删除时没有解绑事；
6. 全局变量使用完毕没有置为null；
7. 事件总线上绑定事件没有解绑；



参考：[JS内存泄漏排查方法-Chrome Profiles](http://caibaojian.com/chrome-profiles.html)

​           [中高级前端必须了解的JS中的内存管理](https://www.cnblogs.com/chenqf/p/11114879.html)

​           [一个Vue页面的内存泄露分析](https://blog.csdn.net/weixin_38098195/article/details/81135137)


# 百分比计算精度问题解决方案

```js
/**
     * @param { Array<Number> } arr 一组数据
     * @param { Boolean } needSign 返回值是否添加%
     * @param { Number } decimalCount 精度：最多保留多少位小数
     * @returns { Array<Number|String> }
     */
    function calcPercentage(arr, needSign, decimalCount){
        var sum = arr.reduce(function(a,b){
                return a + b;
            } , 0),
            D = decimalCount < 2 ? 2 : decimalCount,
            // E1, E2将小数转化成整数，解决因精度导致小数计算错误的问题
            E1 = Math.pow(10, D),
            E2 = Math.pow(10, D + 2);
        if(sum === 0) {
            return arr.map(function(){
                return needSign ? '0%' : 0
            });
        }
        var perArr = arr.map(function(e, i){
            return {
                index: i,
                percentage: Math.round((e / sum).toFixed(D) * E1)
            }
        });
        var all = perArr.reduce(function(a, b){
            return a + b.percentage;
        } , 0);
        // 比较计算出的百分比总和和实际总和
        if(all > E1) {
            // 根据误差大小排序
            perArr.sort(function(a, b) {
                var aCur = a.percentage * Math.pow(10, 2),
                    aReal = Number((arr[a.index] / sum).toFixed(D + 2)) * E2,
                    bCur = b.percentage * Math.pow(10, 2),
                    bReal = Number((arr[b.index] / sum).toFixed(D + 2)) * E2,
                    aError = aCur - aReal,
                    bError = bCur - bReal;
                return  bError - aError < 0 ? -1 : bError - aError > 0 ? 1 : a.index - b.index; // 根据误差排序，如果误差一样，索引小的在前面
            });
            var sumError = all - E1, i = 0;
            // 百分比总和多的部分，从误差大的百分比依次扣除
            while(sumError) {
                perArr[i].percentage = perArr[i].percentage - 1;
                sumError--;
                i++;
            }
        }
        if(all < E1) {
            // 根据误差大小排序
            perArr.sort(function(a, b) {
                var aCur = a.percentage * Math.pow(10, 2),
                    aReal = Number((arr[a.index] / sum).toFixed(decimalCount + 2)) * E2,
                    bCur = b.percentage * Math.pow(10, 2),
                    bReal = Number((arr[b.index] / sum).toFixed(decimalCount + 2)) * E2,
                    aError = aCur - aReal,
                    bError = bCur - bReal;
                return  aError - bError < 0 ? -1 : aError - bError > 0 ? 1 : a.index - b.index;
            });
            var sumError = all - E1, i = 0;
            // 百分比总和少的部分，从误差大的百分比依次补上
            while(sumError) {
                perArr[i].percentage = perArr[i].percentage + 1;
                sumError++;
                i++;
            }
        }
        return perArr.sort(function(a, b){
            return a.index - b.index;
        }).map(function(e){
            return needSign ? (e.percentage / Math.pow(10, D - 2)).toFixed(D - 2) + '%' : e.percentage/E1;
        });
    };
```


**目标：**实现Vue实现换主题/皮肤功能

**需求：**网站换肤，主题切换。网站的主题色可以在几种常用颜色之间进行切换，还有相关图片、图标也要跟随主题进行切换。

**步骤：**通过百度查询相关的实现方式，有相关的github的项目源码最好，查询到的博客：http://www.fly63.com/article/detial/4974，在现有的demo工程中验证是否可以。

**实现方式：**根据博客文档中的方式：

1、在 static 目录下新建一个 styles 文件夹，在 styles 下新建一个 theme.css文件，将需要替换的 CSS 声明在此文件中。

```css
.theme-test-btn {
    background-color: #409eff;
    border-color: #409eff;


.theme-test-btn:hover,
.theme-test-btn:focus {
    background-color: #66b1ff;
    border-color: #66b1ff;
}
```

2、在 src/assets/js/const/ 目录下新建 theme-colors.js，用于声明所有可选的主题。

```css
const colors = [
    {
        themeId: 0,
        primaryBtn: '#409eff', // 主要按钮的背景色
        priBtnHover: '#66b1ff', // 主要按钮的悬浮、聚焦背景色
    },
    {
        themeId: 1,
        primaryBtn: '#67c23a',
        priBtnHover: '#85ce61',
    },
    {
        themeId: 2,
        primaryBtn: '#e6a23c',
        priBtnHover: '#ebb563',
    },
];

export default colors;
```

3、在vue文件中创建基于element的下拉框和一个验证用的按钮

```html
<el-select v-model="active" placeholder="请选择" @change="changeTheme">
	<el-option v-for="item in colors" :key="item.themeId" :label="item.primaryBtn" :value="item.themeId">
	</el-option>
</el-select>
<button class="theme-test-btn">测试按钮背景颜色</button>
```

4、通过 axios 获取 theme.css ，将颜色值替换为关键词。

```js
data() {
    return {
        active: 0,
        themeStyleStr: '', // 存放 替换成关键词的 theme.css 内容
        colors: themeColors, // 所有可选的主题颜色数组。即：theme-colors.js 文件export的数组
    };
},
mounted() {
    // 通过 axios 获取 theme.css 的内容，并将颜色值替换为关键词
    axios({
		method: 'get',
		url: location.origin + '/static/style/theme.css'
	})
	.then((response) => {
		this.themeStyleStr = this.getStyleTemplate(response.data);
	})
	.catch((error) => {
		console.log(error);
	});
},
methods: {
    // 获取样式模板：将颜色值替换为关键词。
    getStyleTemplate(data) {
        let color = this.colors[0];
        delete color.themeId;
        let colorMap = {};
        Object.keys(color).forEach(key => {
            colorMap[color[key]] = key;
        });
        Object.keys(colorMap).forEach(key => {
            data = data.replace(new RegExp(key, 'ig'), colorMap[key]);
        });
        return data;
    },
}
```

5、选择下拉框关键词后，把关键词再换回刚刚生成的相应的颜色值，并在页面上添加 style 标签

```js
// 点击切换主题
changeTheme(event, item) {
    this.setNewStyle(this.themeStyleStr, this.colors[this.active]);
},
// 根据选择的主题颜色，把关键词换成相应的主题颜色，并在页面上添加 style 标签
setNewStyle(originalStyle, colors) {
    let oldEl = document.getElementById('theme-style');
    let cssText = originalStyle;
    Object.keys(colors).forEach(key => {
        cssText = cssText.replace(new RegExp(key, 'ig'), colors[key]);
    });
    const style = document.createElement('style');
    style.innerHTML = cssText;
    style.id = 'theme-style';
    oldEl ? document.head.replaceChild(style, oldEl) : document.head.appendChild(style);
}
6、全局引入：https://www.cnblogs.com/fayin/p/10363924.html
```

**结论：**这种方式可以实现主题切换



主题切换方案：

1、common.scss中公共变量根据不同主题定义多套，不同主题使用不同的变量

2、定义多个主题scss文件

​      1）写在组件和页面内部的样式要提出来，创建不同主题的样式文件，分目录创建。

​      2）根据不同的主题定义不同的scss，公共页面或者组件，同时引入多个不同主题样式文件。

​      3)   涉及主题切换的样式，写在scss文件中，不涉及的样式，写在默认样式文件中即可，切换时不会被覆盖。

3、切换主题时在html中加入标识

​      theme的值要提前定义好，在样式文件中提前定义主题样式

​       公共样式和组件内的样式在最外层都加上下面的代码，代表主题样式的区分。theme2是主题标识

```css
  html[data-theme="theme2"]  body{
    
  }
```

4、切换主题后带标识的样式会覆盖掉默认样式



#### `webpack`插件：`webpack-theme-color-replacer`

第二步，配置`webpack`

```js
const WebpackThemeColorReplacer = require('webpack-theme-color-replacer')

new WebpackThemeColorReplacer({
    fileName: 'css/theme-colors-[contenthash:8].css',
    // 根据匹配的css样式生成单独的css文件
    matchColors: [
         ...forElementUI.getElementUISeries('#FF0000'),
        // 根据主题色生成一系列颜色（10个），适用于ElementUI、Ani Design、Iview等组件
        '#FF0000'
        // 自定义的主题色
    ],
    // 需要匹配的网站主题色
    resolveCss(resultCss) {
        return resultCss.replace(/#4b0/g, '#ed4040')
    },
    // 将匹配的颜色值替换
    externalCssFiles: [],
    // 外部css文件，比如引用了第三方的css文件
    changeSelector(cssSelector) { 
        return cssSelector
    },
    isJsUgly: process.env.NODE_ENV !== 'development'
    // 压缩生成的css文件
})
```

第三步，项目加入切换代码

```js
import replacer from 'webpack-theme-color-replacer/client'
// 引入插件方法

function changeColor(newColor) {
  var options = {
    newColors: [...forElementUI.getElementUISeries(newColor), newColor],
    // 传入的新的主题色
    changeUrl(cssUrl) {
      return `/${cssUrl}`
    }
    // 如果需要加载自定义的css文件
    // 这种方式就像加载外部link一样
  }
 
  replacer.changer.changeColor(options, Promise).then(() => {
      console.log('Theme colors changed!')
  })
  // 执行切换主题方法，返回promise
}
changeColor('#FF3333')
// 用户切换主题色时触发切换方法
```


# 谈谈你对面向对象编程的理解

类就是拥有相等功能和相同的属性的对象的集合 -- 抽象的
对象就是类的实例 -- 具体

三大特征:封装、继承、多态

封装使得类的成员得以有选择性的暴露，一些成员只在类型的内部使用，被称之为私有的（private），一些成员可以被派生类型使用，称之为受保护的（protected），一些成员可以被任何东西使用，称之为公开的（public）。而某些语言还提供了内部的（internal）这样的访问修饰符来标识一些只能被同一个程序集或者包使用的成员。

继承可以从一个现有类型派生出新的类型来，派生类继承了基类的所有成员，也可以新增只属于自己的成员。在任何情况下，派生类类型的实例可以被当做基类类型的实例来使用。

多态是类和接口的关系

# **页面性能优化**

1. 减少http请求次数
2. JS，CSS源码压缩
3. 适当使用缓存数据
4. 图片预加载
5. 减少页面**回流与重绘**

浏览器把获取到的html代码解析成1个Dom树，浏览器解析所有样式，render tree构建

当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为**回流**

当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的

回流必将引起重绘，而重绘不一定会引起回流

- 添加、删除元素(回流+重绘)
- 隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流)
- 移动元素，比如改变top,left(jquery的animate方法就是,改变top,left不一定会影响回流)，或者移动元素到另外1个父元素中。(重绘+回流)
- 对style的操作(对不同的属性操作，影响不一样)
- 还有一种是用户的操作，比如改变浏览器大小，改变浏览器的字体大小等(回流+重绘)
- 操作更换classname



6. 避免重复的CSS，JavaScript代码，多余的HTML标签和属性

7. 启用GZIP压缩减少在[网络](http://www.lwlm.com/wangluojishulunwen/)传输过程中的数据量

8. 使用cdn

