# JavaScript数组去重的12种方法

数组去重，一般都是在面试的时候才会碰到，一般是要求手写数组去重方法的代码。如果是被提问到，数组去重的方法有哪些？你能答出其中的10种，面试官很有可能对你刮目相看。

在真实的项目中碰到的数组去重，一般都是后台去处理，很少让前端处理数组去重。虽然日常项目用到的概率比较低，但还是需要了解一下，以防面试的时候可能回被问到。

注：写的匆忙，加上这几天有点忙，还没有非常认真核对过，不过思路是没有问题，可能一些小细节出错而已。

**数组去重的方法**

**一、利用ES6 Set去重（ES6中最常用）**

> function unique (arr) {
> return Array.from(new Set(arr))
> }
> var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
> console.log(unique(arr))
> //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]
> 不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。



**二、利用for嵌套for，然后splice去重（ES5中最常用）**

> function unique(arr){
> for(var i=0; i<arr.length; i++){
> for(var j=i+1; j<arr.length; j++){
> if(arr[i]==arr[j]){ //第一个等同于第二个，splice方法删除第二个
> arr.splice(j,1);
> j--;
> }
> }
> }
> return arr;
> }
> var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
> console.log(unique(arr))
> //[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", {…}, {…}] //NaN和{}没有去重，两个null直接消失了
> 双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。
> 想快速学习更多常用的ES6语法，可以看我之前的文章《学习ES6笔记──工作中常用到的ES6语法》。



**三、利用indexOf去重**

> function unique(arr) {
> if (!Array.isArray(arr)) {
> console.log('type error!')
> return
> }
> var array = [];
> for (var i = 0; i < arr.length; i++) {
> if (array .indexOf(arr[i]) === -1) {
> array .push(arr[i])
> }
> }
> return array;
> }
> var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
> console.log(unique(arr))
> // [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", {…}, {…}] //NaN、{}没有去重
> 新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。



**四、利用sort()**

> function unique(arr) {
> if (!Array.isArray(arr)) {
> console.log('type error!')
> return;
> }
> arr = arr.sort()
> var arrry= [arr[0]];
> for (var i = 1; i < arr.length; i++) {
> if (arr[i] !== arr[i-1]) {
> arrry.push(arr[i]);
> }
> }
> return arrry;
> }
> var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
> console.log(unique(arr))
> // [0, 1, 15, "NaN", NaN, NaN, {…}, {…}, "a", false, null, true, "true", undefined] //NaN、{}没有去重
> 利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。



**五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）**

> function unique(arr) {
> if (!Array.isArray(arr)) {
> console.log('type error!')
> return
> }
> var arrry= [];
> var obj = {};
> for (var i = 0; i < arr.length; i++) {
> if (!obj[arr[i]]) {
> arrry.push(arr[i])
> obj[arr[i]] = 1
> } else {
> obj[arr[i]]++
> }
> }
> return arrry;
> }
> var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
> console.log(unique(arr))
> //[1, "true", 15, false, undefined, null, NaN, 0, "a", {…}] //两个true直接去掉了，NaN和{}去重



**六、利用includes**



> function unique(arr) {
> if (!Array.isArray(arr)) {
> console.log('type error!')
> return
> }
> var array =[];
> for(var i = 0; i < arr.length; i++) {
> if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
> array.push(arr[i]);
> }
> }
> return array
> }
> var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
> console.log(unique(arr))
> //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}] //{}没有去重



**七、利用hasOwnProperty**

> function unique(arr) {
> var obj = {};
> return arr.filter(function(item, index, arr){
> return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)
> })
> }
> var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
> console.log(unique(arr))
> //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}] //所有的都去重了
> 利用hasOwnProperty 判断是否存在对象属性

**八、利用filter**



> function unique(arr) {
> return arr.filter(function(item, index, arr) {
> //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
> return arr.indexOf(item, 0) === index;
> });
> }
> var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
> console.log(unique(arr))
> //[1, "true", true, 15, false, undefined, null, "NaN", 0, "a", {…}, {…}]

**九、利用递归去重**

> function unique(arr) {
> var array= arr;
> var len = array.length;
>
> array.sort(function(a,b){ //排序后更加方便去重
> return a - b;
> })
>
> function loop(index){
> if(index >= 1){
> if(array[index] === array[index-1]){
> array.splice(index,1);
> }
> loop(index - 1); //递归loop，然后数组去重
> }
> }
> loop(len-1);
> return array;
> }
> var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
> console.log(unique(arr))
> //[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]



**十、利用Map数据结构去重**

> function arrayNonRepeatfy(arr) {
> let map = new Map();
> let array = new Array(); // 数组用于返回结果
> for (let i = 0; i < arr.length; i++) {
> if(map .has(arr[i])) { // 如果有该key值
> map .set(arr[i], true);
> } else {
> map .set(arr[i], false); // 如果没有该key值
> array .push(arr[i]);
> }
> }
> return array ;
> }
> var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
> console.log(unique(arr))
> //[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]
> 创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。



**十一、利用reduce+includes**



> function unique(arr){
> return arr.reduce((prev,cur) => prev.includes(cur) ? prev : [...prev,cur],[]);
> }
> var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
> console.log(unique(arr));
> // [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]



**十二、[…new Set(arr)]**



> [...new Set(arr)]
> //代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）


# 十大经典排序算法

### **0.1 算法分类**

十种常见排序算法可以分为两大类：

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。



![img](https://pic2.zhimg.com/80/v2-eaabd72624137268328780e1199850f1_720w.jpg)



### **0.2 算法复杂度**



![img](https://pic4.zhimg.com/80/v2-f4b442b09f0983d1821fec88c00f4f4b_720w.jpg)



**0.3 相关概念**

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- **时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- **空间复杂度：**是指算法在计算机

内执行时所需存储空间的度量，它也是数据规模n的函数。

### **1、冒泡排序（Bubble Sort）**

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

### **1.1 算法描述**

- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
- 针对所有的元素重复以上的步骤，除了最后一个；
- 重复步骤1~3，直到排序完成。

**1.2 动图演示**



![img](https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp)



### **1.3 代码实现**

```js
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i < len - 1; i++) {
        for (var j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
```

### **2、选择排序（Selection Sort）**

选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

### **2.1 算法描述**

n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：

- 初始状态：无序区为R[1..n]，有序区为空；
- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
- n-1趟结束，数组有序化了。

### **2.2 动图演示**

![img](https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp)

### **2.3 代码实现**

```js
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
} 
```

### **2.4 算法分析**

表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。

### **3、插入排序（Insertion Sort）**

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

### **3.1 算法描述**

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤2~5。

### **3.2 动图演示**

![img](https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp)



### **3.2 代码实现**

```text
function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while (preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex + 1] = current;
    }
    return arr;
}
```

### **3.4 算法分析**

插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

### **4、希尔排序（Shell Sort）**

1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫**缩小增量排序**。

### **4.1 算法描述**

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

- 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
- 按增量序列个数k，对序列进行k 趟排序；
- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### **4.2 动图演示**



<video src="https://vdn1.vzuu.com/SD/6613c382-2362-11eb-a750-d6c52a23d5aa.mp4?disable_local_cache=1&bu=pico&expiration=1610618107&auth_key=1610618107-0-0-ad0146b57d43380712420e61c1e63047&f=mp4&v=hw" controls="controls" width="500" height="300">您的浏览器不支持播放该视频！</video>

### **4.3 代码实现**

```js
function shellSort(arr) {
    var len = arr.length;
    for (var gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {
        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行
        for (var i = gap; i < len; i++) {
            var j = i;
            var current = arr[i];
            while (j - gap >= 0 && current < arr[j - gap]) {
                 arr[j] = arr[j - gap];
                 j = j - gap;
            }
            arr[j] = current;
        }
    }
    return arr;
}
```

### **4.4 算法分析**

希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。

### **5、归并排序（Merge Sort）**

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

### **5.1 算法描述**

- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。

### **5.2 动图演示**

![img](https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.webp)

### **5.3 代码实现**

```js
function mergeSort(arr) {
    var len = arr.length;
    if (len < 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
 
function merge(left, right) {
    var result = [];
 
    while (left.length>0 && right.length>0) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
 
    while (left.length)
        result.push(left.shift());
 
    while (right.length)
        result.push(right.shift());
 
    return result;
}
```

### **5.4 算法分析**

归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。

### **6、快速排序（Quick Sort）**

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

### **6.1 算法描述**

快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

- 从数列中挑出一个元素，称为 “基准”（pivot）；
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

### **6.2 动图演示**



![img](https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.webp)



### **6.3 代码实现**

```js
function quickSort(arr, left, right) {
    var len = arr.length,
        partitionIndex,
        left = typeof left != 'number' ? 0 : left,
        right = typeof right != 'number' ? len - 1 : right;
 
    if (left < right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    }
    return arr;
}
 
function partition(arr, left ,right) {     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i <= right; i++) {
        if (arr[i] < arr[pivot]) {
            swap(arr, i, index);
            index++;
        }       
    }
    swap(arr, pivot, index - 1);
    return index-1;
}
 
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

### **7、堆排序（Heap Sort）**

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

### **7.1 算法描述**

- 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
- 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
- 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

### **7.2 动图演示**



<video src="https://vdn1.vzuu.com/SD/3bb38dfe-236a-11eb-8039-a6caf32b14c9.mp4?disable_local_cache=1&bu=pico&expiration=1610618410&auth_key=1610618410-0-0-d088510d2b9de33988ff6f01e902aa6b&f=mp4&v=hw" controls="controls" width="500" height="300">您的浏览器不支持播放该视频！</video>



### **7.3 代码实现**

```js
var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量
 
function buildMaxHeap(arr) {   // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i >= 0; i--) {
        heapify(arr, i);
    }
}
 
function heapify(arr, i) {     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;
 
    if (left < len && arr[left] > arr[largest]) {
        largest = left;
    }
 
    if (right < len && arr[right] > arr[largest]) {
        largest = right;
    }
 
    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest);
    }
}
 
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
 
function heapSort(arr) {
    buildMaxHeap(arr);
 
    for (var i = arr.length - 1; i > 0; i--) {
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    }
    return arr;
}
```

### **8、计数排序（Counting Sort）**

计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

### **8.1 算法描述**

- 找出待排序的数组中最大和最小的元素；
- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
- 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

### **8.2 动图演示**

![img](https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_b.webp)



### **8.3 代码实现**

```js
function countingSort(arr, maxValue) {
    var bucket = new Array(maxValue + 1),
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;
 
    for (var i = 0; i < arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }
 
    for (var j = 0; j < bucketLen; j++) {
        while(bucket[j] > 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }
 
    return arr;
}
```

### **8.4 算法分析**

计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。

### **9、桶排序（Bucket Sort）**

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。

### **9.1 算法描述**

- 设置一个定量的数组当作空桶；
- 遍历输入数据，并且把数据一个一个放到对应的桶里去；
- 对每个不是空的桶进行排序；
- 从不是空的桶里把排好序的数据拼接起来。

### **9.2 图片演示**



![](https://pic4.zhimg.com/80/v2-6ca3d43771f871abdbeef439ae24a05b_720w.jpg)



### **9.3 代码实现**

```js
function bucketSort(arr, bucketSize) {
    if (arr.length === 0) {
      return arr;
    }
 
    var i;
    var minValue = arr[0];
    var maxValue = arr[0];
    for (i = 1; i < arr.length; i++) {
      if (arr[i] < minValue) {
          minValue = arr[i];                // 输入数据的最小值
      } else if (arr[i] > maxValue) {
          maxValue = arr[i];                // 输入数据的最大值
      }
    }
 
    // 桶的初始化
    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  
    var buckets = new Array(bucketCount);
    for (i = 0; i < buckets.length; i++) {
        buckets[i] = [];
    }
 
    // 利用映射函数将数据分配到各个桶中
    for (i = 0; i < arr.length; i++) {
        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
    }
 
    arr.length = 0;
    for (i = 0; i < buckets.length; i++) {
        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
        for (var j = 0; j < buckets[i].length; j++) {
            arr.push(buckets[i][j]);                     
        }
    }
 
    return arr;
}
```

### **9.4 算法分析**

桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。

### **10、基数排序（Radix Sort）**

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。

### **10.1 算法描述**

- 取得数组中的最大数，并取得位数；
- arr为原始数组，从最低位开始取每个位组成radix数组；
- 对radix进行计数排序（利用计数排序适用于小范围数的特点）；

### **10.2 动图演示**

![img](https://pic3.zhimg.com/v2-3a6f1e5059386523ed941f0d6c3a136e_b.webp)

### **10.3 代码实现**

```js
var counter = [];
function radixSort(arr, maxDigit) {
    var mod = 10;
    var dev = 1;
    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
        for(var j = 0; j < arr.length; j++) {
            var bucket = parseInt((arr[j] % mod) / dev);
            if(counter[bucket]==null) {
                counter[bucket] = [];
            }
            counter[bucket].push(arr[j]);
        }
        var pos = 0;
        for(var j = 0; j < counter.length; j++) {
            var value = null;
            if(counter[j]!=null) {
                while ((value = counter[j].shift()) != null) {
                      arr[pos++] = value;
                }
          }
        }
    }
    return arr;
}
```

### **10.4 算法分析**

基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。

基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n>>k，因此额外空间需要大概n个左右。


# 实现把多维数组转为一维数组的几种方式

```js
/** 
* 使用转字符串法
*/
let tempArr = [1,[2,3],[4,5,[6,7]]];
let result_str1 = tempArr.join(',').split(',');
console.log(result_str1); //  ["1", "2", "3", "4", "5", "6", "7"]
```

```js
//使用数组的concat方法，以及apply 
let tempArr4 = [[1,2],'3','4',[5,6],[7]];
console.log([].concat.apply([],tempArr4)); // [1, 2, "3", "4", 5, 6, 7]
```

# 斐波那契数列

斐波那契数列就是形如0,1,1,2,3,5,8.....的数列。

```js
let getFibonacci = n =>{
    let arr = [];
    for(let i = 0;i<n - 1;i++){
        if(i < 1){
           arr.push(i);
        }else{
           arr.push(arr[i-1] + arr[i-2]);
        }
    }
    return arr;
}
```


# **正则表达式常见面试题**

- 1.给一个连字符串例如：get-element-by-id转化成驼峰形式。

  ```js
  var str = "get-element-by-id";
  var reg = /-(\w)/g;
  console.log(str.match(reg));//["-e", "-b", "-i"]
  console.log(str.replace(reg,function(p){
  	return p[1].toUpperCase()//返回下标为1的字母的大写字母
  }));
  ```

- 2.匹配二进制数字

  ```js
  var a = "010000101";
  var p = /\d+/;
  console.log(p.test(a));//true
  ```

- 3.非零的十进制数字 (有至少一位数字, 但是不能以0开头)

  ```js
  var a = "666";
  var p = /^[1-9][0-9]+$/;
  console.log(p.test(a));//true
  ```

- 4.匹配一年中的12个月

  ```js
  var str = "12";
  var reg = /^(0?[1-9]|1[0-2])$/g;
  console.log(reg.test(str));
  ```

- 5.匹配qq号最长为13为

  ```js
  var str ="10009093283333";
  var reg = /^[1-9][0-9]{4,12}$/g;
  console.log(reg.test(str));
  ```

- 6.匹配常见的固定电话号码

  ```js
  var str = "000-12344562";
  //  \(? 匹配左括号一次或0次然后以0开头后面加两个数字，再匹配右括号或空格或减号一次或0次，随后匹配8个数字
  var reg = /\(?0\d{2}[) -]?\d{8}/g;
  console.log(str.match(reg));
  ```

- 7.匹配ip地址

  ```js
  var str = "255.221.221.12";
  // [01]?\d\d?表示匹配小于199的数，可以说两位数或一位数，2[0-4]\d表示从200到249，配合25[0-5]就表示小于255的数了。
  var reg = /(([01]?\d\d?|2[0-4]\d|25[0-5])\.){3}([01]?\d\d?|2[0-4]\d|25[0-5])$/g;
  console.log(str.match(reg));
  ```

- 8.匹配用尖括号括起来的以a开头的字符串

  ```js
  var str = "<a herf='www.baidu.com'>";
  var reg = /<a[^>]+>/g;
  console.log(str.match(reg));
  ```

- 9.分割数字每三个以一个逗号划分

  ```js
  var str = "12345678901";
  function numSplit(str){
      var re = /(\d)(?=(\d{3})+$)/g;
      //(\d{3})+$ 的意思是连续匹配 3 个数字，且最后一次匹配以 3 个数字结尾。
      //要找到所有的单个字符，这些字符的后面跟随的字符的个数必须是3的倍数，并在符合条件的单个字符后面添加,
      return str.replace(re,'$1,');
  }
  console.log(numSplit(str));
  ```

- 10.判断字符串是否包含数字

  ```js
  var test_text="abc123";//2.
  if (new RegExp("[0-9]").test(test_text)) {
       return false;
  }
  ```

- 11.判断电话号码

  ```js
  function checkPhone(){ 
      var phone = document.getElementById('phone').value;
      if(!(/^1[3456789]d{9}$/.test(phone))){ 
          alert("手机号码有误，请重填");  
          return false; 
      } 
  }
  ```

- 12.获取 url 参数

  ```js
  //通过正则匹配获取当前页面的url中的参数
  function getUrlParam(name){
  var reg = new RegExp("(^|&)"+name+"=([^&]*)(&|$)"); 
  var r =  window.location.search.substr(1).match(reg);
  var strValue = "";
  if (r!=null){
   strValue= unescape(r[2]);
  }
  return strValue;
  }
  ```

- 13.验证邮箱

  ```js
  var email = this.value;
  var reg = /^([a-zA-Z]|[0-9])(\w|\-)+@[a-zA-Z0-9]+\.([a-zA-Z]{2,4})$/;
  if(reg.test(email)){
  	alert("邮箱格式正确");
  }else{
  	alert("邮箱格式不正确");
  }
  ```

- 14.验证身份证号码

  ```js
  // 函数参数必须是字符串，因为二代身份证号码是十八位，而在javascript中，十八位的数值会超出计算范围，造成不精确的结果，导致最后两位和计算的值不一致，从而该函数出现错误。
  // 详情查看javascript的数值范围
  function checkIDCard(idcode){
      // 加权因子
      var weight_factor = [7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2];
      // 校验码
      var check_code = ['1', '0', 'X' , '9', '8', '7', '6', '5', '4', '3', '2'];
  
      var code = idcode + "";
      var last = idcode[17];//最后一位
  
      var seventeen = code.substring(0,17);
  
      // ISO 7064:1983.MOD 11-2
      // 判断最后一位校验码是否正确
      var arr = seventeen.split("");
      var len = arr.length;
      var num = 0;
      for(var i = 0; i < len; i++){
          num = num + arr[i] * weight_factor[i];
      }
      
      // 获取余数
      var resisue = num%11;
      var last_no = check_code[resisue];
  
      // 格式的正则
      // 正则思路
      /*
      第一位不可能是0
      第二位到第六位可以是0-9
      第七位到第十位是年份，所以七八位为19或者20
      十一位和十二位是月份，这两位是01-12之间的数值
      十三位和十四位是日期，是从01-31之间的数值
      十五，十六，十七都是数字0-9
      十八位可能是数字0-9，也可能是X
      */
      var idcard_patter = /^[1-9][0-9]{5}([1][9][0-9]{2}|[2][0][0|1][0-9])([0][1-9]|[1][0|1|2])([0][1-9]|[1|2][0-9]|[3][0|1])[0-9]{3}([0-9]|[X])$/;
  
      // 判断格式是否正确
      var format = idcard_patter.test(idcode);
  
      // 返回验证结果，校验码和格式同时正确才算是合法的身份证号码
      return last === last_no && format ? true : false;
  }
  ```

- 15.匹配汉字

  ```js
  var str666 = 'long long age';
  var reg = new RegExp("[\\u4E00-\\u9FFF]+","g");
  if(reg.test(str666)){
      console.log("有汉字");
  }else{
      console.log("无汉字");
  }
  ```

- 16.IPv4地址正则

  ```js
  var str = "127.0.0.0";
  var reg = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
  console.log(str.test(reg));
  ```

- 17.十六进制颜色正则

  ```js
  var str = "#331122";
  var reg=/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
  console.log(str.test(reg));
  ```

- 18.车牌号正则

  ```js
  //车牌号验证
  function chepai(){
  	var is_no = isLicenseNo($('#haoma').val())
  	console.log(is_no)
  	if(!is_no){
  		alert('请输入正确的车牌号');
  		$('#haoma').val('');
  	}
  }
      
  function isLicenseNo(str) {
      var regExp = /(^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$)/;
      if(!regExp.test(str)){
      	return false;
      }else {
      	console.log("车牌号正确")
      	return true;
      }
  }
  ```

- 19.过滤HTML标签

  ```js
  var str = "<a herf='www.baidu.com'>";
  var reg=/<[^<>]+>/g   //1、全局匹配g肯定忘记写  2、<>标签中不能包含标签实现过滤HTML标签
  console.log(str.test(reg));
  ```

- 20.密码强度正则，最少8位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符

  ```js
  var str = "asee@sa123";
  var reg=/^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-]).{8,}$/;
  console.log(str.test(reg));
  ```



# 洗牌算法

```js
let swap = a =>{
    let b = [];
    for(let i = a.length;i>0){
        var index = Math.floor(Math.random() * 1);
        b.push(a[index]);
        a[index - a[--i]];
    }
    return b;
}
```


# 算法基础01-数组、链表、跳表

## 一、数组本质

- 数组的本质是把数据存储在计算机内存管理器开辟的**连续内存地址对应的位置**
- 所以数组的随机访问时间复杂度为O(1)，搜索元素的时间复杂度为O(n)
- 插入删除元素由于平均需要移动半个数组的元素，平均时间复杂度为**O(n)**

## 二、链表本质

- 链表的本质是**每个元素靠指针指向其相邻元素**，随机访问需要遍历整个链表
- 访问和搜索的时间复杂度为O(n)
- 插入删除元素只需要处理相邻元素的指针指向关系，所以插入和删除的时间复杂度为O(1)

## 三、跳表本质

![img](https://pic3.zhimg.com/80/v2-8f067b9218dcd860b353156c3c10006e_720w.jpg)

- 跳表的本质是在链表的基础上进行**升维**，加入**多级索引**，每级索引不再是跳向相邻元素，而是跳跃 2^k 个元素
- 其底层实现有多种方式，有BST二叉搜索树、AVL平衡二叉树等
- 故其访问和搜索的时间复杂度为O(logn)
- 插入和删除元素的时间复杂度也是O(logn)
- redis 的sorted set的底层实现就是跳表[[1\]](https://zhuanlan.zhihu.com/p/115271079#ref_1)

# 算法基础02-栈、队列、优先队列、双端队列、哈希表、映射、集合

## 一、栈、队列、双端队列、优先队列本质

- 栈的本质是以后进先出LIFO方式插入删除元素的数据结构
- 队列的本质是以先进先出方式插入删除元素的数据结构
- 双端队列的本质是栈+队列，同时支持先进先出和后进先出
- 优先队列的本质是入队与队列相同，出队按优先级顺序出队，底层实现可能是堆、平衡二叉树等
- 栈、队列、双端队列的的插入删除时间复杂度都是O(1)，搜索和遍历时间复杂度都是O(n)
- 优先队列的插入时间复杂度是O(1)，取出的时间复杂度是O(logn)

## 二、哈希表、映射、集合本质

- 哈希表的本质是根据Key直接访问Value的数据结构，通过把Key经过Hash Function映射到表中某个位置，以加快访问速度
- 映射的本质是key-value对，其中key唯一
- 集合的本质是元素唯一
- 哈希表的插入、删除、搜索时间复杂度都是O(1)

## 三、Java Queue 和 Priority Queue源码分析

- Priority Queue是通过数组实现一个堆，元素在queue数组中并不是完全有序的，仅堆顶元素最大或最小
- poll方法，实际上是获取堆顶元素，然后调整堆
- 调整堆的方法（大顶堆为例）：
  1.判断是否传入comparator，有则按照comparator顺序，否则按照自然顺序排序
  2.取节点左右孩子节点的最大值，与父节点交换

## 四、Java HashMap总结

- 根据键的hashCode值存储数据，访问时间复杂度近似O(1)，但遍历顺序不确定
- 非线程安全，任意时刻可以有多个线程同时写HashMap，可能会导致数据混乱，如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap
- 为了解决哈希冲突，Java采用链地址法（另一种方法是开放地址法），底层实现是数组+链表+红黑树的组合

![img](https://pic2.zhimg.com/80/v2-bc6f2854a7a6027dc1c25bb91f37f08d_720w.jpg)Java 8 HashMap底层实现

- 具体实现过程[[1\]](https://zhuanlan.zhihu.com/p/115277503#ref_1)为：

1. 先调用key的hashCode方法得到hashCode值
2. 再通过Hash算法中的高位运算和取模运算，确定键值对的存储位置
3. 当HashCode值相等时，发生哈希碰撞，此时先判断当前地址下的的链表长度是否大于8，如果大于8就把链表转为红黑树，否则进行链表的插入操作
4. 插入成功后，判断实际存在的键值对数量是否超过最大容量threshold，如果超过就扩容

# 算法基础03-树、二叉树、递归、分治、回溯、图、堆

## 一、树的本质

树是一个由根和子树构成的二维数据结构，满足以下几个特点：

- 每个节点都只有有限个子节点或无子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树；
- 树里面没有环路(cycle)

![img](https://pic2.zhimg.com/80/v2-496f28533b0658fccf3274d442624441_720w.jpg)



由于树的每个节点都具有相同的特点，所以跟树相关的问题几乎都能用**递归**来解决。

### 二叉树

每个节点最多只有两颗子树的树。

二叉树的遍历

```text
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        dfs(res, root);
        return res;
    }

    void dfs(List<Integer> res, TreeNode root){
        if(root == null) return;
        dfs(res, root.left);
        res.add(root.val); // 根据访问根节点的顺序不同，可以分为前序、中序、后序遍历，这里是中序遍历
        dfs(res, root.right);
    }
}
```

### 二叉搜索树（Binary Search Tree）

二叉搜索树，也称二叉搜索树、有序二叉树（Ordered Binary Tree）、 排序二叉树（Sorted Binary Tree），是指一棵空树或者具有下列性质的二叉树：

- 左子树上的**所有节点**小于根节点
- 右子树上的**所有节点**大于根节点
- 根节点的左右子树也为二叉搜索树

![img](https://pic4.zhimg.com/80/v2-51560c1841e75cc9da7d09cf49bef703_720w.jpg)



根据这些性质，二叉搜索树最大的特点就是其中序遍历是**升序**的，另外二叉搜索树插入、删除、访问、搜索时间复杂度都是**O(logn)**。

## 二、递归

递归，讲起来很简单，先递进再回归。

![img](https://pic3.zhimg.com/80/v2-ff13d7eb04061352001dd39cf02dc482_720w.jpg)



我认为递归是计算机计算效率远超人类的三大原因之一（判断、循环和递归）。因为相比计算机，世世代代人类的老祖先们却只能顺序迭代，所以这就导致了递归是非常**反人类天性**的，这也是大部分人觉得递归难的根本原因。

### 递归模板

这里给出递归的Python代码模板，其他语言类似。

```text
def recursion(level, param1, param2...):
    # 1.terminator
    if level > MAX_LEVEL:
        process_result
        return
    # 2.process
    process(level, data...)
    # 3.drill down
    recursion(level+1, p1, p2...)
    # 4.restore the current level's states if needed
```

### 递归的要点

1. 不要一层一层人肉递归，因为人肉递归会很耗脑力，让你非常累（反直觉，但没有办法）
2. 找到最近重复子问题，或者将一个大问题拆成可重复的子问题
3. 数学归纳法思维

### 分治

分治的思想就是把大问题分成小问题，解决小问题，再把小问题的解答合并得到大问题的解答。

分治的代码模板就是在递归的基础上增加了split the problem和merge subproblems

```python3
def divide_conquer(problem, param1, param2, ...):
    # recursion terminator
    if problem is None:
        print_result
        return
    # prepare data
    data = prepare_data(problem)
    subproblems = split_problem(problem, data)
    # conquer subproblems
    subresult1 = self.divide_conquer(subproblems[0], p1, ...)
    subresult2 = self.divide_conquer(subproblems[1], p1, ...)
    subresult3 = self.divide_conquer(subproblems[2], p1, ...)
    …
    # process and generate the final result
    result = process_result(subresult1, subresult2, subresult3, …)
    # revert the current level states
```

### 回溯

回溯的思想就是在递归解决问题的过程中，遇到不满足条件的情况，返回上一层重新选择路径解决。

回溯的代码模板是在递归的基础上，加入了对选择列表的循环，最重要的是**restore current states**，这一步也是回溯的精髓所在。

```text
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        # 做选择
        路径.add(选择)
        (将该选择从选择列表移除)
        backtrack(路径, 选择列表)
        # 撤销选择，restore current states
        路径.remove(选择)
        (将该选择重新添加到选择列表)
```

## 三、图的本质

图是由定点和边构成的二维数据结构，用来表示元素之间的关系。从定义的角度来说，树其实是特殊化的图（无向无环），而链表又是特殊化的树（只有单边子树）。图的遍历方法有广度优先搜索(Breadth First, BFS Search)和深度优先搜索(Depth First Search, DFS)。

## 四、堆的本质

堆是一个顶点元素总是小于其子节点元素的数据结构，所以堆的堆顶元素总是元素列表中最大值或最小值。

### 二叉堆

二叉堆（英语：binary heap）是一种特殊的堆，二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足堆特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。因为这些性质，二叉堆的插入、删除、搜索、访问任意元素的操作时间复杂度都是O(logn)，访问最大或最小元素的时间复杂度为O(1)。


# 算法基础04-深度优先搜索、广度优先搜索、二分查找、贪心算法

## **深度优先搜索DFS、广度优先搜索BFS**

### **比较**

- 拿谚语打比方的话，深度优先搜索可以比作**打破砂锅问到底**、**不撞南墙不回头**；广度优先搜索则对应**广撒网，多敛鱼**
- 两者没有绝对的优劣之分，只是**适用场景不同**
- 当解决方案离树根不远或搜索深度可变时，BFS通常更好，因为只需搜索所有数据中的一部分。另外BFS的一个重要优点是它可以用于找到**无权图**（有权图用Dijkstra算法，贪心思想）中任意两个节点之间的**最短路径**（不能使用DFS）
- 如果树比较宽而且深度有限，DFS可能是更优选项，因为DFS比BSF**更节省空间**，另外由于使用递归，DFS更好写（BFS必须手动维护队列）

### **时间复杂度**

都是O(n)

### **空间复杂度**

都是O(n)

### **经典题目**

1. LeetCode 102题，[二叉树的层序遍历](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/binary-tree-level-order-traversal/)
   思路：

2. 1. DFS，深度优先，用level记录当前层，如果当前层记录完毕就return，结果数组用level索引当前层，结果数组容量小于等于level就扩容，再DFS递归到下一层
2. BFS，广度优先，用队列先进先出的特性，先确定当前层的节点数量，遍历当前层，把当前层的下一层所有节点入队，当前层节点出队并放到一个临时数组，再添加到结果

```java
// DFS-Java
class Solution {
    public List<List<Integer>> res = new LinkedList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        dfs(0, root);
        return res;
    }
    private void dfs(int level, TreeNode root){
        if(root == null) return;
        if(res.size() <= level){
            res.add(new LinkedList<>());
        }
        res.get(level).add(root.val);
        dfs(level+1, root.left);
        dfs(level+1, root.right);
    }
}
```



```java
// BFS-Java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root == null) return res;
        queue.add(root);
        while(!queue.isEmpty()){
            int level = queue.size();
            List<Integer> tempList = new LinkedList<>();
            for(int i = 0; i < level; i++){
                if(queue.peek().left != null) queue.add(queue.peek().left);
                if(queue.peek().right != null) queue.add(queue.peek().right);
                tempList.add(queue.poll().val);
            }
            res.add(tempList);
        }
        return res;
    }
}
```

## **二分查找**

### **本质**

二分查找的本质是在一组**单调**、**有上下界**、**可索引**的数据中搜索目标值，三大条件缺一不可。

### **时间复杂度**

O(logN)

### **空间复杂度**

O(1)

### **经典题目**

1. LeetCode 69 题，[x的平方根](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/sqrtx/)
   思路：

2. 1. 二分查找，因为y=x^2在x正半轴**单调递增**，且存在**上下界1和x**，所以可以使用二分查找逼近
2. 牛顿迭代法，利用切线逼近，公式为 x = (x + a/x) / 2

```java
// 二分查找
class Solution {
    public int mySqrt(int x) {
        if(x == 0 || x == 1) return x;
        long left = 1, right = x, mid = 1;
        while(left <= right){
            mid = left + (right - left) / 2;
            if(mid * mid > x){
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return (int) right;
    }
}
```



```java
// 牛顿迭代法
class Solution {
    public int mySqrt(int x) {
        long r = x;
        while (r * r > x) {
            r = (r + x / r) / 2;
        }
        return (int)r;
    }
}
```



## **贪心算法**

### **本质**

贪心的本质是通过每一步的局部最优，期望实现全局最优的一种算法思想。关键在于局部最优是否真的能实现全局最优。如果能实现，那么贪心算法基本上就是问题的最优解。

### **经典例题**

1. LeetCode 55题，[跳跃游戏](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/jump-game/)
   思路：

2. 1. 倒序贪心，看最后能不能到达第一个点
2. 正序贪心，如果某个点可以跳到最后，那么它左边的点一定可以



```java
// 倒序贪心
class Solution {
    public boolean canJump(int[] nums) {
        if (nums == null) return false;
        int endReachable = nums.length - 1;
        for (int i = nums.length - 1; i >= 0; i--){
            if(nums[i] + i >= endReachable){
                endReachable = i;
            }
        }
        return endReachable == 0;
    }
}
```



```java
// 正序贪心
class Solution {
    public boolean canJump(int[] nums) {
        int maxPos = 0;
        for (int i = 0; i < nums.length; i++){
            if(i > maxLen) return false;
            maxPos = Math.max(maxPos, nums[i] + i);
            if(maxPos >= nums.length-1) break;
        }
        return true;
    }
}
```


# 算法基础05-动态规划

## 定义

让我们看看维基百科中动态规划的定义，截取其中最关键的一部分

> Dynamic programming refers to simplifying a complicated problem by **breaking it down into simpler sub-problems** in a recursive manner.
> Likewise, in computer science, if a problem can be **solved optimally by breaking it into sub-problems** and then **recursively finding the optimal solutions to the sub-problems**, then it is said to have optimal substructure.

翻译过来就是：动态规划指的是通过把一个问题**递归拆解**成更加简单的子问题的方式简化一个复杂问题。在计算机科学中，如果一个问题可以通过先拆解成简单子问题，寻递归找到每个子问题的最优解，这样我们就可以认为这个问题存在**最优子结构**。

## 本质

分治+最优子结构（每步选最优，淘汰次优）

## 动态规划“三板斧”

1. 分治，找到最优子结构 `opt[n]=best_of(opt[n-1], opt[n-2], ...)`
2. 状态定义，i 条件时的状态 `f[i]`
3. DP方程，也就是递推公式，例如一维的斐波那契递推公式 `dp[i] = dp[i-1] + dp[i-2]`
   二维递推公式例如 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`，高级的DP公式可能会达到三维甚至三维以上

## 经典问题

[62.Unique Path](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/unique-paths/)

思路：

1. 暴力递归，指数级时间复杂度
2. DP
   a. 分治（子问题） path = path(top) + path(left)
   b. 状态定义 `f[i, j]` 表示第i行第j列的不同路径数
   c. DP方程 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`

代码

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for(int i = 0; i < n; i++) dp[0][i] = 1;
        for(int i = 0; i < m; i++) dp[i][0] = 1;
        for(int i = 1; i < m; ++i){
            for(int j = 1; j < n; ++j){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

对于我们的DP公式`dp[i][j] = dp[i-1][j] + dp[i][j-1]`，我们还可以继续优化，因为求的是到达终点的不同路径，我们没必要保存到每行每列任意点的不同路径数，其实只需要保存每一行任意点的路径数即可，DP方程可以更新为 `dp[i] = dp[i] + dp[i-1]`

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] dp = new int[m];
        dp[0] = 1;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (j > 0) dp[j] += dp[j-1];
            }
        }
        return dp[m-1];
    }
}
```



[1143.最长公共子序列LCS](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-common-subsequence/)

思路：

1. 暴力
2. DP

![img](https://pic4.zhimg.com/80/v2-b2a4330f4e0ff8ad0b4e4b46f3378ba7_720w.jpg)


a. 分治 `LCS[i] = max（LCS(最后一个字母相同)，LCS(最后一个字母不相同)）`

b. 状态定义 `f[i][j]` 第一个字符串索引 0-i 构成的子串与第二个字符串索引 0-j 子串的最长公共序列

c. DP方程

```text
if text1[-1] == text2[-1]:
        dp[i][j] = dp[i-1][j-1] + 1
    else:
        dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

Java 实现

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        char[] s1 = text1.toCharArray();
        char[] s2 = text2.toCharArray();
        int[][] dp = new int[s1.length+1][s2.length+1];
        for (int i = 1; i < s1.length+1; ++i) {
            for (int j = 1; j < s2.length+1; ++j) {
                if(s1[i-1] == s2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[s1.length][s2.length];
    }
}
```

# 算法基础06 - 字典树、并查集、高级搜索、红黑树、AVL 树

## 字典树（Trie 树）

### 基本结构

字典树是一颗沿着单词中字母排列顺序扩展的多叉树，典型应用是用于统计和排序大量的字符串（但不仅限于字符串），优点是最大限度减少无谓的字符串比较，查询效率比哈希表高。



![img](https://pic4.zhimg.com/80/v2-7bb0944a9ff1aa70675d9299f53bc187_720w.jpg)



单词 leet 在 Trie 树中的表示



![img](https://pic2.zhimg.com/80/v2-ba976bb15f5672364336c1460b59db2d_720w.jpg)



### 核心思想

Trie 树的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

### 主要用途

- 搜索引擎输入栏的自动补全
- 拼写检查
- IP 路由最长前缀匹配
- 打字预测

### 经典问题

### [212.单词搜索 II](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/word-search-ii/)

思路：

- Trie 树+ DFS + 剪枝，时间复杂度![[公式]](https://www.zhihu.com/equation?tex=O%28m+%2A+n+%2A+4+%2A+3%5E%7BL-1%7D%29) ，其中 L 为单词最大长度，m * n 为网格单元数，空间复杂度为 O(N)，其中 N 为字典中字母总数

Python解法

```python3
class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        # 构建 Trie
        trie = {}
        for word in words:
            node = trie
            for char in word:
                node = node.setdefault(char, {})
            node['#'] = True
        # DFS
        def _dfs(i, j, node, pre, visited):
            if '#' in node:
                res.add(pre)
            for (di, dj) in ((-1,0), (1,0), (0, -1), (0, 1)):
                x, y = i+di, j+dj
                if 0 <= x < m and 0 <= y < n and board[x][y] in node and (x,y) not in visited:
                    _dfs(x, y, node[board[x][y]], pre+board[x][y], visited | {(x,y)})
        # 主逻辑
        res, m, n = set(), len(board), len(board[0])
        for i in range(m):
            for j in range(n):
                if board[i][j] in trie:
                    _dfs(i, j, trie[board[i][j]], board[i][j], {(i,j)})
        return list(res)
```

------

## 并查集

并查集，英文名 disjoint set，是用于处理不交集的合并以及查询问题的树形结构。

### 基本操作

- MakeSet(s)：创建一个新的并查集，其中包含s个单元素集合

![img](https://pic4.zhimg.com/80/v2-1f769277c64556d472f18d9c11d06c87_720w.jpg)



- Union(x, y)： 将两个子集合并为一个
- Find(x)： 找到元素所在集合的代表，进而确定元素属于哪一个子集

![img](https://pic3.zhimg.com/80/v2-403b494d64ac8d1c1a805e1a830878da_720w.jpg)



使用路径压缩可以使未来的查询时间复杂度降为 O(1)

![img](https://pic4.zhimg.com/80/v2-c32ba21f5dda6ec9215bb4de99dadc27_720w.jpg)



### 代码模板

```python3
def init(p): 
	# for i = 0 .. n: p[i] = i; 
	p = [i for i in range(n)] 
 
def union(self, p, i, j): 
	p1 = self.parent(p, i) 
	p2 = self.parent(p, j) 
	p[p1] = p2 
 
def parent(self, p, i): 
	root = i 
	while p[root] != root: 
		root = p[root] 
	while p[i] != i: # 路径压缩
		x = i; i = p[i]; p[x] = root 
	return root
```

------

## 高级搜索

想知道高级搜索之前，我们先来看看什么是初级搜索

### 初级搜索

1. 暴力搜索
2. 优化方向：剪枝、缓存
3. 搜索方向：DFS、BFS

高级搜索是对初级搜索的进一步改良，比如双向搜索、启发式搜索等。

### 双向搜索

核心思想是开始和结束位置同时开始搜索，如果能在中间相遇，说明可以搜索到，如果无法相遇，说明搜索不到。双端BFS是最典型的双向搜索技巧。

### 双端BFS搜索时间复杂度



![[公式]](https://www.zhihu.com/equation?tex=O%28b%5E%7Bd%2F2%7D+%2B+b%5E%7Bd%2F2%7D%29) ，其中 b 为BFS每层的宽度，d 为图的深度

普通BFS的时间复杂度为 ![[公式]](https://www.zhihu.com/equation?tex=O%28b+%5E+d%29) ，可以通过数学证明双端BFS时间复杂度会比普通BFS快很多。

### 双端BFS代码模板

```java
public <T> two-endedBFS(begin, end, Container) {
    if (Container.length == 0 || !Container.contains(end)) return NEGATIVE;
    Set<T> beginSet = new HashSet<>(), endSet = new HashSet<>();
    beginSet.add(begin);
    endSet.add(end);
    
    Set<T> visited = new HashSet<>();
    int level = 0;
    
    while(!beginSet.isEmpty() && !endSet.isEmpty()) {
        if (beginSet.size() > endSet.size()){
            Set<T> set = beginSet;
            beginSet = endSet;
            endSet = set;
        }
        Set<T> temp = new HashSet<>();
        for (T item: beginSet){
            T next = generate_nextLevel_nodes();
            if (endSet.contains(next)) return POSITIVE;
            if (Container.contains(next) && !visited.contains(next)){
                temp.add(next);
                visited.add(next);
            }
            // reverse node states
        }
        beginSet = temp;
        level++;
    }
    return NEGATIVE;
}
```

### 启发式搜索

启发式搜索，也叫A*算法，它的本质就是优先搜索。根据问题不同，定义不同的优先级比较器，按照优先级从大到小搜索。由于实现一般比较复杂，这里不作代码方面的展开。

------

## 红黑树 & AVL树

二叉搜索树的查询时间复杂度只跟树的深度有关，所以为了高效查询，需要保证每个节点子树的深度差不能过大，如此便诞生了平衡二叉树，其中最有名的是红黑树和AVL树。

### AVL树特点

- Balance Factor（平衡因子）：左右子树的高度差，通常限制在 {-1, 0, 1} 范围内

![img](https://pic3.zhimg.com/80/v2-386c6dd141ccad92ee6443b5baa3a602_720w.jpg)



- 通过旋转操作来进行平衡：左旋、右旋、左右旋、右左旋

![img](https://pic1.zhimg.com/80/v2-7bb1e7146c22b2cbd5f65bfa23663f18_720w.jpg)



### 红黑树特点

红黑树是一种近似平衡的二叉搜索树，它可以确保任何一个节点的左右子树的高度差小于两倍。

- 每个节点要么红，要么黑
- 根节点是黑色
- 每个子叶节点（NIL节点）是黑色的
- 不能有相邻接的两个红色节点
- 从任一节点到其每个子叶的所有路径都包含数量相同的黑色节点
- 最关键的性质是：从根到叶子的**最长**可能路径**不多于最短的**可能路径的**两倍长**

### AVL & 红黑树比较

- AVL查询更快，因为更加严格平衡
- 红黑树增加删除更快，因为相比AVL，红黑树需要的旋转操作更少
- AVL要存储平衡因子或子树高度，所以会消耗更多空间，而红黑树每个节点只需要1位信息（红 or 黑）
- 所以读操作非常多写操作不多时，AVL更好；写操作较多或读写参半时红黑树更好；
- 比如主流语言的库函数如map等是用红黑树实现的，而数据库用AVL实现较多

# 算法基础07-位运算、布隆过滤器、LRU Cache

## 位运算

### 核心要领

想要熟练掌握位运算，**记住下面几个公式**即可：

- 清除 n 最低位的 1：`n & (n - 1)`
- 获取 n 最低位的 1：`n & -n`
- 整除 2：`n >> 1`
- 判断奇偶： `n & 1 == 1 | 0`
- `n & ~n = 0`

### 经典例题

### [52. N-Queens II](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/n-queens-ii/)

思路：

1. 回溯，时间复杂度 O(n!)，空间复杂度 O(n)
2. **位运算**，时间复杂度 O(n!)，空间复杂度 O(n)，由于位运算**更接近计算机底层**，所以运行速度会更快，位运算也是N-Queens问题的**终极解决方案**，算法的核心要点如下：

- 0 - 不能放皇后，1 - 能放
- `availPos = (~(cols | pie | na)) & ((1 << n) - 1)` 考虑整行、两条对角线，得到当前能放皇后的位置，用最低的 n 位表示
- `p = availPos & -availPos` 取得 availPos 最低位的1，用来放皇后
- `availPos &= (availPos - 1)` 清除最低位的 1，表示皇后已放
- `dfs(n, row + 1, cols | p, (pie | p) << 1, (na | p) >> 1)` 对 cols, pie, na 可放皇后的位置做相应的更新，下探下一层 ( Drill Down )



### Java 实现

```java
class Solution {
    private int count = 0;

    public int totalNQueens(int n) {
        dfs(n, 0, 0, 0, 0);
        return count;
    }

    private void dfs(int n, int row, int cols, int pie, int na) {
        if (row == n) {
            count++;
            return;
        }
        int availPos = (~(cols | pie | na)) & ((1 << n) - 1);
        while (availPos != 0) {
            int p = availPos & -availPos;
            availPos &= (availPos - 1);
            dfs(n, row + 1, cols | p, (pie | p) << 1, (na | p) >> 1);
        }
    }
}
```

### Python 实现

```python
class Solution:
    def totalNQueens(self, n: int) -> int:
        self.count = 0
        self.dfs(n, 0, 0, 0, 0)
        return self.count
    
    def dfs(self, n, row, cols, pie, na):
        if row == n:
            self.count += 1
            return
        
        availPos = (~(cols | pie | na)) & ((1 << n) - 1)

        while availPos:
            p = availPos & -availPos
            availPos &= (availPos - 1)
            self.dfs(n, row + 1, cols | p, (pie | p) << 1, (na | p) >> 1)
```

## 布隆过滤器（Bloom Filter）

### 本质

布隆过滤器由**一个很长的二进制向量**和**一系列随机映射函数**组成。用于检索一个元素是否在一个集合中。

- 优点是**空间效率和查询时间远超一般算法**
- 缺点是**有一定的错误识别率和删除困难**



![img](https://pic4.zhimg.com/80/v2-f9d1cf3df8d78da44bd2bdada86a9043_720w.jpg)



### 要点

布隆过滤器是一个快速判断元素是否存在集合的算法，特点是：

1. 不需要像哈希表一样存额外的信息
2. 只能判断**肯定不存在**或**可能存在**
3. 适合用作**高速缓存**，如判断为可能存在，再到数据库中查询
4. 每个元素的存在用几个**二进制位置 1** 来表示
5. 多用于大型分布式系统如比特币网络、Redis缓存、垃圾邮件过滤器、评论过滤器等



![img](https://pic3.zhimg.com/80/v2-670af45efa29c00ac97ec58de93f3b1e_720w.jpg)



## LRU Cache

最近最少使用缓存替换策略，是一种 [缓存替换策略](https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Cache_replacement_policies)，其他缓存策略还有 FIFO、LFU、RR 等等。

LRU：Latest Recently Used 最近最少使用。



![img](https://pic3.zhimg.com/80/v2-62c53a6efda563c25f87b147ed5094f2_720w.jpg)



### 硬核实现 LRU Cache

接下来让我们自己造轮子，硬核实现一个 LRU Cache，它应该支持以下两个操作：

- 获取数据 `get(key)` - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
- 写入数据 `put(key, value)` - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

还有两个需求：

- 增加删除数据的时间复杂度为O(1)
- 随机访问数据的时间复杂度为O(1)

------

增删 O(1)，我们第一个想到要用 LinkedList，访问 O(1)，我们第一个想到要用 HashTable，那么怎么把两者结合起来呢？让我们从思考这两个问题开始：

1. 链表有特殊要求吗？单链表还是双向链表？
2. 链表中的节点存什么，只存 value 够吗？

先回答第一个问题，因为我们需要删除数据，链表删除节点需要找到当前节点的**前驱**，单链表想要找到节点前驱需要从头开始遍历，存在 O(n) 的时间复杂度；而双向链表本身就保存了节点的前驱，删除时间复杂度就是 O(1)，所以我们使用**双向链表**。

接下来回答第二个问题，由于缓存空间有限，当缓存存满时，根据 LRU 策略，我们需要移除缓存里保存最久的未被访问节点，比如上图中的 A 和 B，与此同时，我们还需要移除 HashMap 中的该节点（已不在缓存中，下次无法查到），如果节点只存 value，那么 HashMap 就无法移除该节点（哈希表删除节点需要 key， `map.remove(key)`），所以链表节点需要**同时存 key 和 value**，就像下图这样。



![img](https://pic3.zhimg.com/80/v2-9e7f80e1e3135f0ba3396a3fe870eb2a_720w.jpg)



解答了这两个问题，我们就可以开始动手了，先实现一个同时保存 key 和 value 的双向链表。

```java
class Node {
    public int key, val;
    public Node next, prev;

    public Node(int k, int v) {
        this.key = k;
        this.val = v;
    }
}

// 双向链表
class DoubleLinkedList {
    private Node head, tail; // 头尾虚节点
    private int size; // 链表元素数

    public DoubleLinkedList() {
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
        size = 0;
    }

    // 在链表头部添加节点
    public void addFirst(Node node) {
        node.next = head.next;
        node.prev = head;
        head.next.prev = node;
        head.next = node;
        size++;
    }
    
    // 删除链表中的节点（该节点一定存在）
    public void remove(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        size--;
    }
    
    // 删除链表中最后一个节点，并返回该节点
    public Node removeLast() {
        if (tail.prev == head)
            return null;
        Node last = tail.prev;
        remove(last);
        return last;
    }
    
    // 返回链表长度
    public int size() {
        return size;
    }
}
```

接下来就是正式实现 LRU Cache 了，核心逻辑写在注释上了。

```java
class LRUCache {
    private HashMap<Integer, Node> map;
    private DoubleLinkedList cache;
    private int cap; // 最大容量

    public LRUCache(int capacity) {
        this.cap = capacity;
        map = new HashMap<>();
        cache = new DoubleLinkedList();
    }

    // 访问节点
    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        }
        int val = map.get(key).val;
        // 使用put方法把最近访问的节点提前
        put(key, val);
        return val;
    }

    public void put(int key, int value) {
        // 生成新的节点
        Node node = new Node(key, value);
        if (map.containsKey(key)) {
            // 删除旧的节点，新的插到头部
            cache.remove(map.get(key));
            cache.addFirst(node);
            // 更新 map 中对应的数据
            map.put(key, node);
        } else {
            // 如果缓存满了
            if (cap == cache.size()) {
                // 删除链表最后一个数据
                Node last = cache.removeLast();
                // 哈希表也要删
                map.remove(last.key);
            }
            // 新节点添加到头部
            cache.addFirst(node);
            map.put(key, node);
        }
    }
}
```

最后多说一句，如果我们把这两部分合起来，其实就得到了 [LeetCode 146](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/lru-cache/) 的**最佳题解**，我想这也是面试题中对 LRU Cache 实现的**最高要求**了。


# 算法基础08-排序算法

说到排序算法，它可能是最接近程序员日常工作的算法，像 Java、Python 里 `sort()` API 的实现，都离不开快速排序。非常经典的逆序对问题的最佳解法也需要用到归并排序，所以排序算法很大程度上能体现一个程序员的基础扎实程度。这里对排序算法做一个全面的归纳总结。

### 复杂度总览

除了最下面三种特殊排序算法，目前所有排序算法都无法突破 O(nlogn) 的时间复杂度下限。根据时间复杂度是 O(n^2) 还是 O(nlogn)，我们把排序算法分为初级排序算法和高级排序算法。



![img](https://pic2.zhimg.com/80/v2-62b9e7899b62491f698d848df3f31da9_720w.jpg)


# 算法基础09-高级DP、字符串算法

## 高级 DP

高级 DP， 顾名思义，是比较复杂的 DP 问题，这种复杂主要体现在三个方面

- 状态有更多维度，二维、三维或者更多，甚至需要压缩
- dp 方程更加复杂
- Corner Cases 更多，容易漏

这就需要我们更多的**练习**，提高**编程基本功**、**逻辑思维能力**、**数学能力**，以练就看到问题就能准确又快速地定义且推导出正确的 DP 状态方程。话不多说，下面给出几道高级 DP 问题，大家可以体验一下这个难度，还有 DP 方程的推导。

### 经典例题

### [32.最长有效括号](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-valid-parentheses/)

思路：

1. 暴力，栈，双重遍历子序列，看是否有效，`O(n^3)`
2. 栈，一次遍历，贪心，找到一对括号才更新最大长度，`O(n^2)`
3. 高级DP

- s[i] == ')' 且 s[i-1] == '('，形如".....()"，`dp[i] = dp[i-2] + 2`
- s[i] == ')' 且 s[i-1] == ')'，形如".....))"，此时如果s[i - dp[i-1] - 1] == '('，有 `dp[i] = dp[i - dp[i-1] - 2] + dp[i-1] + 2`



高级DP

```java
class Solution {
    public int longestValidParentheses(String s) {
        int[] dp = new int[s.length()];
        int res = 0;
        for (int i = 1; i < s.length(); ++i) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                    dp[i] = dp[i - 1] + (i - dp[i - 1] >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

### [818.赛车](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/race-car/)

思路：

1. BFS，时间`O(target * log(target))` 空间 `O(target * log(target))`
2. DP，时间`O(target * (log(target))^2)` 空间`O(target)`

- AAA...RAAA...R，车还没开到，currPos < target，正向加速 acc_cnt，反向加速 rev_acc_cnt，`dp[i] = min(dp[i], acc_cnt + 1 + rev_acc_cnt + 1 + dp[i - (currPos - revPos)]`
- AAAA, 只用加速刚好到 target `dp[i] = min(dp[i], acc_cnt)`
- AAA...RAAA... 车开过了，currPos > target, `dp[i] = min(dp[i], 1 + acc_cnt + dp[currPos - 1]`



```java
class Solution {
    public int racecar(int target) {
        int[] dp = new int[target + 1];
        for (int i = 1; i <= target; ++i) {
            dp[i] = Integer.MAX_VALUE;
            int acc_cnt = 1, currPos = 1;
            // AAA...RAAA...R
            while (currPos < i) {
                for (int rev_acc_cnt = 0, revPos = 0; revPos < currPos; revPos = (1 << ++rev_acc_cnt) - 1) {
                    dp[i] = Math.min(dp[i], acc_cnt + 1 + rev_acc_cnt + 1 + dp[i - (currPos - revPos)]);
                }
                currPos = (1 << ++acc_cnt) - 1;
            }
            // AAAA or AAA...RAAA...
            dp[i] = Math.min(dp[i], acc_cnt + (currPos == i ? 0 : 1 + dp[currPos - i]));
        }
        return dp[target];
    }
}
```

## 字符串算法

字符串问题，是最接近我们实际工作的一类问题，另一类问题是[排序](https://link.zhihu.com/?target=https%3A//juejin.im/post/5eabdf585188256d4a6d6031)，因此在笔试面试中非常常见。这里对字符串问题做一个全面汇总，让大家以后遇到此类问题能心中不慌。首先，字符串问题可以分为以下几类：

- 字符串基础
- 字符串操作
- 异位词问题
- 回文串问题
- 最长子串、子序列问题
- 字符串匹配问题

其次，我会带着大家过一遍，每类问题我都会给出一些**基本认识**和**经典例题**。

### 字符串基础

在 Java、JS、Python 里，String 是 Immutable (**不可变**) 的，意思是无法修改字符串某个索引的字符，只能复制新的字符串，或者说，只能浅拷贝。但是否所有编程语言中的字符串都是不可变的呢？其实不是，像下面几种语言的 String 就是 mutable 的：

- Ruby
- PHP
- C++ 、 C(其实没有 String 类，用 `char *` 表示)
- Swift

### [387.字符串第一个唯一字符](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/first-unique-character-in-a-string/)

JS

```js
// 哈希
var firstUniqChar = function(s) {
    let map = {}
    for (const char of s) {
        map[char] = ++map[char] || 0
    }
    for (let i = 0; i < s.length; ++i) {
        if (map[s[i]] == 0) return i
    }
    return -1
};

// 骚操作
var firstUniqChar = function(s) {
    for (const char of s) {
        if (s.indexOf(char) == s.lastIndexOf(char)) 
            return s.indexOf(char)
    }
    return -1
};
```

Java

```java
class Solution {
    public int firstUniqChar(String s) {
        Map<Character, Integer> map = new HashMap<>();
        for (char c : s.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        for (int i = 0; i < s.length(); ++i) {
            if (map.get(s.charAt(i)) == 1)
                return i;
        }
        return -1;
    }
}
```

### 字符串操作

反转字符串相关的操作熟悉一下，也是基础。

### [557.反转字符串中的单词 III](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/reverse-words-in-a-string-iii/description/) ✨

这道题是腾讯的面试题，大家感受一下。

```java
class Solution {
    public String reverseWords(String s) {
        char[] a = s.toCharArray();
        int i = 0, j = 0;
        while (j < a.length) {
            while (j < a.length && a[j] != ' ') j++;
            reverse(a, i, j - 1);
            i = j + 1;
            j++;
        }
        return String.valueOf(a);
    }

    private void reverse(char[] a, int start, int end) {
        while (start < end) {
            char tmp = a[start];
            a[start++] = a[end];
            a[end--] = tmp;
        }
    }
}
```

### 异位词问题

高频题目，最好把各种解法都掌握。

### [438.找到字符串中的所有异位词](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

思路：

1. 暴力，遍历 s，将 s 的子串与 t 比较是否互为异位词，时间复杂度`O(mn)`
2. 滑动窗口，复杂度`O(m)`，也是**最优解**

暴力

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        int m = s.length(), n = p.length();
        if (m < n) return res;
        for (int i = n; i <= m; ++i) {
            if (isAnagram(s.substring(i - n, i), p)) {
                res.add(i - n);
            }
        }
        return res;
    }
    private boolean isAnagram(String s, String p) {
        int[] cnt = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            cnt[s.charAt(i) - 'a']++;
            cnt[p.charAt(i) - 'a']--;
        }
        for (int n : cnt) {
            if (n != 0) return false;
        }
        return true;
    }
}
```

滑动窗口

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        int left = 0, right = 0;
        int validCnt = 0;
        for (char c : p.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1); // 初始化要求
        while (right < s.length()) {
            char rChar = s.charAt(right++); // 窗口右滑
            if (need.containsKey(rChar)) {
                window.put(rChar, window.getOrDefault(rChar, 0) + 1);
                if (window.get(rChar) <= need.get(rChar)) validCnt++; // <= 为了处理重复字符如"baa""aa"的cases
            }
            while (validCnt == p.length()) {
                if (right - left == p.length()) res.add(left); // 满足某种条件时更新 res
                char lChar = s.charAt(left++); // 窗口左滑
                if (need.containsKey(lChar)) {
                    window.put(lChar, window.get(lChar) - 1);
                    if (window.get(lChar) < need.get(lChar)) validCnt--; // 窗口不满足要求
                }
            }
        }
        return res;
    }
}
```

### 回文串问题

有点 tricky 的一类问题，重点是如何更好地利用回文串的性质。

### [680.验证回文字符串 II](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/valid-palindrome-ii/)

思路：

1. 暴力，删掉某个字符，看剩下的是否回文 `O(n^2)`
2. 贪心，如果首位字符不同，那么只用判断 `(i+1, j)``(i, j- 1)`是否回文（删首或者尾）

```java
class Solution {
    public boolean validPalindrome(String s) {
        char[] a = s.toCharArray();
        for (int i = 0, j = a.length - 1; i < j; ++i, --j) {
            if (a[i] != a[j]) {
                return isPalindrome(a, i + 1, j) || isPalindrome(a, i, j - 1);
            }
        }
        return true;
    }
    
    private boolean isPalindrome(char[] a, int i, int j) {
        while (i < j) {
            if (a[i++] != a[j--]) return false;
        }
        return true;
    }
}
```

### 最长子串、子序列问题

高频，通用解法一般是 DP。

### [1143.最长公共子序列 LCS](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-common-subsequence/) ✨

思路：

1. 暴力
2. DP
   a. 分治 `LCS[i] = max（最后一个字母相同，最后一个字母不相同）`
   b. 状态定义 `f[i][j]`
   c. DP方程if text1[-1] == text2[-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])

DP-Java

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
}
```

### [5.最长回文子串](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-palindromic-substring/)

思路：

1. 暴力 `O(n^3)`
2. DP 空间 + 时间复杂度 `O(n^2) + O(n)`
3. 从中间向外扩散 `O(n^2) + O(1)`

DP

```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        String res = "";
        for (int i = n - 1; i >= 0; --i) {
            for (int j = i; j < n; ++j) {
                dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 2 || dp[i + 1][j - 1]);
                if (dp[i][j] && (j - i + 1) > res.length()) {
                    res = s.substring(i, j + 1);
                }
            }
        }
        return res;
    }
}
```

中间向外扩散

```java
class Solution {
    private int lo, maxLen;

    public String longestPalindrome(String s) {
        if (s.length() < 2) return s;
        for (int i = 0; i < s.length(); ++i) {
            extendPalindrome(s, i, i); // odd
            extendPalindrome(s, i, i + 1); // even
        }
        return s.substring(lo, lo + maxLen);
    }

    private void extendPalindrome(String s, int j, int k) {
        while (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {
            j--;
            k++;
        }
        if (k - j - 1 > maxLen) {
            lo = j + 1;
            maxLen = k - j - 1;
        }
    }
}
```

### 字符串匹配问题

此类问题一般是给你两个字符串，问你是否匹配、或增加删除修改某个字符后是否能匹配。通常来讲，解法都是**动态规划**。

### [72.编辑距离](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/edit-distance/) ✨

思路：

1. 双端 BFS
2. DP，我们可以用`dp[i][j]`来表示 word1 的前 i 个字符与 word2 的前 j 个字符的编辑距离，我们可以像下面这样画个表格来辅助理解



![img](https://pic1.zhimg.com/80/v2-55b3325cb5683e0d09de5713370d80d4_720w.jpg)



这里给出 DP 方程

```python
if word[i] == word[j]:
    dp[i][j] = dp[i - 1][j - 1]
else:
    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
```

Java 题解

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i <= m; ++i) dp[i][0] = i;
        for (int j = 0; j <= n; ++j) dp[0][j] = j;
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }else {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
            }
        }
        return dp[m][n];
    }
}
```

### [10.正则表达式匹配](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/regular-expression-matching/description/)

思路：

1. 高级DP，`dp[i][j]: S 的前 i 个字符是否能被 P 的前 j 个字符匹配`

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0] = true;
        // s: '', p: '#*#*#*#*#*'
        for (int j = 2; j <= n; j += 2) {
            if (p.charAt(j - 1) == '*' && dp[0][j - 2]) {
                dp[0][j] = true;
            }
        }
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                // s: '####a', p: '####.'
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                // s: '#####a', p: '####a*'
                } else if (p.charAt(j - 1) == '*') {
                    // s: '#####b', p: '####a*'
                    if (p.charAt(j - 2) != '.' && s.charAt(i - 1) != p.charAt(j - 2)) {
                        dp[i][j] = dp[i][j - 2]; // '*' as empty
                    } else {
                        // '*' as 0, 1, multiple
                        dp[i][j] = dp[i][j - 2] || dp[i - 1][j - 1] || dp[i - 1][j];
                    }
                }
            }
        }
        return dp[m][n];
    }
}
```

对于此类问题大家可能拿到之后感觉难以下手，别慌，我自己**总结了字符串匹配类问题的模板**，分享给大家。

### 字符串匹配问题模板

```java
public <T> StringDP(String A, String B) {
    // 1. initializing
    int m = A.length();
    int n = B.length();
    <T>[][] dp = new <T>[m + 1][n + 1];
    dp[0][0] = INIT_VALUE;
    for (int i = 1; j <= m; ++i) {
        Initialize(dp[i][0]);
    }
    for (int j = 1; j <= n; ++j) {
        Initialize(dp[0][j]);
    }
    // 2. Iterating
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (Condition_1) {
                Update(dp[i][j]);
            } else if (Condition_2) {
                if (SubCondition_1) Update(dp[i][j]);
                else Update(dp[i][j]);
            }
            ...
        }
    }
    // 3. Result
    return dp[m][n];
}
```


# 算法的时间与空间复杂度（一看就懂）

算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。

那么我们应该如何去衡量不同算法之间的优劣呢？

主要还是从算法所占用的「时间」和「空间」两个维度去考量。

- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。

因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。

下面我来分别介绍一下「时间复杂度」和「空间复杂度」的计算方式。

## **一、时间复杂度**

我们想要知道一个算法的「时间复杂度」，很多人首先想到的的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。

这种方式可以吗？当然可以，不过它也有很多弊端。
这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系。再者，并我们在写算法的时候，还没有办法完整的去运行呢。

因此，另一种更为通用的方法就出来了：「 **大O符号表示法** 」，即 T(n) = O(f(n))

我们先来看个例子：

```text
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

通过「 大O符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢?

在 大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：**算法的渐进时间复杂度**。

我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)

为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

所以上面的例子中，如果n无限大的时候，T(n) = time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) = O(n) 就可以了。

常见的时间复杂度量级有：

- 常数阶O(1)
- 对数阶O(logN)
- 线性阶O(n)
- 线性对数阶O(nlogN)
- 平方阶O(n²)
- 立方阶O(n³)
- K次方阶O(n^k)
- 指数阶(2^n)

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

下面选取一些较为常用的来讲解一下（没有严格按照顺序）：

1. **常数阶O(1)**

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

```text
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

1. **线性阶O(n)**

这个在最开始的代码示例中就讲解过了，如：

```text
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

1. **对数阶O(logN)**

还是先来看代码：

```text
int i = 1;
while(i<n)
{
    i = i * 2;
}
```

从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n
也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：**O(logn)**

1. **线性对数阶O(nlogN)**

线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。

就拿上面的代码加一点修改来举例：

```text
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

1. **平方阶O(n²)**

平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。
举例：

```text
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)
如果将其中一层循环的n改成m，即：

```text
for(x=1; i<=m; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

那它的时间复杂度就变成了 O(m*n)

1. **立方阶O(n³)**、**K次方阶O(n^k)**

参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。

除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。

## **二、空间复杂度**

既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。

空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：

1. **空间复杂度 O(1)**

如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
举例：

```text
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

1. **空间复杂度 O(n)**

我们先看一个代码：

```text
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)


