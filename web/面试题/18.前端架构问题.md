# OAuth 2.0和JWT的区别

**基于令牌的认证由于会包含认证用户的相关信息，因此可以通过验证令牌来完成用户身份的校验，完全不同于之前基于会话的认证。因此，基于令牌的这个优点，像T微信、支付宝、微博及GitHub等，都推出了基于令牌的认证服务，用于访问所开放的API及单点登录。接下来将重点介绍基于令牌认证方案中的OAuth 2.0和JWT**

## OAuth 2.0

范围是OAuth 2.0中的一种机制，用于限制应用程序对用户帐户的访问。**一个应用程序可以请求一个或多个范围**，然后在同一 屏幕中将此信息呈现给用户，并且颁发给该应用程序的访问令牌将限于所授予的范围。

### **OAuth 2.0客户端授权模式**

生产中一般采用**授权码模式**，简单来说就是你要**重定向**url认证服务器获取授权码（code)，在获取访问令牌。

简单画了一个流程图



![img](https://pic4.zhimg.com/80/v2-8fee285206cee3db36a549768a0cd83b_720w.jpg)

## **JWT**

oken生成的其实**就是一个UUID**，和业务没有丝毫的关系，这样带来最大的问题，就是需要人工持久化处理token（像处理分布式下的sessionId一样）。但是**jwt就不需要，因为自包含，所以token里有身份验证信息**，不需要做后台持久化处理，前端每次请求被保护的资源时请求头里带上该token就可以实现。

使用的签名算法，例如HMAC SHA256或RSA。


# Serverless和FAAS，BAAS有什么区别联系？

**Serverless**：侧重描述一类服务，即，从使用者的角度无需关心背后的计算存储网络内存等实现，也无需关心维护方面。FaaS和BaaS，一定程度来说，都算Serverless。

**FAAS**：**侧重在针对开发通用**application上面，终端客户接触不到。把程序执行的过程，抽象为执行的一个个函数（Function），这些函数可以被打散到各个服务器上去独立执行，开发者只需要实现函数的业务逻辑，无需关注背后的存储网络计算资源等。

**BAAS**：**侧重在针对开发Restful Application**上面，提供可以使用的后端服务，终端客户接触不到。开发者使用这些后端服务就可以轻松开发Application。开发者只需要关注客户端的实现，服务端的实现以及存储网络等都无需关心，是假设云平台可以帮你完成的。

**IAAS**：**侧重在Infrastructure方面**，也就是**计算/内存/存储/网络资源**是被虚拟化的，多个租户可以自由按需分别使用，一般是被IT公司租用。终端客户（比如打开某个app的手机用户）接触不到。例如，云厂商的虚拟机业务。

**SAAS**：**侧重在**终端用户可以用的**Application/Software**是跑在云上的，打开网页即可使用。举例，Gmail，Office365，Google Drive，百度云，Github等等。



解释完名词，来说下关系：

1. **IaaS**是比较底层，其他的一般需要依赖IaaS来实现，
2. **FaaS**和**BaaS**都可以算作**Serverless**，其中FaaS和Serverless最近，算是一种Serverless。BaaS侧重于提供了RESTFul的API接口，但是FaaS并不提供这类接口（当然也可以提供），Serverless也没有说必须要提供RESTFul的API接口（尽管也可以提供）
3. **SaaS**相信很容易理解，开箱即用，就是终端用户可以使用的产品。按使用量收费，比如对于iCloud的备份空间超出5GB是要额外按月购买的。你买一份，那么iCloud就被剥离出去5GB的存储。**注意，**这个和你在爱奇艺上按月订购视频服务是不一样的。区别在于你购买iCloud空间是**一个大的共享资源池的一部分**，而你订购爱奇艺视频，和共享资源池无关，爱奇艺不过是给你发送一份订阅而已，类似于送报纸的逻辑，给你送报纸。iCloud开辟一个空间，更像是一些孵化创业园区的共享办公，划出一个隔间作为A公司的办公室，划出一些隔间作为B公司的办公室，分别按照使用量收钱。



说到底，一句话概括各种云计算业务：

在一个**超大的共享资源池**，**按需租用资源**，而无需关心背后的实现和维护，但是需要按照厂商规定的”姿势“去使用这些资源，往往这些"姿势"都很简单。


# Vue 如何劫持所有的click事件？

vue.mixin实现了个插件，下面只说如何劫持所有click的实现逻辑：

```js
Vue.mixin({
  mounted:function(){
  this.$nextTick(()=>{
       delegateBehavior(this);
       },0)
  }
});
```

mixin会对所有的component有效，在每个渲染完成后我们把当前实例的context传进我们要进行捕获click的函数中。

```js
delegateBehavior(context: any) {
	//在conetxt的$el上做_uid的赋值。
	if (context.$el) {
		context.$el.setAttribute('vueautoreport-uid', context._uid);
	}
    //在root上做标记，不以次数订，可能页面存在多个vue实例.
    if (context.$root.$el && !context.$root.$el._isBindDelegate) {
    	eventTypes.forEach((eventType) => {
            //root组件绑定捕获事件，处理冒泡阻止的情况
            context.$root.$el.addEventListener(eventType, (e: Event) => {
                this.captureEvent(e, this.captureContexts, eventType);
            }, true);
    	})
    	context.$root.$el._isBindDelegate = true;
     }
}
```

首先我把每个component上挂了一个uid的attribute，为了方便我在网页中看到组件结构

然后我们知道每个vue实例的$root代表他的根节点，我们判断一下$root上的$el是否有我们之前绑定过事件的flag，就是isBindDelegate属性，因为这个delegateBehavior是要在每个组件的context上都执行一遍的。

eventTypes目前就只有click一个item，以后可能我们还会捕获其他事件，先做成数组了。

然后我们给$el绑定对应的捕获事件，注意addEventListener的第三个参数我们要设置为true，使用捕获，而不是冒泡captureEvent函数的第二个参数是我记录的所有contexts，这个数组是在vue.mixin的mounted的时候存的。

```js
captureEvent(e: (Event | IntersectionObserverEntry), contexts: Array<any>, eventType: String, ext?: anyExt) {
	let els = contexts.map((context: any) => context.$el);
    let currentEl = e.target as Node;
    while (currentEl) {
        let index = els.indexOf(currentEl);
        if (index > -1) {
            this.emit('logreport', e, contexts, index, eventType, ext);
            break;
        }
        currentEl = currentEl.parentNode;
    }
}
```

之所以用捕获而不是冒泡来进行click劫持，主要是为了避免.stop这种情况无法感知，我们知道vue中的stop或者我们日常开发都是使用冒泡来进行事件代理，大家可以去了解下事件捕获的机制，他是在冒泡之前触发的，所以不会受到影响很适合做这种统计需求。

然后我们看下具体的逻辑，首先我们拿到所有contexts的$el，通过target的node节点和vue的contexts里的$el进行比较，因为contexts的$el都是component的根节点，不一定会匹配到target，所以要从target一直往上找到他所属的component，目的是为了找到这target属于哪个context，主要是拿到那个index。

然后我们把index和contexts还有对应的一些其他东东传给logreport，在logreport广播中进行log的拼装即可。

```js
this.on('logreport', (e: Event, contexts: Array<any>, index: number, eventType: string, ext: anyExt) => {
	let node = this.getVnodeTarget(e.target as Element, contexts[index]._vnode);
    let log = this.behaviorLogInfo({
        target: e.target,
        node,
        context: contexts[index],
        eventType,
        ext
    });
    this.logreport(log);
})
```

通过target，target所属的context的_vnode，我们可以找到这个target的Vnode，方便从这个Vnode上找到vue给他设置的属性，比如node.data.attrs等。

拼装log的方法比较复杂，因为里面还有不少其他逻辑，比如曝光，组件调用栈关系等操作，就不贴了。拦截click的方法基本就是这样实现的。

好处就是可以不受事件冒泡被阻止的影响，除了拿到target的el，我们还能拿到对应的vnode，以便获取更多埋点信息。


# Vue 服务端渲染实践 ——Web应用首屏耗时最优化方案

随着各大前端框架的诞生和演变，`SPA`开始流行，单页面应用的优势在于可以不重新加载整个页面的情况下，通过`ajax`和服务器通信，实现整个`Web`应用拒不更新，带来了极致的用户体验。然而，对于需要`SEO`、追求极致的首屏性能的应用，前端渲染的`SPA`是糟糕的。好在`Vue 2.0`后是支持服务端渲染的，零零散散花费了两三周事件，通过改造现有项目，基本完成了在现有项目中实践了`Vue`服务端渲染。

关于[Vue服务端渲染](https://link.zhihu.com/?target=https%3A//ssr.vuejs.org/)的原理、搭建，官方文档已经讲的比较详细了，因此，本文不是抄袭文档，而是文档的补充。特别是对于如何与现有项目进行很好的结合，还是需要费很大功夫的。本文主要对我所在的项目中进行`Vue`服务端渲染的改造过程进行阐述，加上一些个人的理解，作为分享与学习。

## **概述**

本文主要分以下几个方面：

- 什么是服务端渲染？服务端渲染的原理是什么？

- 如何在基于`Koa`的`Web Server Frame`上配置服务端渲染？

- - 基本用法
- `Webpack`配置



- 开发环境搭建

- - 渲染中间件配置



- 如何对现有项目进行改造？

- 基本目录改造；

- 在服务端用`vue-router`分割代码；

- - 在服务端预拉取数据；
- 客户端托管全局状态；
- 常见问题的解决方案；



## **什么是服务端渲染？服务端渲染的原理是什么？**

> `Vue.js`是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出`Vue`组件，进行生成`DOM`和操作`DOM`。然而，也可以将同一个组件渲染为服务器端的`HTML`字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。

上面这段话是源自[Vue服务端渲染文档](https://link.zhihu.com/?target=https%3A//ssr.vuejs.org/zh/%23%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F)的解释，用通俗的话来说，大概可以这么理解：

- 服务端渲染的目的是：性能优势。 在服务端生成对应的`HTML`字符串，客户端接收到对应的`HTML`字符串，能立即渲染`DOM`，最高效的首屏耗时。此外，由于服务端直接生成了对应的`HTML`字符串，对`SEO`也非常友好；
- 服务端渲染的本质是：生成应用程序的“快照”。将`Vue`及对应库运行在服务端，此时，`Web Server Frame`实际上是作为代理服务器去访问接口服务器来预拉取数据，从而将拉取到的数据作为`Vue`组件的初始状态。
- 服务端渲染的原理是：虚拟`DOM`。在`Web Server Frame`作为代理服务器去访问接口服务器来预拉取数据后，这是服务端初始化组件需要用到的数据，此后，组件的`beforeCreate`和`created`生命周期会在服务端调用，初始化对应的组件后，`Vue`启用虚拟`DOM`形成初始化的`HTML`字符串。之后，交由客户端托管。实现前后端同构应用。

## **如何在基于`Koa`的`Web Server Frame`上配置服务端渲染？**

## **基本用法**

需要用到`Vue`服务端渲染对应库`vue-server-renderer`，通过`npm`安装：

```js
npm install vue vue-server-renderer --save
```

最简单的，首先渲染一个`Vue`实例：

```js
// 第 1 步：创建一个 Vue 实例
const Vue = require('vue');

const app = new Vue({
  template: `<div>Hello World</div>`
});

// 第 2 步：创建一个 renderer
const renderer = require('vue-server-renderer').createRenderer();

// 第 3 步：将 Vue 实例渲染为 HTML
renderer.renderToString(app, (err, html) => {
  if (err) {
      throw err;
  }
  console.log(html);
  // => <div data-server-rendered="true">Hello World</div>
});
```

与服务器集成：

```js
module.exports = async function(ctx) {
    ctx.status = 200;
    let html = '';
    try {
        // ...
        html = await renderer.renderToString(app, ctx);
    } catch (err) {
        ctx.logger('Vue SSR Render error', JSON.stringify(err));
        html = await ctx.getErrorPage(err); // 渲染出错的页面
    }


    ctx.body = html;
}
```

使用页面模板：

当你在渲染`Vue`应用程序时，`renderer`只从应用程序生成`HTML`标记。在这个示例中，我们必须用一个额外的`HTML`页面包裹容器，来包裹生成的`HTML`标记。

为了简化这些，你可以直接在创建`renderer`时提供一个页面模板。多数时候，我们会将页面模板放在特有的文件中：

```js
<!DOCTYPE html>
<html lang="en">
  <head><title>Hello</title></head>
  <body>
    <!--vue-ssr-outlet-->
  </body>
</html>
```

然后，我们可以读取和传输文件到`Vue renderer`中：

```js
const tpl = fs.readFileSync(path.resolve(__dirname, './index.html'), 'utf-8');
const renderer = vssr.createRenderer({
    template: tpl,
});
```

## **Webpack配置**

然而在实际项目中，不止上述例子那么简单，需要考虑很多方面：路由、数据预取、组件化、全局状态等，所以服务端渲染不是只用一个简单的模板，然后加上使用`vue-server-renderer`完成的，如下面的示意图所示：

![img](https://pic2.zhimg.com/80/v2-6a8834d7dbc08f849e8119d242ff2475_720w.jpg)

如示意图所示，一般的`Vue`服务端渲染项目，有两个项目入口文件，分别为`entry-client.js`和`entry-server.js`，一个仅运行在客户端，一个仅运行在服务端，经过`Webpack`打包后，会生成两个`Bundle`，服务端的`Bundle`会用于在服务端使用虚拟`DOM`生成应用程序的“快照”，客户端的`Bundle`会在浏览器执行。

因此，我们需要两个`Webpack`配置，分别命名为`webpack.client.config.js`和`webpack.server.config.js`，分别用于生成客户端`Bundle`与服务端`Bundle`，分别命名为`vue-ssr-client-manifest.json`与`vue-ssr-server-bundle.json`，关于如何配置，`Vue`官方有相关示例[vue-hackernews-2.0](https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue-hackernews-2.0/)

## **开发环境搭建**

我所在的项目使用`Koa`作为`Web Server Frame`，项目使用[koa-webpack](https://link.zhihu.com/?target=https%3A//github.com/shellscape/koa-webpack)进行开发环境的构建。如果是在产品环境下，会生成`vue-ssr-client-manifest.json`与`vue-ssr-server-bundle.json`，包含对应的`Bundle`，提供客户端和服务端引用，而在开发环境下，一般情况下放在内存中。使用`memory-fs`模块进行读取。

```js
const fs = require('fs')
const path = require( 'path' );
const webpack = require( 'webpack' );
const koaWpDevMiddleware = require( 'koa-webpack' );
const MFS = require('memory-fs');
const appSSR = require('./../../app.ssr.js');

let wpConfig;
let clientConfig, serverConfig;
let wpCompiler;
let clientCompiler, serverCompiler;

let clientManifest;
let bundle;

// 生成服务端bundle的webpack配置
if ((fs.existsSync(path.resolve(cwd,'webpack.server.config.js')))) {
  serverConfig = require(path.resolve(cwd, 'webpack.server.config.js'));
  serverCompiler = webpack( serverConfig );
}

// 生成客户端clientManifest的webpack配置
if ((fs.existsSync(path.resolve(cwd,'webpack.client.config.js')))) {
  clientConfig = require(path.resolve(cwd, 'webpack.client.config.js'));
  clientCompiler = webpack(clientConfig);
}

if (serverCompiler && clientCompiler) {
  let publicPath = clientCompiler.output && clientCompiler.output.publicPath;

  const koaDevMiddleware = await koaWpDevMiddleware({
    compiler: clientCompiler,
    devMiddleware: {
      publicPath,
      serverSideRender: true
    },
  });

  app.use(koaDevMiddleware);

  // 服务端渲染生成clientManifest

  app.use(async (ctx, next) => {
    const stats = ctx.state.webpackStats.toJson();
    const assetsByChunkName = stats.assetsByChunkName;
    stats.errors.forEach(err => console.error(err));
    stats.warnings.forEach(err => console.warn(err));
    if (stats.errors.length) {
      console.error(stats.errors);
      return;
    }
    // 生成的clientManifest放到appSSR模块，应用程序可以直接读取
    let fileSystem = koaDevMiddleware.devMiddleware.fileSystem;
    clientManifest = JSON.parse(fileSystem.readFileSync(path.resolve(cwd,'./dist/vue-ssr-client-manifest.json'), 'utf-8'));
    appSSR.clientManifest = clientManifest;
    await next();
  });

  // 服务端渲染的server bundle 存储到内存里
  const mfs = new MFS();
  serverCompiler.outputFileSystem = mfs;
  serverCompiler.watch({}, (err, stats) => {
    if (err) {
      throw err;
    }
    stats = stats.toJson();
    if (stats.errors.length) {
      console.error(stats.errors);
      return;
    }
    // 生成的bundle放到appSSR模块，应用程序可以直接读取
    bundle = JSON.parse(mfs.readFileSync(path.resolve(cwd,'./dist/vue-ssr-server-bundle.json'), 'utf-8'));
    appSSR.bundle = bundle;
  });
}
```

## **渲染中间件配置**

产品环境下，打包后的客户端和服务端的`Bundle`会存储为`vue-ssr-client-manifest.json`与`vue-ssr-server-bundle.json`，通过文件流模块`fs`读取即可，但在开发环境下，我创建了一个`appSSR`模块，在发生代码更改时，会触发`Webpack`热更新，`appSSR`对应的`bundle`也会更新，`appSSR`模块代码如下所示：

```js
let clientManifest;
let bundle;

const appSSR = {
  get bundle() {
    return bundle;
  },
  set bundle(val) {
    bundle = val;
  },
  get clientManifest() {
    return clientManifest;
  },
  set clientManifest(val) {
    clientManifest = val;
  }
};

module.exports = appSSR;
```

通过引入`appSSR`模块，在开发环境下，就可以拿到`clientManifest`和`ssrBundle`，项目的渲染中间件如下：

```js
const fs = require('fs');
const path = require('path');
const ejs = require('ejs');
const vue = require('vue');
const vssr = require('vue-server-renderer');
const createBundleRenderer = vssr.createBundleRenderer;
const dirname = process.cwd();

const env = process.env.RUN_ENVIRONMENT;

let bundle;
let clientManifest;

if (env === 'development') {
  // 开发环境下，通过appSSR模块，拿到clientManifest和ssrBundle
  let appSSR = require('./../../core/app.ssr.js');
  bundle = appSSR.bundle;
  clientManifest = appSSR.clientManifest;
} else {
  bundle = JSON.parse(fs.readFileSync(path.resolve(__dirname, './dist/vue-ssr-server-bundle.json'), 'utf-8'));
  clientManifest = JSON.parse(fs.readFileSync(path.resolve(__dirname, './dist/vue-ssr-client-manifest.json'), 'utf-8'));
}


module.exports = async function(ctx) {
  ctx.status = 200;
  let html;
  let context = await ctx.getTplContext();
  ctx.logger('进入SSR，context为： ', JSON.stringify(context));
  const tpl = fs.readFileSync(path.resolve(__dirname, './newTemplate.html'), 'utf-8');
  const renderer = createBundleRenderer(bundle, {
    runInNewContext: false,
    template: tpl, // （可选）页面模板
    clientManifest: clientManifest // （可选）客户端构建 manifest
  });
  ctx.logger('createBundleRenderer  renderer：', JSON.stringify(renderer));
  try {
    html = await renderer.renderToString({
      ...context,
      url: context.CTX.url,
    });
  } catch(err) {
    ctx.logger('SSR renderToString 失败： ', JSON.stringify(err));
    console.error(err);
  }

  ctx.body = html;
};
```

## **如何对现有项目进行改造？**

## **基本目录改造**

使用`Webpack`来处理服务器和客户端的应用程序，大部分源码可以使用通用方式编写，可以使用`Webpack`支持的所有功能。

一个基本项目可能像是这样：

```js
src
├── components
│   ├── Foo.vue
│   ├── Bar.vue
│   └── Baz.vue
├── frame
│   ├── app.js # 通用 entry(universal entry)
│   ├── entry-client.js # 仅运行于浏览器
│   ├── entry-server.js # 仅运行于服务器
│   └── index.vue # 项目入口组件
├── pages
├── routers
└── store
```

`app.js`是我们应用程序的「通用`entry`」。在纯客户端应用程序中，我们将在此文件中创建根`Vue`实例，并直接挂载到`DOM`。但是，对于服务器端渲染(`SSR`)，责任转移到纯客户端`entry`文件。`app.js`简单地使用`export`导出一个`createApp`函数：

```js
import Router from '~ut/router';
import { sync } from 'vuex-router-sync';
import Vue from 'vue';
import { createStore } from './../store';

import Frame from './index.vue';
import myRouter from './../routers/myRouter';

function createVueInstance(routes, ctx) {
    const router = Router({
        base: '/base',
        mode: 'history',
        routes: [routes],
    });
    const store = createStore({ ctx });
    // 把路由注入到vuex中
    sync(store, router);
    const app = new Vue({
        router,
        render: function(h) {
            return h(Frame);
        },
        store,
    });
    return { app, router, store };
}

module.exports = function createApp(ctx) {
    return createVueInstance(myRouter, ctx); 
}
```

> 注：在我所在的项目中，需要动态判断是否需要注册`DicomView`，只有在客户端才初始化`DicomView`，由于`Node.js`环境没有`window`对象，对于代码运行环境的判断，可以通过`typeof window === 'undefined'`来进行判断。

## **避免创建单例**

如`Vue SSR`文档所述：

> 当编写纯客户端 (client-only) 代码时，我们习惯于每次在新的上下文中对代码进行取值。但是，Node.js 服务器是一个长期运行的进程。当我们的代码进入该进程时，它将进行一次取值并留存在内存中。这意味着如果创建一个单例对象，它将在每个传入的请求之间共享。如基本示例所示，我们为每个请求创建一个新的根 Vue 实例。这与每个用户在自己的浏览器中使用新应用程序的实例类似。如果我们在多个请求之间使用一个共享的实例，很容易导致交叉请求状态污染 (cross-request state pollution)。因此，我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例。同样的规则也适用于 router、store 和 event bus 实例。你不应该直接从模块导出并将其导入到应用程序中，而是需要在 createApp 中创建一个新的实例，并从根 Vue 实例注入。

如上代码所述，`createApp`方法通过返回一个返回值创建`Vue`实例的对象的函数调用，在函数`createVueInstance`中，为每一个请求创建了`Vue`，`Vue Router`，`Vuex`实例。并暴露给`entry-client`和`entry-server`模块。

在客户端`entry-client.js`只需创建应用程序，并且将其挂载到`DOM`中：

```js
import { createApp } from './app';

// 客户端特定引导逻辑……

const { app } = createApp();

// 这里假定 App.vue 模板中根元素具有 `id="app"`
app.$mount('#app');
```

服务端`entry-server.js`使用`default export` 导出函数，并在每次渲染中重复调用此函数。此时，除了创建和返回应用程序实例之外，它不会做太多事情 - 但是稍后我们将在此执行服务器端路由匹配和数据预取逻辑:

```js
import { createApp } from './app';

export default context => {
  const { app } = createApp();
  return app;
}
```

## **在服务端用`vue-router`分割代码**

与`Vue`实例一样，也需要创建单例的`vueRouter`对象。对于每个请求，都需要创建一个新的`vueRouter`实例：

```js
function createVueInstance(routes, ctx) {
    const router = Router({
        base: '/base',
        mode: 'history',
        routes: [routes],
    });
    const store = createStore({ ctx });
    // 把路由注入到vuex中
    sync(store, router);
    const app = new Vue({
        router,
        render: function(h) {
            return h(Frame);
        },
        store,
    });
    return { app, router, store };
}
```

同时，需要在`entry-server.js`中实现服务器端路由逻辑，使用`router.getMatchedComponents`方法获取到当前路由匹配的组件，如果当前路由没有匹配到相应的组件，则`reject`到`404`页面，否则`resolve`整个`app`，用于`Vue`渲染虚拟`DOM`，并使用对应模板生成对应的`HTML`字符串。

```js
const createApp = require('./app');

module.exports = context => {
  return new Promise((resolve, reject) => {
    // ...
    // 设置服务器端 router 的位置
    router.push(context.url);
    // 等到 router 将可能的异步组件和钩子函数解析完
    router.onReady(() => {
      const matchedComponents = router.getMatchedComponents();
      // 匹配不到的路由，执行 reject 函数，并返回 404
      if (!matchedComponents.length) {
        return reject('匹配不到的路由，执行 reject 函数，并返回 404');
      }
      // Promise 应该 resolve 应用程序实例，以便它可以渲染
      resolve(app);
    }, reject);
  });

}
```

## **在服务端预拉取数据**

在`Vue`服务端渲染，本质上是在渲染我们应用程序的"快照"，所以如果应用程序依赖于一些异步数据，那么在开始渲染过程之前，需要先预取和解析好这些数据。服务端`Web Server Frame`作为代理服务器，在服务端对接口服务发起请求，并将数据拼装到全局`Vuex`状态中。

另一个需要关注的问题是在客户端，在挂载到客户端应用程序之前，需要获取到与服务器端应用程序完全相同的数据 - 否则，客户端应用程序会因为使用与服务器端应用程序不同的状态，然后导致混合失败。

目前较好的解决方案是，给路由匹配的一级子组件一个`asyncData`，在`asyncData`方法中，`dispatch`对应的`action`。`asyncData`是我们约定的函数名，表示渲染组件需要预先执行它获取初始数据，它返回一个`Promise`，以便我们在后端渲染的时候可以知道什么时候该操作完成。注意，由于此函数会在组件实例化之前调用，所以它无法访问`this`。需要将`store`和路由信息作为参数传递进去：

举个例子：

```js
<!-- Lung.vue -->
<template>
  <div></div>
</template>

<script>
export default {
  // ...
  async asyncData({ store, route }) {
    return Promise.all([
      store.dispatch('getA'),
      store.dispatch('myModule/getB', { root:true }),
      store.dispatch('myModule/getC', { root:true }),
      store.dispatch('myModule/getD', { root:true }),
    ]);
  },
  // ...
}
</script>
```

在`entry-server.js`中，我们可以通过路由获得与`router.getMatchedComponents()`相匹配的组件，如果组件暴露出`asyncData`，我们就调用这个方法。然后我们需要将解析完成的状态，附加到渲染上下文中。

```js
const createApp = require('./app');

module.exports = context => {
  return new Promise((resolve, reject) => {
    const { app, router, store } = createApp(context);
    // 针对没有Vue router 的Vue实例，在项目中为列表页，直接resolve app
    if (!router) {
      resolve(app);
    }
    // 设置服务器端 router 的位置
      router.push(context.url.replace('/base', ''));
    // 等到 router 将可能的异步组件和钩子函数解析完
    router.onReady(() => {
      const matchedComponents = router.getMatchedComponents();
      // 匹配不到的路由，执行 reject 函数，并返回 404
      if (!matchedComponents.length) {
        return reject('匹配不到的路由，执行 reject 函数，并返回 404');
      }
      Promise.all(matchedComponents.map(Component => {
        if (Component.asyncData) {
          return Component.asyncData({
            store,
            route: router.currentRoute,
          });
        }
      })).then(() => {
        // 在所有预取钩子(preFetch hook) resolve 后，
        // 我们的 store 现在已经填充入渲染应用程序所需的状态。
        // 当我们将状态附加到上下文，并且 `template` 选项用于 renderer 时，
        // 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。
        context.state = store.state;
        resolve(app);
      }).catch(reject);
    }, reject);
  });
}
```

## **客户端托管全局状态**

当服务端使用模板进行渲染时，`context.state`将作为`window.__INITIAL_STATE__`状态，自动嵌入到最终的`HTML` 中。而在客户端，在挂载到应用程序之前，`store`就应该获取到状态，最终我们的`entry-client.js`被改造为如下所示：

```js
import createApp from './app';

const { app, router, store } = createApp();

// 客户端把初始化的store替换为window.__INITIAL_STATE__
if (window.__INITIAL_STATE__) {
  store.replaceState(window.__INITIAL_STATE__);
}

if (router) {
  router.onReady(() => {
    app.$mount('#app')
  });
} else {
  app.$mount('#app');
}
```

## **常见问题的解决方案**

至此，基本的代码改造也已经完成了，下面说的是一些常见问题的解决方案：

- 在服务端没有`window`、`location`对象：

对于旧项目迁移到`SSR`肯定会经历的问题，一般为在项目入口处或是`created`、`beforeCreate`生命周期使用了`DOM`操作，或是获取了`location`对象，通用的解决方案一般为判断执行环境，通过`typeof window`是否为`'undefined'`，如果遇到必须使用`location`对象的地方用于获取`url`中的相关参数，在`ctx`对象中也可以找到对应参数。

- `vue-router`报错`Uncaught TypeError: _Vue.extend is not _Vue function`，没有找到`_Vue`实例的问题：

通过查看`Vue-router`源码发现没有手动调用`Vue.use(Vue-Router);`。没有调用`Vue.use(Vue-Router);`在浏览器端没有出现问题，但在服务端就会出现问题。对应的`Vue-router`源码所示：

```js
VueRouter.prototype.init = function init (app /* Vue component instance */) {
    var this$1 = this;

  process.env.NODE_ENV !== 'production' && assert(
    install.installed,
    "not installed. Make sure to call `Vue.use(VueRouter)` " +
    "before creating root instance."
  );
  // ...
}
```

- 服务端无法获取`hash`路由的参数

由于`hash`路由的参数，会导致`vue-router`不起效果，对于使用了`vue-router`的前后端同构应用，必须换为`history`路由。

- 接口处获取不到`cookie`的问题：

由于客户端每次请求都会对应地把`cookie`带给接口侧，而服务端`Web Server Frame`作为代理服务器，并不会每次维持`cookie`，所以需要我们手动把
`cookie`透传给接口侧，常用的解决方案是，将`ctx`挂载到全局状态中，当发起异步请求时，手动带上`cookie`，如下代码所示：

```js
// createStore.js
// 在创建全局状态的函数`createStore`时，将`ctx`挂载到全局状态
export function createStore({ ctx }) {
    return new Vuex.Store({
        state: {
            ...state,
            ctx,
        },
        getters,
        actions,
        mutations,
        modules: {
            // ...
        },
        plugins: debug ? [createLogger()] : [],
    });
}
```

当发起异步请求时，手动带上`cookie`，项目中使用的是`Axios`：

```js
// actions.js

// ...
const actions = {
  async getUserInfo({ commit, state }) {
    let requestParams = {
      params: {
        random: tool.createRandomString(8, true),
      },
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
      },
    };

    // 手动带上cookie
    if (state.ctx.request.headers.cookie) {
      requestParams.headers.Cookie = state.ctx.request.headers.cookie;
    }

    // ...

    let res = await Axios.get(`${requestUrlOrigin}${url.GET_A}`, requestParams);
    commit(globalTypes.SET_A, {
      res: res.data,
    });
  }
};

// ...
```

- 接口请求时报`connect ECONNREFUSED 127.0.0.1:80`的问题

原因是改造之前，使用客户端渲染时，使用了`devServer.proxy`代理配置来解决跨域问题，而服务端作为代理服务器对接口发起异步请求时，不会读取对应的`webpack`配置，对于服务端而言会对应请求当前域下的对应`path`下的接口。

解决方案为去除`webpack`的`devServer.proxy`配置，对于接口请求带上对应的`origin`即可：

```js
const requestUrlOrigin = requestUrlOrigin = state.ctx.URL.origin;
const res = await Axios.get(`${requestUrlOrigin}${url.GET_A}`, requestParams);
```

- 对于`vue-router`配置项有`base`参数时，初始化时匹配不到对应路由的问题

在官方示例中的`entry-server.js`：

```js
// entry-server.js
import { createApp } from './app';

export default context => {
  // 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise，
  // 以便服务器能够等待所有的内容在渲染前，
  // 就已经准备就绪。
  return new Promise((resolve, reject) => {
    const { app, router } = createApp();

    // 设置服务器端 router 的位置
    router.push(context.url);

    // ...
  });
}
```

原因是设置服务器端`router`的位置时，`context.url`为访问页面的`url`，并带上了`base`，在`router.push`时应该去除`base`，如下所示：

```js
router.push(context.url.replace('/base', ''));
```

## **小结**

本文为笔者通过对现有项目进行改造，给现有项目加上`Vue`服务端渲染的实践过程的总结。

首先阐述了什么是`Vue`服务端渲染，其目的、本质及原理，通过在服务端使用`Vue`的虚拟`DOM`，形成初始化的`HTML`字符串，即应用程序的“快照”。带来极大的性能优势，包括`SEO`优势和首屏渲染的极速体验。之后阐述了`Vue`服务端渲染的基本用法，即两个入口、两个`webpack`配置，分别作用于客户端和服务端，分别生成`vue-ssr-client-manifest.json`与`vue-ssr-server-bundle.json`作为打包结果。最后通过对现有项目的改造过程，包括对路由进行改造、数据预获取和状态初始化，并解释了在`Vue`服务端渲染项目改造过程中的常见问题，帮助我们进行现有项目往`Vue`服务端渲染的迁移。


# vue项目埋点之指令埋点（点击和曝光）

埋点方案有命令式埋点和声明式埋点。

- 命令式埋点：在用户行为触发位置调用事件上报函数进行行为上报，缺点是埋点和业务耦合度比较高，工作量比较大
- 声明式埋点：通过自定义指令统一完成事件上报，使得埋点和业务代码一定程度上解耦合。
  本篇文章将记录借助vue自定义指令完成声明式埋点，降低前端埋点压力。

### **一、准备工作**

这里关于vue自定义指令和IntersectionObserver不做详细介绍，自行前往官网了解学习。

- vue自定义指令，[vue自定义指令官网](https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/custom-directive.html)
- IntersectionObserver实现元素视窗观测，[Intersection Observer API](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API)

### **二、代码实现**

- 创建指令
  这里我们计划创建`v-track`指令，创建代码如下：

```js
import Vue from 'vue'
import Exposure from './exposure'
import Click from './click'

// 实例化曝光和点击
const exp = new Exposure()
const cli = new Click()

Vue.directive('track', {
  // 调用指令声明周期钩子函数bind，其他钩子函数请移步官网
  bind(el, binding) {
    // 获取指令参数
    const { arg } = binding
    arg.split('|').forEach(item => {
      // 点击
      if (item === 'click') {
        cli.add({ el })
      } else if (item === 'exposure') {
        exp.add({ el })
      }
    })
  }
})
```

- 曝光类`exposure.js`
  曝光使用IntersectionObserver观察元素是否在视窗内，并且曝光上报只上报一次，上报之后移除观察。设定每2秒进行一次上报。
  如何解决曝光的漏报（定时器2秒之内的用户退出）和多报：
  a. 漏报：保存localStorage，下次进入之后如果有数据则上报，如果用户再不进入，对漏报的几条数据可忽略
  b. 多报：IntersectionObserver监听曝光，上报时候移除元素的监听

```js
import 'intersection-observer'
import { track } from './sendData'

// 节流时间调整，默认100ms
IntersectionObserver.prototype['THROTTLE_TIMEOUT'] = 300

export default class Exposure {
  constructor(maxNum = 20) {
    this.cacheDataArr = []
    this.maxNum = maxNum
    this._timer = 0
    this._observer = null
    this.init()
  }

  /**
   * 初始化
   */
  init() {
    const self = this
    // 边界处理
    this.trackFromLocalStorage()
    this.beforeLeaveWebview()

    // 实例化监听
    this._observer = new IntersectionObserver(function(entries, observer) {
      entries.forEach((entry) => {
        // 出现在视窗中
        if (entry.isIntersecting) {
          // 清除当前定时器
          clearInterval(this._timer)

          // 获取参数
          const tp = entry.target.attributes['track-params'].value
          // 收集参数统一上报，减少网络请求
          self.cacheDataArr.push(tp)
          // 曝光之后取消观察
          self._observer.unobserve(entry.target)

          if (self.cacheDataArr.length >= self.maxNum) {
            self.track()
          } else {
            self.storeIntoLocalStorage(self.cacheDataArr)
            if (self.cacheDataArr.length > 0) {
              // 2秒上报一次
              self._timer = setInterval(function() {
                self.track()
              }, 2000)
            }
          }
        }
      })
    },
    {
      root: null,
      rootMargin: '0px',
      threshold: 0.5 // 元素出现面积，0 - 1，这里当元素出现一半以上则进行曝光
    })
  }

  /**
   * 给元素添加监听
   * @param {Element} entry 
   */
  add(entry) {
    this._observer && this._observer.observe(entry.el)
  }

  /**
   * 埋点上报
   */
  track() {
    const trackData = this.cacheDataArr.splice(0, this.maxNum)
    track(trackData)
    // 更新localStoragee
    this.storeIntoLocalStorage(this.cacheDataArr)
  }

  /**
   * 存储到localstorage, 防止在设定上报时间内用户退出
   * @param { Arrary } data 
   */
  storeIntoLocalStorage(data) {
    window.localStorage.setItem('cacheTrackData', data)
  }

  /**
   * 首次进入先获取localStorage中的数据，也就是用户上次退出未上报的数据
   */
  trackFromLocalStorage() {
    const cacheData = window.localStorage.getItem('cacheTrackData')
    if (cacheData) {
      track(cacheData)
    }
  }

  /**
   * 用户退出系统时调用方法，需要和客户端同学协商注册事件
   */
  beforeLeaveWebview() {
    // 客户端自定义事件监听上报
  }
}
```

- 点击类`click.js`
  用户的点击行为没有曝光行为频繁，所以简单处理，每次点击进行埋点上报。

```js
import { track } from './sendData'

export default class Click {
  add(entry) {
    const tp = entry.el.attributes['track-params'].value
    entry.el.addEventListener('click', function() {
      track(tp)
    })
  }
}
```

- 上报函数`sendData.js`
  上报函数未具体实现，如果需要提供，后续私信完善。

```js
import config from './config'

/**
 * 事件上报
 * @param {Object} params 
 */
export function track(params) {
   // 这里自己封装fetch或者axios，在拦截器中实现公共参数上报
  console.log(`Track data to server ${config.serverUrl}: ${JSON.stringify(params)}`)
}
```

### **三、使用**

- 引入全局指令

```js
// main.js
import './directives/track'
```

- 页面使用自定义指令完成上报

```js
// 点击事件
<div v-track:click></div>

// 点击事件带参数
<div v-track:click :track-params="12455"></div>

// 曝光事件
<div v-track:exposure></div>

// 曝光事件带参数
<div v-track:exposure :track-params="12455"></div>

// 曝光事件并点击带参数
<div v-track:click|exposure :track-params="12455"></div>
```


# 你的前端项目可能需要重构了

## **什么是重构**

我们开发惯指的 **重构** ，一般都是指技术重构。简单点说就是基于项目进行代码层面的重构。推倒了重新来，老房子扒掉重新造，肯定是有钱了想让自己更舒适，程序代码推倒了重新写，还不是因为代码质量经过长年累月需求迭代，祖传代码越来越难维护，更别说在这个基础上去老树开花，开发一些新功能。（代码太烂，遗留的坑太多，就是程序的拓展性和维护性不好呗画外音，前浪们留下的一堆堆精华 :hankey: ，需要后狼们一铲一铲地拍在 上……）

## **那么问题来了，你的项目到底需不需要重构呢**

考虑到项目重构带来的人力、时间、项目风险等因素，在商业项目中，推倒重来是一个风险高，收益低，吃力不太讨好的事情。而且，推翻之前的项目重做，也不定会写出比以前更好的代码。那为什么还要重构呢，或许我们从业务和团队角度分析能得到一些答案。

### **业务角度分析**

1. 业务转型了，基于原有业务做得系统自然成了前朝遗老，不招人稀罕了，别说重构，废弃都是有可能的。
2. 业务体量变化，原先的技术架构可能对于百人内的团队，性能上瓶颈不明显，但是随着业务体量的上涨，对于产品性能、扩展性、稳定性的要求越来越高，会推动当前产品迭代及重构的需求

### **团队角度分析**

1. 当前技术方案的问题：单签方案是否影响团队开发效率，项目技术方案是否比较陈旧，难以维护，是否存在家属架构及依赖包过于老旧的问题。如果你的项目依赖文件人家官方都已经不维护了，而且官方文档也给出了相关替换方案，那你的项目确实该进行升级、迭代，甚至是换一套新的技术栈进行重构了。
2. 当前项目的代码本身的问题：代码是否基于团队规范标准开发，代码是否有较好的拓展性、健壮性和可维护性。项目代码经过长期迭代，多人轮换，没有规范标准的情况下，代码会变得越来越难维护，一个文件动辄千八百行代码，不用驼峰，不用清晰语义命名，不写代码注释，分分钟逼死强逼症，这样的代码，加个新功能，都要反反复复的翻以前的代码，即使改好了，还有可能因为，之前项目代码不够健壮，报出来其他奇奇怪怪的问题。

## **那前端开发在项目重构中能干点啥呢**

1. 无用的三方库看着不碍眼吗，删掉啊
2. 一些三方库只用了一两次，自写功能成本也不是很高，留着干啥
3. 删除无用变量|无用import 文件
4. 删除用不到的逻辑，精简、抽分通用逻辑
5. 拆分大文件，动辄千八百行的代码文件，不抽分，后期只会越来越多，后期维护成本越来越高，重构代价也越来越大
6. 减少全局样式，采用 css modules 做样式隔离，避免绞尽脑计想命名，也避免跟某个组件库样式冲突
7. 代码结构重构，优化项目工程目录结构，项目迭代下来，会有很多重复的文件目录结构，应该从项目整体角度考虑，合理划分目录结构
8. 代码命名、模块抽分、合理注释总得加一下吧
9. 一些无用的，当时测试用的 console，debugger 看到就删掉呗
10. 做一些必要的依赖升级，项目依赖包一直在升级，为了项目长期稳定的使用依赖包的一些能力，必要的依赖包升级还是有必要的

## **重构时应该注意哪些问题呢**

1. 首先，很认真的问下自己，问下团队相关成员，这个项目是真的需要重构吗，软件迭代是必需的，但是重构真的不是必要的，必要打碎了，重新来过，不一定比之前做的更好
2. 重构时，你要对重构的项目有必要的理解，知道当初这个功能实现的初衷，才能保证重构后的版本，不会有其他不好的影响，建议重构过程中，多看之前的逻辑实现，多问当时参与的人，相关的产品经理、开发，甚至是测试，了解到被注释掉的代码，是否是没用了，真没用了，再扔掉，否则，一刀切，很可能，后期你还得补回来
3. 重构的目的要清楚，你是重构一个组件，一个模块，还是整个系统，整个系统推倒重来，对于任何公司来说都是一个慎重的事情，比较好的做法是，渐进式的重构，把系统切成相互独立的小块，一点一点迭代，可以作为日常迭代，也可以做成专项迭代，看业务需求
4. 架构选型，不一定是什么新，什么流行用什么，得考虑团队或者个人的学习成本，可能这个新技术确实很好，但是现有团队业务开发任务很重，没有必要一步登天，折磨自己，折磨别人，一句话适合自己的才是最好的
5. 明确重构的目的是为了，让项目不像老代码那样臃肿，难以维护，那么定一些标准化的参考规则是很有必要的，最起码保证相当长的时间内，看着像一个正经的项目

## **我个人在重构过程中的一些习惯（仅供参考）**

1. 首先，我会梳理现有项目代码，对照项目页面，给老项目加一点注释标记
2. 创建项目结构 + 功能脑图，项目干了点啥，需要哪些功能一目了然，后期开发，参照起来，安排排期、预估开发进度，个人感觉还挺有用的
3. 标记问题，老项目缺少注释，文件结构混乱是常有的事儿，遇到不理解的，多思多问是个好习惯，提前把风险点记录下来，可以用来评估，这个项目重构带来的结果是不是正向的
4. 参照通用规范，梳理开发标准，像 css、js 的变量命名，模块抽分标准这样还是要有个可参考的开发标准的
5. 基础技术栈统一，一个项目js、ts 混着用，可能是不好的，鉴于现在前端的发展趋势，大方向上使用 ts 会是未来几年的大趋势，也避免了 js 弱类型带来的一些负面影响，样式管理的话，我这边采用的是 less + css module 来做，这样命名相对清晰，也不会造成样式文件相互影响

总后，总结一句话，鞋合不合适，只有脚知道。总不能自己给自己穿小鞋儿是不是。项目重构是不可避免的，但不一定是必要的，没必要为了炫技或者 OKR 来做一些吃力不讨好的事情。


## 前端vue单页面框架分模块打包

这个架构是把社会治理统一平台当做一个工程，平台里面的子系统当做业务模块。是基于webpack，将模块拆分成基础模块和 N 个业务模块，基础模块作为业务模块插槽，业务模块则独立开发和更新，并且业务模块使用时为懒加载。

1. 用户体验和单页项目一致（本身就是单页）。
2. 负责不同模块的小组技术栈甚至代码风格是一致的，能更好应对紧急情况下的人员调动。

虽然可能由不同小组负责不同业务模块，但技术选型、代码风格和打包都依赖于基础模块，所以规范方面都是可以在基础模块严格控制的。

## 前端架构可以解决的问题

1. 在一个工程的基础上模块可以独立打包，独立开发和更新，解决工程包很大，每次一起发布的问题
2. 公共资源可以独立打包
3. 基础工程和业务模块可以共享组件
4. 有基础模块加载业务模块路由，可以后台控制加载的路由
5. 在平台中的子系统没有独立的打算，所以架构设计把每个子系统以业务模块的形式存在

## 工程构建的步骤

该架构下，工程的完整打包流程为如下所示：
1. `npm run dll`为打包公共资源文件，构建后的目录`dll`，只有第一次打包时需要。
2. `npm run mod xxx`为打包模块`xxx`为模块名称，构建后的目录`modules`，业务模块改变后才需要重新打包。
3. `npm run build`为打包基础模块，构建后的目录`dist`，基础模块改变后才需要重新打包。
5. 除去第一次构建外，每次业务模块更新版本打包后可以替换对应的业务模块。

## 路由配置说明

1. 业务模块中通过`registeredRouter`方法进行路由注册，具体方法封装在`@/utils/module`中
3. 前端路由可以通过后端配置进行权限控制，具体json例子在`static/base.json`中
```json
{
  "menuList": [
	{
      "id":"0",
      "title":"全景数据",
      "path":"map/fullView"
    }
  ]
}
```
4. 路由注册查找规则是根据配置的`path`的值`map/fullView`，通过根目录`map`去匹配模块，所以根目录的名称要和模块名称一致
5. 每次登录通过`permission.js`查询路由权限，动态加载路由

## 业务模块打包配置说明

1. 业务模块打包配置文件`webpack.mod.conf.js`
2. 要实现分模块打包首先不能让webpack识别否则会打包到一起，所以最后使用requirejs的方式引入模块
3. 配置`libraryTarget`，通过打包库文件的方式进行模块打包，这时需要一个入口文件`index.js`，里面可以配置路由，store等等


## 其他注意事项

1. 在业务模块vue文件中不能引入`路由文件`否则会打包路由位置的相应模块到业务模块目录

# 前端如何实现整套视频直播技术流程

目录大纲：

1. 直播技术的简单介绍
2. 前端搭建使用的技术
3. 实践效果
4. 后续需要深入的地方

## 简介：

首先说明，本篇文章是概念+实践，对于希望了解和实践一个简单的摄像头直播网页功能的人会有帮助，由于篇幅和实践深入度有限，目前demo效果只支持直播播放电脑端以及常用摄像头的实时视频流，其他复杂的功能（例如视频信息实时处理，高并发，网络分发等）尚未实现，还需要进一步探索。

## 正文：

下面按照目录大纲来一个一个讲解:

## 1. 直播技术的介绍

直播技术涵盖很广，现如今大家广泛了解的就有视频网站的个人直播、手机直播、安防方面的摄像头监控等会使用到直播的技术；

下面先出一张概念图，介绍直播流程中的各个技术环节。可以理解分为采集端、流媒体服务器以及播放端；还需要了解什么是推流，什么是拉流。



![img](https://pic3.zhimg.com/80/v2-16bc8b4334a9508c8585c21f7d7f38f6_720w.jpg)



- 采集端：顾名思义是视频的源头，视频的采集一般都是从真实的摄像头中得到的。例如移动端设别、PC端设备的摄像头以及一些摄像头设备
- 流媒体服务器：流媒体服务器是整个直播技术框架的非常重要的一环，它需要接收从采集端推上来的视频流，然后将该视频流再推送到播放端
- 播放端：播放端就是各种app，网页中的播放器，拉取流媒体服务器上的视频流，然后进行转码，最终播放出来
- 推流:把采集阶段收集的数据封装好传输到服务器的过程
- 拉流:服务器已有直播内容,用指定地址进行拉去的过程

既然需要推流和拉流, 就必然涉及到视频流的传输,所以接下来介绍常用的流媒体传输协议 常用的流媒体传输协议有RTMP,RTSP,HLS,HTTP-FLV

- RTMP:(可用于推流端和拉流端) Real Time Messaging Protocol 实时消息传输协议，RTMP协议中，视频必须是H264编码，音频必须是AAC或MP3编码，且多以flv格式封包。因为RTMP协议传输的基本是FLV格式的流文件，必须使用flash播放器才能播放.
- RTSP:(用于推流端) Real-Time Stream Protocol，RTSP 实时效果非常好，适合视频聊天、视频监控等方向
- HLS(用于拉流端) Http Live Streaming，由Apple公司定义的基于HTTP的流媒体实时传输协议。传输内容包括两部分：1.M3U8描述文件，2.TS媒体文件。TS媒体文件中的视频必须是H264编码，音频必须是AAC或MP3编码。数据通过HTTP协议传输。目前video.js库支持该格式文件的播放
- HTTP-FLV(用于拉流端) 本协议就是http+flv,将音视频数据封装成FLV格式,然后通过http协议传输到客户端,这个协议大大方便了浏览器客户端播放直播视频流.目前flv.js库支持该格式的文件播放

有了以上基本概念之后，我们就大致知道要搭建一个拥有直播功能的页面需要哪些东西了，下面就基于这个架构进行各个部分的实现

## 2. 前端搭建使用的技术

- 搭建流媒体服务

提到流媒体服务器,其实作为开发前端的人来说,本人一开始也是无所适从的,不知道这个东西该怎么实现或者要用什么语言去写.首先想到的肯定是搜索现有的实现技术,看看是否能够通过纯前端去实现,纯JS技术的话,肯定首先想到了node.js,于是就使用node.js+视频流媒体技术实现方案的关键词去搜索,获得了一个看着比较靠谱的结果:NodeMediaServer,然后去看介绍发现是基于node去实现的一个开源的流媒体服务器,虽然最新版本已经使用go去重构了,但是毕竟历史上它是由node来开发的,所以决定看文档试一试搭建一个这样的服务器.NodeMediaServer官网:

> [http://www.nodemedia.cn/](https://link.zhihu.com/?target=http%3A//www.nodemedia.cn/)

NodeMediaServer支持：以rtmp,rtsp,hls协议拉进行推流，支持http-flv,ws-flv来进行拉流，也就是支持浏览器端使用http或websocket传输flv格式的视频流进行播放

开始搭建流媒体服务器:

- 下载对应的安装包,使用的Linux环境

下载:

```js
wget https://cdn.nodemedia.cn/nms/3.2.12/nms-linux-amd64-20200222.tar.gz
```

解压:

```js
tar -zxvf nms-linux-amd64-20200222.tar.gz
```

到解压后的目录下,执行命令,启动服务

- 在控制台输入 ./nms运行
- 在当前程序目录下执行 sudo ./service.sh install 安装服务并自动运行
- 在当前程序目录下执行 sudo ./service.sh uninstall 停止并卸载服务

服务成功启动之后,可以在8000端口(默认端口)访问流媒体服务的后台系统,这里面大概长下面这个样子:



![img](https://pic3.zhimg.com/80/v2-b3e0b633ddf89bf83877907bb6c59666_720w.jpg)



首页dashboard展示了服务器cpu的使用情况以及网络带宽状况

- 服务启动之后,接下来要做的是推流

怎么推流?这里涉及到一个很强大的东西ffmpeg,它是可以用来记录、转换数字音视频，并将其转化为流的开源软件,通过它可以进行视频的采集封装成流，并推送到流媒体服务器,例如在mac上面安装了这个软件之后,可以通过它调用摄像头,并将摄像头数据封装成流后推送到流媒体服务器,这个过程就是推流.ffmpeg还可以推送本地的视频文件到流媒体服务器.



使用ffmpeg进行mac本地摄像头实时推流到nodeMediaServer:

```js
ffmpeg -f avfoundation -video_size 1280x720 -framerate 30 -i 0:0 -vcodec libx264 -preset veryfast -f flv http://ip:8000/live/stream.flv
```

这里涉及到ffmpeg工具，上面的参数不逐一解释，只是最重要的几个：

- -vide_size 表示要输出的视频画面的分辨率尺寸
- -f 后面的参数 flv表述输出的格式，再后面的地址 [http://ip:8000/live/stream.flv](https://link.zhihu.com/?target=http%3A//ip%3A8000/live/stream.flv) 表示想要输出的地址，这个地址的stream.flv可以按照自己需求随意修改，保持后缀是你需要的flv格式即可

另外一种常用的场景是直接拉去摄像头设备中的视频流数据,这种方式,nodeMediaServer也支持,只需要在管理后台配置对应的摄像头的配置信息,就可以进行推流操作了.这些配置信息包括ip,登录用户名和密码等,配置界面如下所示:

预设配置:



![img](https://pic4.zhimg.com/80/v2-b8784970884b248880ff14355a88dd63_720w.jpg)



还可以自定义设定配置，如果使用的是自定义的摄像头，具备rtsp传输功能的，就可以使用西面的配置方式进行摄像头信息的配置，指定输出流地址，这样直接从浏览器端就可以通过这个输出流地址进行视频的播放:



![img](https://pic4.zhimg.com/80/v2-f9ca529c60f162828d321b282bb66fcf_720w.jpg)



- 前端页面支持播放视频流

前端页面部分，首要目标是找到支持http-flv和ws-flv协议格式的前端播放器，首先去观察了B站的直播,发现他们的直播页面是使用的video标签，后来进一步发掘，才知道他们用的是自己开源的flv.js库，这是一个支持在浏览器端进行http-flv及ws-flv格式的视频流进行播放的播放器,正好是播放直播视频流需要的

视频流有了，那么就可以使用flv.js来搭建页面demo，查看实际效果了

## 3. 实践效果

- 首先搞定推流:

分别实验了直接从mac上推摄像头的视频流数据以及绑定摄像头设备地址信息，通过nodeMediaServer进行推流和拉流服务.

- 然后是前端页面进行视频流的播放,下面是播放器部分的核心代码:

> live-demo.js

```js
import * as React from 'react';

import { Button, Input, Row, Col } from 'react-x-component';
import flv from 'flv.js';

const { useState, useEffect } = React;

interface LiveDemoProps {
    defaultUrl?: string,
    onUrlChange?: Function
}

export default function LiveDemo({ defaultUrl = 'http://ip:8000/live/stream.flv', onUrlChange }: LiveDemoProps) {

    let player = null;
    let playerDom = null;
    
    const [liveUrl, setLiveUrl] = useState(defaultUrl);
    
    useEffect(() => {
        if (flv.isSupported) {
            player = flv.createPlayer({
                type: 'flv',
                isLive: true,
                hasAudio: false,
                hasVideo: true,
                url: liveUrl,
                cors: true
            }, {
                enableWorker: false,
                lazyLoadMaxDuration: 3 * 60,
                seekType: 'range'
            });
            player.attachMediaElement(playerDom);
            player.load();
    
        } else {
            console.log('Your browser is not support flv.js');
        }
    }, []);
    
    function updatePlayer() {
        if (player) {
            player.unload();
            player.detachMediaElement();
            player.destroy();
            player = null;
        }
    
        player = flv.createPlayer({
            type: 'flv',
            isLive: true,
            hasAudio: false,
            hasVideo: true,
            url: liveUrl,
            cors: true
        }, {
            enableWorker: false,
            lazyLoadMaxDuration: 3 * 60,
            seekType: 'range'
        });
        player.attachMediaElement(playerDom);
        player.load();
    }
    
    return (
        <div className='live-demo'>
            <div className="modify-url">
                <Row>
                    <Col md={6}>
                        <Input
                            value={liveUrl}
                            onChange={(value) => {
                                setLiveUrl(value);
                            }}
                        />
                    </Col>
                    <Col md={6}>
                        <Button
                            type={'primary'}
                            onClick={() => {
                                updatePlayer();
                                onUrlChange && onUrlChange(liveUrl);
                            }}
                        >修改</Button>
                    </Col>
                </Row>
            </div>
            <video
                style={{ width: '100%', height: '100%' }}
                controls
                className='video-demo'
                ref={(e) => playerDom = e}
            ></video>
        </div>
    );
}
```

- 播放摄像头的视频流效果,右边是直接获取的摄像头数据流,右边是通过mac电脑推的实时的摄像头画面:



![img](https://pic1.zhimg.com/80/v2-bba70538e78dcfc582d9d3c75f2e1d20_720w.jpg)



OK，这样就搞定了一整套直播网页需要的前后端技术服务的搭建了！

### 4. 后续需要继续继续实践和探索的内容

上面的示例相对而言还过于简单，只是借助了第三方的技术和框架搭建了一个流媒体服务器，和前端支持播放视频流的播放页面，并通过摄像头采集数据，推流，打通了整个流程，形成了一个闭环，但是还有很多内容需要进一步深入：

- 视频信息实时处理，如何添加更多的信息
- 高并发场景是如何去实现的，流媒体服务器这块的实现还是过于简单，肯定还有需要分发处理的机制
- 浏览器播放性能需要进行压力测试

# 前端网络安全

## 一、xss跨站脚本攻击

### 1、类型

​	     1）反射型：通过网络请求参数中加入恶意脚本，解析后执行触发。

​	     2）文档型：请求传输数据中截取网络数据包，对html代码插入再返回。

​	     3）存储型：通过输入发送到服务端存储到数据库。

### 2、防范措施

​     	1）对用户输入进行过滤或转码。

​         2）csp(内容安全策略)。

​			  使CSP可用, 你需要配置你的网络服务器返回 HTTP头部

```javascript
	 Content-Security-Policy: policy
	 policy参数是一个包含了各种描述你的CSP策略指令的字符串
```

```html
	 除此之外,  <meta>  元素也可以被用来配置该策略, 例如
	 <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```

​			 参考资料：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP

​         3)   cookie中httpOnly。

​				JavaScript {{domxref（“ Document.cookie”）}} API 无法访问带有 `HttpOnly` 属性的cookie；此类 Cookie 仅作用于服务器。例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 `HttpOnly` 属性。



## 二、csrf跨站请求伪造，利用当前登录状态发起跨站请求

## 1、CSRF攻击原理及过程

​		  1）用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；

​		  2）在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；

​		  3）用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；

​		  4）网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；

​		  5）浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。

### 2、类型

​	     1）自动发起get请求：改了类似图片src代码。

​	     2）自动发起post请求：恶意插入表单脚本进行提交。

​	     3）主动发起get请求：放入一个恶意链接提供点击。



### 3、防范措施

​     	1）cookie的SameSite属性，`SameSite` Cookie 允许服务器要求某个 cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击。

​			SameSite 可以有下面三种值：

- **None**。浏览器会在同站请求、跨站请求下继续发送 cookies，不区分大小写。
- **`Strict`。**浏览器将只在访问相同站点时发送 cookie。
- **`Lax`。**与 **`Strict`** 类似，但用户从外部站点导航至URL时除外。 在新版本浏览器中，为默认选项，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者 frames 的调用，但只有当用户从外部站点导航到URL时才会发送。如 link 链接
- 参考资料：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies

​		 2）验证来源站点，请求头中加入两个字段：origin域名信息和referer具体的url路径，检查是否是正常页面过来的请求

```javascript
Origin: https://developer.mozilla.org
Referer: https://developer.mozilla.org/en-US/docs/Web/JavaScript
```

​		 3）csrf 增加token验证

-  csrf在ajax提交的时候通过请求头传递的给后台的
-  csrf在前端的key为：X-CSRFtoken，到后端的时候进行验证
-  csrf在form中提交的时需要在前端form中添加{%csrftoken%}



## 三、中间人攻击

### **1、什么是中间人攻击？**

当数据传输发生在一个设备（PC/手机）和网络服务器之间时，攻击者使用其技能和工具将自己置于两个端点之间并截获数据；尽管交谈的两方认为他们是在与对方交谈，但是实际上他们是在与干坏事的人交流，这便是中间人攻击。

攻击方式：

- **嗅探**：嗅探或数据包嗅探是一种用于捕获流进和流出系统/网络的数据包的技术。网络中的数据包嗅探就好像电话中的监听。记住，如果使用正确，数据包嗅探是合法的；许多公司出于“安全目的”都会使用它。

- **数据包注入**：在这种技术中，攻击者会将恶意数据包注入常规数据中。这样用户便不会注意到文件/恶意软件，因为它们是合法通讯流的一部分。在中间人攻击和拒绝式攻击中，这些文件是很常见的。

- **会话劫持**：你曾经遇到过“会话超时”错误吗？如果你进行过网上支付或填写过一个表格，你应该知道它们。在你登录进你的银行账户和退出登录这一段期间便称为一个会话。这些会话通常都是黑客的攻击目标，因为它们包含潜在的重要信息。在大多数案例中，黑客会潜伏在会话中，并最终控制它。这些攻击的执行方式有多种。

- **SSL剥离**：SSL剥离或SSL降级攻击是MiTM攻击的一种十分罕见的方式，但是也是最危险的一种。众所周知，SSL/TLS证书通过加密保护着我们的通讯安全。在SSL剥离攻击中，攻击者使SSL/TLS连接剥落，随之协议便从安全的HTTPS变成了不安全的HTTP。

### 2、防范措施



- 确保在URL前你所访问的网站有HTTPS
- 点击电子邮件前，检查电子邮件的发件人
- 如果你是一个网站管理员，你应当执行HSTS协议
- 不要在公共Wi-Fi网络上购买或发送敏感数据
- 确保你的网站没有任何混合内容
- 如果你的网站使用了SSL，确保你禁用了不安全的SSL/TLS协议。你应当只启用了TLS 1.1和TLS 1.2
- 不要点击恶意链接或电子邮件
- 不要下载盗版内容
- 将安全工具正确地安装在系统上



# 大型项目前端架构浅谈

目录：

- 1、综合

- - 1.1、使用场景
- 1.2、核心思想
- 1.3、切入角度
- 1.4、其他

- 2、基础层设计

- - 2.1、自建Gitlab
- 2.2、版本管理
- 2.3、自动编译发布Jenkins
- 2.4、纯前端版本发布
- 2.5、统一脚手架
- 2.6、Node中间层
- 2.7、埋点系统
- 2.8、监控和报警系统
- 2.9、安全管理
- 2.10、Eslint
- 2.11、灰度发布
- 2.12、前后端分离
- 2.13、Mock
- 2.14、定期备份

- 3、应用层设计

- - 3.1、多页和单页
- 3.2、以应用为单位划分前端项目
- 3.3、基础组件库的建设
- 3.4、技术栈统一
- 3.5、浏览器兼容
- 3.6、内容平台建设
- 3.7、权限管理平台
- 3.8、登录系统设计（单点登录）
- 3.9、CDN
- 3.10、负载均衡
- 3.11、多端共用一套接口

- 4、总结

## 1、综合

本篇文章不会更多侧重于具体技术实现，而是尝试从更高角度出发，分析为什么要这么做，这些设计能解决什么问题，成本和收益如何。

### 1.1、适用场景：

本篇文章，适用于单个/多个大型项目、拥有超过10个以上的前端开发的场景。

前端项目的规模不同，成本收益比也会有所差别。通常来说，人员越多、项目复杂度越高，那么收益/成本的比值越大。

对于人数较少、项目简单的开发团队，可能有部分措施不适用，因此应该根据具体情况来选用。

### 1.2、核心思想：

【1】解决问题：前端架构的设计，应是用于解决已存在或者未来可能发生的技术问题，增加项目的可管理性、稳定性、可扩展性。

【2】人效比：对于需要额外开发工作量的事务（本文中存在一些需要一定开发量的内容），我们在决定是否去做的时候，应该考虑到两个要素：第一个是花费的人力成本，第二个是未来可能节约的时间和金钱、避免的项目风险与资损、提高对业务的支撑能力以带来在业务上可衡量的更高的价值、以及其他价值。

【3】定性和定量：架构里设计的内容，一定要有是可衡量的意义的，最好是可以定量的——即可以衡量带来的收益或减少的成本，至少是可以定性的——即虽然无法用数字阐述收益，但我们可以明确这个是有意义的，例如增加安全性降低风险。

【4】数据敏感：专门写这一条强调数据作为依据的重要性。当我们需要说服其他部门/上级管理者，以推动我们设计的内容时，只有数据——特别是跟钱有关的数据，才是最有说服力的证明。

本文很难直接给出定量的值，因此建议架构设计者，先确保项目中设计使用2.7里的埋点系统，根据埋点系统获取的数据，对项目效果进行定量分析，并以此写成PPT和其他部门/上级管理者进行协调。

### 1.3、切入角度：

分为基础层和应用层。

基础层偏基础设施建设，与业务相关性较低。

应用层更贴近用户，用于解决某一个问题。

部分两个都沾边的，根据经验划分到其中一个。

### 1.4、其他

由于已经谈到架构层级，因此很多内容，并不仅仅只属于前端领域，有很多内容是复合领域（前端、后端、运维、测试），因此需要负责架构的人，技术栈足够全面，对未来发展有足够的前瞻性。

文章的内容结构为：【项目】—>【解决的问题和带来的好处】—>【项目的实际意义】

## 2、基础层设计

### 2.1、自建Gitlab

这个是基础的基础了。本不应该提的，不过考虑到我最近面试的几家公司，有的公司（人数并不少）并没有使用Gitlab，因此专门提一下，并且使用这个的难度非常低。

强烈建议使用Gitlab进行版本管理，自建Gitlab难度并不大，方便管理，包括代码管理、权限管理、提交日志查询，以及联动一些第三方插件。

意义：

公司代码是公司的重要资产，使用自建Gitlab可以有效保护公司资产。

### 2.2、版本管理

版本管理的几个关键点：

- 发布后分支锁死，不可再更改：指当例如0.0.1版本成功发布后，不可再更改0.0.1分支上的代码，否则可能会导致版本管理混乱。
- 全自动流程发布；指应避免开发者提交后，手动编译打包等操作，换句话说，开发人员发布后，将自动发布到预发布/生产环境。开发人员不和相关环境直接接触。实现这个需要参考下面的2.3。
- 多版本并存；指当例如发布0.0.2版本后，0.0.1版本的代码应仍保存在线上（例如CDN），这样当出现线上bug时，方便快速回滚到上一个版本。

意义：

提高项目的可控性。

### 2.3、自动编译发布Jenkins

这个工具用于在代码发布后，执行一系列流程，例如自动编译打包合并，然后再从Gitlab发布到CDN或者静态资源服务器。

使用这个工具，可以让一般研发人员不关心代码传到Gitlab后会发生什么事情，只需要专心于开发就可以了。

意义：

让研发人员专心于研发，和环境、运维等事情脱钩。

### 2.4、纯前端版本发布

纯前端版本发布分为两步：

- 前端发布到生产环境——此时可以通过外网链接加正确的版本号访问到新版本的代码，但页面上的资源还是旧版本；
- 前端通过配置工具（或者是直接更新html文件），将html中引入的资源，改为新版本。

解决的问题是：当前端需要发布新版本时，可以不依赖于后端（根据实际情况，也可以不依赖于运维）。毕竟有很多需求并不需要后端介入，单纯改个前端版本后就要后端发布一次，显然是一件非常麻烦的事情。

这个需要专门的工具，用于配置版本发布，我最近就在写这个。

意义：

提高发布效率，降低发布带来的人员时间损耗（这些都是钱），也可以在前端版本回滚的时候，速度更快。

### 2.5、统一脚手架

适用场景：有比较多独立中小项目。好处：

- 可以减少开发人员配置脚手架带来的时间损耗（特殊功能可以fork脚手架后再自行定制）；
- 统一项目结构，方便管理，也降低项目交接时带来的需要熟悉项目的时间；
- 方便统一技术栈，可以预先引入固定的组件库；

意义：

提高开发人员在多个项目之间的快速切换能力，提高项目可维护性，统一公司技术栈，避免因为环境不同导致奇怪的问题。

### 2.6、Node中间层

适用场景：需要SEO且前端使用React、vue，或前端介入后端逻辑，直接读取后端服务或者数据库的情况。

- SEO：仁者见仁智者见智，虽然很多公司已经不做了，但通常认为，还是有一定意义的（特别是需要搜索引擎引流的时候），因此React或者Vue的同构是必须的。并且同构还可以降低首页白屏时间；
- 前端读取后端服务/数据库：好处是提高前端的开发效率和对业务的支持能力，缺点是可能导致P0级故障。

意义：

让前端可以侵入后端领域，质的提升对业务的支持能力。

### 2.7、埋点系统

强烈推荐前端做自己的埋点系统。这个不同于后端的日志系统。

前端埋点系统的好处：

- 记录每个页面的访问量（日周月年的UV、PV）；
- 记录每个功能的使用量；
- 捕捉报错情况；
- 图表化显示，方便给其他部门展示；

埋点系统是前端高度介入业务，把握业务发展情况的一把利剑，通过这个系统，我们可以比后端更深刻的把握用户的习惯，以及给产品经理、运营等人员提供准确的数据依据。当有了数据后，前端人员就可以针对性的优化功能、布局、页面交互逻辑、用户使用流程。

埋点系统应和业务解耦，开发人员使用时注册，然后在项目中引入。然后在埋点系统里查看相关数据（例如以小时、日、周、月、年为周期查看）[原创水印-作者：零零水(王冬)，微信：qq20004604]。

意义：

数据是money，数据是公司的生命线，数据是最好的武器。

### 2.8、监控和报警系统

监控和报警系统应基于埋点系统而建立，在如以下场景时触发：

- 当访问量有比较大的变化（比如日PV/UV只有之前20%以下）时，自动触发报警，发送邮件到相关人员邮箱；
- 比如报错量大幅度上升（比如200%或更高），则触发报警；
- 当一段时间内没有任何访问量（不符合之前的情况），则触发报警；
- 每过一段时间，自动汇总访问者/报错触发者的相关信息（例如系统、浏览器版本等）；

建设这个系统的好处在于，提前发现一些不容易发现的bug（需要埋点做的比较扎实）。有一些线上bug，因为用户环境特殊，导致无法被开发人员和测试人员发现。但其中一部分bug又因为不涉及资金，并不会导致资损（因此也不会被后端的监控系统所发现），这样的bug非常容易影响项目里某个链路的正常使用。

意义：

提高项目的稳定性，提高对业务的把控能力。降低bug数，降低资损的可能性，提前发现某些功能的bug（在工单到来之前）。

### 2.9、安全管理

前端的安全管理，通常要依赖于后端，至于只跟单纯有关系的例如dom.innerHTML= 'xxx '这种太基础，就不提了。

安全管理的很难从架构设计上完全避免，但还是有一定解决方案的，常见安全问题如下：

- XSS注入：对用户输入的内容，需要转码（大部分时候要server端来处理，偶尔也需要前端处理），禁止使用eval函数；
- https：这个显然是必须的，好处非常多；
- CSRF：要求server端加入CSRF的处理方法（至少在关键页面加入）；

意义：

减少安全漏洞，避免用户受到损失，避免遭遇恶意攻击，增加系统的稳定性和安全性。

### 2.10、Eslint

Eslint的好处很多，强烈推荐使用：

- 降低低级bug（例如拼写问题）出现的概率；
- 增加代码的可维护性，可阅读性；
- 硬性统一代码风格，团队协作起来时更轻松；

总的来说，eslint推荐直接配置到脚手架之中，对我们提高代码的可维护性的帮助会很大。可以考虑在上传到gitlab时，硬性要求eslint校验，通过的才允许上传。

意义：

提高代码的可维护性，降低团队协作的成本。

### 2.11、灰度发布

灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如1~5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量极大的页面。

好处有以下几点：

- 生产环境比开发环境复杂，灰度发布时可以在生产环境小范围尝试观察新版本是否可以正常运行，即使出问题，也可以控制损失。
- 对于大版本更新，可以先灰度一部分，观察埋点效果和用户反馈（即所谓的抢先试用版）。假如效果并不好，那么回滚到老版本也可以及时止损；
- 当我们需要验证某些想法或问题的时候，可以先灰度一部分，快速验证效果如何，然后查漏补缺或者针对性优化；

灰度发布通常分为多个阶段：【1】1%；【2】5~10%；【3】30~50%；【4】全量推送（100%）。灰度发布一定要允许配置某些IP/账号访问时，可以直接访问到灰度版本。

意义：

降低风险，提高发布灵活度。

### 2.12、前后端分离

这个并不是指常见的前后端分离，而是指在分配前后端管控的领域。

中小项目常见的情况是后端只提供接口和让某个url指向某个html，前端负责html、css、js等静态资源。

但大型项目并不建议这么做，建议前端负责除html以外的静态资源，而html交给后端处理，理由有很多：

- 后端进行渲染，方便统一插入一些代码和资源，例如埋点js，监控js，国际化文本资源，页面标识符等。这些通常是后端通过调用某些服务直接写入的；
- 当页面需要统一的头尾时（参考淘宝里我的淘宝页面），前端不应该关注这些跟当前页面无关的东西；
- 某些东西，如果通过html来管理，那么耦合度太高了，违背了解耦和分离的原则；
- 前端版本发布在后端引入某种功能模块后，可以从单独的页面控制前端发布内容，比更新html更方便，也利于灰度发布；

意义：

更规范的进行页面管理，降低页面和功能的耦合度，减少复杂页面的环境配置时间。

### 2.13、Mock

Mock也是常见前端系统之一，用于解决在后端接口未好时，生成返回的数据。

我个人不太建议开发一个专门的系统来Mock，更好的Mock手法是直接嵌入到脚手架之中。思路如下：

- 当在开发环境下，访问链接通常是localhost:8000/index.html，此时加入后缀 ?debug=true；
- 封装好的异步请求在发现当前链接有以上标志时，认为是测试环境，访问/userinfo 时，不去读取线上的数据（因为也读取不到），去本地环境读取 src/test_ajax/userinfo.json，并将内容返回给用户；
- 异步请求正常拿到数据，在页面中显示；
- 当线上接口可以获取到数据后，从network里找到返回的数据，放入/ src/test_ajax/userinfo.json中，此时再次本地调试的话，相当于使用的是线上的真实数据。

这种处理，可以降低mock的复杂度，随时更改mock时返回的数据，比单独开发一个mock系统性价比更高。

意义：

在前后端并行开发时，降低沟通交流成本，方便开发完毕后直接对接。

### 2.14、定期备份

备份是常被忽略的一件事情，但当我们遇见毁灭性场景时，缺少备份带来的损失是非常大的，常见场景：

- 服务器损坏，导致存在该服务器上的内容全部完蛋；
- 触发某致命bug或者错误操作（例如rm -f），导致文件和数据全部消失；
- 数据库出现错误操作或出现问题，导致用户数据、公司资产遭受严重损失；

总的来说，没人想遇见这样的场景，但我们必须考虑这种极端情况的发生，因此需要从架构层面解决这个问题。常见方法是定期备份、多机备份、容灾系统建设等。

意义：

避免在遭遇极端场景时，给公司带来不可估量的损失。

## 3、应用层设计

### 3.1、多页和单页

除了特殊场景，通常推荐使用多页架构。理由如下：

- 多页项目，页面和页面之间是独立的，不存在交互，因此当一个页面需要单独重构时，不会影响其他页面，对于有长期历史的项目来说，可维护性、可重构性要高很多；
- 多页项目的缺点是不同页面切换时，会有一个白屏时间，但通常来说，这个时间并不长，大部分现有大公司的线上网页，都是这样的，因此认为是可以接受的；
- 多页项目可以单次只更新一个页面的版本，而单页项目如果其中一个功能模块要更新（特别是公共组件更新），很容易让所有页面都需要更新版本；
- 多页项目的版本控制更简单，如果需要页面拆分，调整部分页面的使用流程，难度也会更低；
- 灰度发布更友好；

之前面试的一家，采用了单页的形式，之前因为种种原因，同时采用了ng和react。由于项目历史也比较久（3年以上），结果导致目前继续维护更新的难度很大，即使想部分重构，也很麻烦。

意义：

降低长期项目迭代维护的难度，

### 3.2、以应用为单位划分前端项目

在项目比较大的时候，将所有页面的前端文件放入到同一个代码仓库里，我之前参与过一家企业的前端项目开发，发现其就是这么做的。根据使用经验来看，存在很多问题：

- 会极大的增加代码的维护难度；
- 项目会变得很丑陋；
- 不方便权限管理，容易造成页面误更改或代码泄密；
- 任何人都有权利改任何他能看到的页面（在合并代码的时候，管理人员并不能确定他本次修改的页面是否是需求里他应该改的页面）；
- 发布成本高，即使改一个页面，也需要发布所有资源；

因此，我们应该避免这种现象的发生，个人推荐以应用为单位进行开发、发布。所谓应用即指一个业务涉及到的前后端代码，好处很多：

- 方便进行管理，当某个业务有需求变更时，可以只给研发人员该业务前端应用的developer权限；
- 在需要发布某业务时，只需要发布该业务的所属应用即可；

意义：

规范项目，增加代码的安全性，降低项目维护成本。

### 3.3、基础组件库的建设

这个蛮基础的，对于组件库的建设，不建议研发人员较少时去做这件事情，专职前端开发人数少于10人时，建议使用比较靠谱的第三方UI库，例如Antd，这样性价比更高。

设计基础组件库的前提，是要求统一技术栈，这样才能最大化基础组件库的效益。组件库建议以使用以下参考标准：

- 使用ts；
- 可扩展性强；
- 适用程度高；
- 文档清楚详细；
- 版本隔离，小版本优化加功能，大改需要大版本更新；
- 和UI协调统一，要求UI交互参与进来；

总的来说，建设起来后，利大于弊，但是需要专人维护，因此还是有一定成本的。

意义：

统一不同/相同产品线之间的风格，给用户更好的体验，减少单次开发中写UI组件时浪费的时间和人力，提高开发效率。

### 3.4、技术栈统一

前端有三大主流框架，还有兼容性最强jQuery，以及各种第三方库，UI框架。因此项目需求如果复杂一些，很容易形成一个大杂烩。因此前端的技术栈必须统一，具体来说，建议实现以下举措：

- 三大框架选型其一，团队水平一般推荐Vue、水平较好推荐React，对外项目选React或者ng；
- 需要兼容IE8或更老版本时，建议使用jQuery；
- 组件库自建或者统一选择一个固定的第三方；
- 一些特殊第三方库统一使用一个版本，例如需要使用地图时，固定使用高德或百度或腾讯地图；
- 基础设施建设应避免重复造轮子，所有团队尽量共用，并有专门的前端平台负责统一这些东西，对于特殊需求，可以新建，但应当有说服力；

总的来说，技术栈统一的好处很多，可以有效提高开发效率，降低重复造轮子产生的成本。

意义：

方便招人，简化团队成员培养成本，以及提高项目的可持续性。

### 3.5、浏览器兼容

常见的问题是IE6、7、8，以及部分小众浏览器（PC和手机）产生的奇怪问题。因此应该考虑统一解决方案，避免bug的重复产生。常见解决方案有：

- 配置postcss，让某些css增加兼容性前缀；
- 写一个wepback的loader，处理某些特殊场景；
- 规范团队代码，使用更稳定的写法（例如移动端避免使用fixed进行布局）；
- 对常见问题、疑难问题，总结解决方案并团队共享；
- 建议或引导用户使用高版本浏览器（比如chrome）；

意义：

避免浏览器环境产生的bug，以及排查此类bug所浪费的大量时间。

### 3.6、内容平台建设

为了提高公司内部的沟通效率，总结经验，以及保密原因。应建设一个内部论坛+博客站点。其具备的好处如下：

- 可以记录公司的历史；
- 研发同学之间分享经验；
- 总结转载一些外界比较精品的文章，提高大家的眼界；
- 增加公司内部同学的交流，有利于公司的团队和文化建设；
- 对某些技术问题可以进行讨论，减少因没有达成共识带来的沟通损耗；

众所周知，大型互联网公司通常都有这样一个内部论坛和博客站点。其降低了公司的沟通和交流成本，也增加了公司的技术积累。

意义：

博客增强技术积累，论坛增强公司内部沟通能力。

### 3.7、权限管理平台

当公司内部人员较多时，应有一个专门的平台，来管理、规范用户的权限以及可访问内容。权限管理平台有几个特点：

- 必然和Server端天然高耦合度，因此需要有专门的控制模块负责处理权限问题（负责Server端开发处理，或者前端通过中间层例如Node层介入处理）；
- 自动化流程控制，即用户创建、申请、审批、离职自动删除，都应该是由系统推进并提醒相关人士，必要时应能触发报警；
- 权限应有时效性，减少永久性权限的产生；
- 审批流程应清晰可见，每一阶段流程应具体明确；
- 应与公司流程紧密结合，并且提高可修改性，方便公司后期进行流程优化；

意义：

使得公司内部流程正规化、信息化。

### 3.8、登录系统设计（单点登录）

当公司内部业务线比较复杂但相互之间的耦合度比较高时，我们应该考虑设计添加单点登录系统。具体来说，用户在一处登录，即可以在任何页面访问，登出时，也同样在任何页面都失去登录状态。SSO的好处很多：

- 增强用户体验；
- 打通了不同业务系统之间的用户数据；
- 方便统一管理用户；
- 有利于引流；
- 降低开发系统的成本（不需要每个业务都开发一次登录系统和用户状态控制）；

总的来说，大中型web应用，SSO可以带来很多好处，缺点却很少。

意义：

用户体验增强，打通不同业务之间的间隔，降低开发成本和用户管理成本。

### 3.9、CDN

前端资源的加载速度是衡量用户体验的重要指标之一。而现实中，因为种种因素，用户在加载页面资源时，会受到很多限制。因此上CDN是非常有意义的，好处如下：

- 用户来自不同地区，加入CDN可以使用户访问资源时，访问离自己比较近的CDN服务器，降低访问延迟；
- 降低服务器带宽使用成本；
- 支持视频、静态资源、大文件、小文件、直播等多种业务场景；
- 消除跨运营商造成的网络速度较慢的问题；
- 降低DDOS攻击造成的对网站的影响；

CDN是一种比较成熟的技术，各大云平台都有提供CDN服务，价格也不贵，因此CDN的性价比很高。

意义：

增加用户访问速度，降低网络延迟，带宽优化，减少服务器负载，增强对攻击的抵抗能力。

### 3.10、负载均衡

目前来看，负载均衡通常使用Nginx比较多，以前也有使用Apache。当遇见大型项目的时候，负载均衡和分布式几乎是必须的。负载均衡有以下好处：

- 降低单台server的压力，提高业务承载能力；
- 方便应对峰值流量，扩容方便（如举办某些活动时）；
- 增强业务的可用性、扩展性、稳定性；

负载均衡已经是蛮常见的技术了，好处不用多说，很容易理解。

意义：

增强业务的可用性、扩展性、稳定性，可以支持更多用户的访问。

### 3.11、多端共用一套接口

目前常见场景是一个业务，同时有PC页面和H5页面，由于业务是一样的，因此应避免同一个业务有多套接口分别适用于PC和H5端。因此解决方案如下：

- 后端提供的接口，应该同时包含PC和H5的数据（即单独对一个存在亢余数据）；
- 接口应当稳定，即当业务变更时，应尽量采取追加数据的形式；
- 只有在单独一端需要特殊业务流程时，设计单端独有接口；

多端共用接口，是减少开发工作量，并且提高业务可维护性的重要解决方案。

意义：

降低开发工作量，增强可维护性。



# 手把手教你优雅处理前端异常

前端一直是距离用户最近的一层，随着产品的日益完善，我们会更加注重用户体验，而前端异常却如鲠在喉，甚是烦人。

## 一、为什么要处理异常？

异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。

1. 增强用户体验；
2. 远程定位问题；
3. 未雨绸缪，及早发现问题；
4. 无法复线问题，尤其是移动端，机型，系统都是问题；
5. 完善的前端方案，前端监控系统；

对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。

## 二、需要处理哪些异常？

对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：

- JS 语法错误、代码异常
- AJAX 请求异常
- 静态资源加载异常
- Promise 异常
- Iframe 异常
- 跨域 Script error
- 崩溃和卡顿

下面我会针对每种具体情况来说明如何处理这些异常。

## 三、Try-Catch 的误区

try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。

1. 同步运行时错误：

```js
try {  let name = 'jartto';  console.log(nam);} catch(e) {  console.log('捕获到异常：',e);}
```

输出：

```js
捕获到异常：ReferenceError: nam is not defined    at :3:15
```

1. 不能捕获到具体的语法错误，只有一个语法错误提示。我们修改一下代码，删掉一个单引号：

```js
try {  let name = 'jartto;  console.log(nam);} catch(e) {  console.log('捕获到异常：',e);}
```

输出：

```js
Uncaught SyntaxError: Invalid or unexpected token不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。
```

1. 异步错误

```js
try {  setTimeout(() => {    undefined.map(v => v);  }, 1000)} catch(e) {  console.log('捕获到异常：',e);}
```

我们看看日志：

```js
Uncaught TypeError: Cannot read property 'map' of undefined    at setTimeout (:3:11)
```

并没有捕获到异常，这是需要我们特别注意的地方。

## 四、window.onerror 不是万能的

当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。

```js
/*** @param {String}  message    错误信息
* @param {String}  source    出错文件
* @param {Number}  lineno    行号
* @param {Number}  colno    列号
* @param {Object}  error  Error对象(对象)
*/
window.onerror = function(message, source, lineno, colno, error) {   
    console.log('捕获到异常：',{message, source, lineno, colno, error});
}
```

1. 首先试试同步运行时错误

```js
window.onerror = function(message, source, lineno, colno, error) {
    // message：错误信息(字符串)。
    // source：发生错误的脚本URL(字符串)
    // lineno：发生错误的行号(数字)
    // colno：发生错误的列号(数字)
    // error：Error对象(对象)
    console.log('捕获到异常：',{message, source, lineno, colno, error});
}
```

可以看到，我们捕获到了异常：

![209bc42338eabf20f4080a9aa997f057.png](https://img-blog.csdnimg.cn/img_convert/209bc42338eabf20f4080a9aa997f057.png)

1. 再试试语法错误呢？

```js
window.onerror = function(message, source, lineno, colno, error) {console.log('捕获到异常：',{message, source, lineno, colno, error});}let name = 'Jartto
```

控制台打印出了这样的异常：

```js
Uncaught SyntaxError: Invalid or unexpected token
```

什么，竟然没有捕获到语法错误？

1. 怀着忐忑的心，我们最后来试试异步运行时错误：

```js
window.onerror = function(message, source, lineno, colno, error) {    console.log('捕获到异常：',{message, source, lineno, colno, error});}setTimeout(() => {    Jartto;});
```

控制台输出了：

```js
捕获到异常：{message: "Uncaught ReferenceError: Jartto is not defined", source: "http://127.0.0.1:8001/", lineno: 36, colno: 5, error: ReferenceError: Jartto is not defined    at setTimeout (http://127.0.0.1:8001/:36:5)}
```

1. 接着，我们试试网络请求异常的情况：

我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。**

补充一点：window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx

```js
window.onerror = function(message, source, lineno, colno, error) {    
    console.log('捕获到异常：',{message, source, lineno, colno, error});    
    return true;
}
setTimeout(() => {    
    Jartto;
});
```

控制台就不会再有这样的错误了：

```js
Uncaught ReferenceError: Jartto is not defined    at setTimeout ((index):36)
```

需要注意：

- onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；
- onerror 无法捕获语法错误；

到这里基本就清晰了：在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。

问题又来了，捕获不到静态资源加载异常怎么办？

## 五、window.addEventListener

当一项资源(如图片或脚本)加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过(至少在 Firefox 中)能被单一的window.addEventListener 捕获。

```js
window.addEventListener('error', (error) => {    
    console.log('捕获到异常：', error);
}, true)
```

控制台输出：

![39c051137e47c4769e3611de0ec4b1ac.png](https://img-blog.csdnimg.cn/img_convert/39c051137e47c4769e3611de0ec4b1ac.png)

由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。

**需要注意：**

- 不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。
- 需要注意避免 addEventListener 重复监听。

## 六、Promise Catch

在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。

没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。

解决方案：为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。使用方式：

```js
window.addEventListener("unhandledrejection", function(e){  
    console.log(e);
});
```

我们继续来尝试一下：

```js
window.addEventListener("unhandledrejection", function(e){  
    e.preventDefault()  
    console.log('捕获到异常：', e);  
    return true;
});
Promise.reject('promise error');
```

可以看到如下输出：

![d43c5fd20d70d57c5497f3a763f6ffd5.png](https://img-blog.csdnimg.cn/img_convert/d43c5fd20d70d57c5497f3a763f6ffd5.png)

那如果对 Promise 不进行 catch 呢？

```js
window.addEventListener("unhandledrejection", function(e){  
    e.preventDefault()  
    console.log('捕获到异常：', e);  
    return true;
});
new Promise((resolve, reject) => {  
    reject('jartto: promise error');
});
```

嗯，事实证明，也是会被正常捕获到的。

所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。

补充一点：如果去掉控制台的异常显示，需要加上：

```js
event.preventDefault();
```

## VUE errorHandler

```js
Vue.config.errorHandler = (err, vm, info) => {  
    console.error('通过vue errorHandler捕获的错误');  
    console.error(err);  
    console.error(vm);  
    console.error(info);
}
```

八、React 异常捕获 React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息

```js
componentDidCatch(error, info) {    console.log(error, info);}
```

除此之外，我们可以了解一下：error boundary UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界(error boundary)的新观念。

需要注意的是：error boundaries 并不会捕捉下面这些错误。

1. 事件处理器
2. 异步代码
3. 服务端的渲染代码
4. 在 error boundaries 区域内的错误

我们来举一个小例子，在下面这个 componentDIdCatch(error,info) 里的类会变成一个 error boundary：

```js
class ErrorBoundary extends React.Component {  
    constructor(props) {    
        super(props);    
        this.state = { hasError: false };  
    }   
    componentDidCatch(error, info) {    
        // Display fallback UI   
        this.setState({ hasError: true });    
        // You can also log the error to an error reporting service    
        logErrorToMyService(error, info);  
    }   
    render() {    
        if (this.state.hasError) {      
            // You can render any custom fallback UI      
            return Something went wrong; 
        } 
        return this.props.children; 
    }
}
```

然后我们像使用普通组件那样使用它：componentDidCatch() 方法像 JS 的 catch{} 模块一样工作，但是对于组件，只有 class 类型的组件(class component )可以成为一个 error boundaries 。

实际上，大多数情况下我们可以在整个程序中定义一个 error boundary 组件，之后就可以一直使用它了！

## 九、iframe 异常

对于 iframe 的异常捕获，我们还得借力 window.onerror：

```js
window.onerror = function(message, source, lineno, colno, error) {  
    console.log('捕获到异常：',{message, source, lineno, colno, error});
}
```

## 十、Script error

一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：

跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。或者动态去添加 js 脚本：

```js
const script = document.createElement('script');
script.crossOrigin = 'anonymous';
script.src = url;
document.body.appendChild(script);
```

特别注意，服务器端需要设置：Access-Control-Allow-Origin

此外，我们也可以试试这个-解决 Script Error 的另类思路：

```js
const originAddEventListener = EventTarget.prototype.addEventListener;
EventTarget.prototype.addEventListener = function (type, listener, options) {  
    const wrappedListener = function (...args) {    
        try {      
            return listener.apply(this, args);    
        }catch (err) {      
            throw err;    
        }  
    }  
    return originAddEventListener.call(this, type, wrappedListener, options);
}
```

简单解释一下：

改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：

```js
(() => {   
    const originAddEventListener = EventTarget.prototype.addEventListener;   
    EventTarget.prototype.addEventListener = function (type, listener, options) {    
        // 捕获添加事件时的堆栈 
        const addStack = new Error(`Event (${type})`).stack;     
        const wrappedListener = function (...args) {       
            try {         
                return listener.apply(this, args);       
            }catch (err) {
                // 异常发生时，扩展堆栈
                err.stack += '' + addStack;         
                throw err;       
            }     
        }     
        return originAddEventListener.call(this, type, wrappedListener, options);   
    } 
})();
```

## 十一、崩溃和卡顿

卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？

崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。

1. 利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。不错的文章，推荐阅读：Logging Information on Browser Crashes。

```js
window.addEventListener('load', function () {    
    sessionStorage.setItem('good_exit', 'pending');    
    setInterval(function () {        
        sessionStorage.setItem('time_before_crash', new Date().toString());    
    }, 1000);  
});  
window.addEventListener('beforeunload', function () {    
    sessionStorage.setItem('good_exit', 'true');  
});  
if(sessionStorage.getItem('good_exit') &&    sessionStorage.getItem('good_exit') !== 'true') {    
    /*        insert crash logging code here    */    
    alert('Hey, welcome back from your crash, looks like you crashed on: ' + sessionStorage.getItem('time_before_crash'));  
}
```

1. 基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控：

Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。

## 十二、错误上报

1.通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。

2.动态创建 img 标签的形式

```js
function report(error) {  
    let reportUrl = 'http://jartto.wang/report';  
    new Image().src = `${reportUrl}?logs=${error}`;
}
```

收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力：

```js
Reporter.send = function(data) {  
    // 只采集 30%  
    if(Math.random() < 0.3) {    
        send(data)      
        // 上报错误信息  
    }
}
```

采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。

## 十三、总结

回到我们开头提出的那个问题，如何优雅的处理异常呢？

1. 可疑区域增加 Try-Catch
2. 全局监控 JS 异常 window.onerror
3. 全局监控静态资源异常 window.addEventListener
4. 捕获没有 Catch 的 Promise 异常：unhandledrejection
5. VUE errorHandler 和 React componentDidCatch
6. 监控网页崩溃：window 对象的 load 和 beforeunload
7. 跨域 crossOrigin 解决

