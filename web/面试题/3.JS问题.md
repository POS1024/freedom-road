# 解释事件委托
事件委托是一种利用事件冒泡的机制，在父元素上监听事件，然后通过判断事件的目标（target）来执行相应的操作。这种技术的核心思想是将事件处理程序绑定到父元素，而不是绑定到每个子元素上。

### 工作原理：

1. **事件冒泡**：当事件在 DOM 树上触发时，它会从触发元素开始向上传播到父元素、祖先元素，直到根节点。

2. **利用事件冒泡**：将事件处理程序绑定到父元素上，利用事件冒泡的特性，父元素可以监听到子元素上触发的事件。

3. **判断事件目标**：当事件被触发时，可以通过事件对象的 `target` 属性获取触发事件的具体元素。

4. **执行操作**：根据事件目标的不同，可以执行相应的操作。通常通过判断目标元素的特定属性、类名或标签名来确定执行什么操作。

### 优点：

- **减少内存消耗**：不需要给每个子元素都绑定事件处理程序，减少了内存消耗。
- **动态元素支持**：对于动态添加的子元素也同样有效，不需要额外的事件绑定操作。
- **简化代码**：通过将事件处理程序绑定到父元素上，代码更加简洁、易于维护。

### 示例：

假设有一个 `ul` 列表，其中有多个 `li` 元素，需要为每个 `li` 元素添加点击事件，当点击时输出对应的文本内容。

```html
<ul id="myList">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
```

使用事件委托的方式：

```javascript
document.getElementById('myList').addEventListener('click', function(event) {
  if (event.target.tagName === 'LI') {
    console.log(event.target.textContent);
  }
});
```

在这个例子中，只需要将事件处理程序绑定到 `ul` 元素上，当点击 `li` 元素时，事件会冒泡到 `ul` 元素，然后通过判断事件目标是哪个 `li` 元素，执行相应的操作。这样无论有多少个 `li` 元素，都只需要一个事件处理程序。

# 解释JavaScript中this的工作原理，举例说明一下 ES6 中this操作方式的改变
在 JavaScript 中，`this` 关键字表示当前执行上下文中的对象。`this` 的值在函数调用时动态确定，取决于函数的调用方式。

### 工作原理：

1. **全局上下文**：在全局上下文中，`this` 指向全局对象（浏览器环境下为 `window` 对象）。

2. **函数上下文**：在函数中，`this` 的值取决于函数的调用方式：
    - 如果函数作为普通函数调用，`this` 指向全局对象。
    - 如果函数作为对象的方法调用，`this` 指向调用该方法的对象。
    - 如果函数作为构造函数调用（使用 `new` 关键字），`this` 指向新创建的实例对象。
    - 如果函数通过 `call()`、`apply()` 或 `bind()` 显示指定 `this`，则 `this` 指向指定的对象。

3. **箭头函数**：箭头函数中的 `this` 指向定义时所在的词法作用域的 `this` 值，而不是运行时的值。箭头函数没有自己的 `this` 绑定，会捕获最近的外层非箭头函数的 `this` 值。

### 示例：

```javascript
// 全局上下文中的 this
console.log(this); // 在浏览器中输出 window 对象

// 对象方法中的 this
const obj = {
  name: 'Alice',
  greet: function() {
    console.log('Hello, ' + this.name);
  }
};
obj.greet(); // 在对象方法中，this 指向对象本身，输出 "Hello, Alice"

// 构造函数中的 this
function Person(name) {
  this.name = name;
}
const person1 = new Person('Bob');
console.log(person1.name); // 输出 "Bob"

// 显示指定 this
function sayHello() {
  console.log('Hello, ' + this.name);
}
const user = { name: 'Charlie' };
sayHello.call(user); // 使用 call 方法显示指定 this，输出 "Hello, Charlie"

// 箭头函数中的 this
const greet = () => {
  console.log('Hello, ' + this.name);
};
const context = { name: 'David' };
greet.call(context); // 箭头函数中的 this 指向定义时的词法作用域，输出 "Hello, undefined"
```

### ES6 中的改变：

ES6 中引入了箭头函数，箭头函数的 `this` 行为与传统函数不同。箭头函数没有自己的 `this` 绑定，而是捕获定义时所在的词法作用域的 `this` 值。这种行为解决了传统函数中 `this` 指向问题的困扰，使得在回调函数等场景中更加方便和可靠。

# 解释原型继承如何工作
原型继承是 JavaScript 中一种基于原型链的继承方式，它通过原型链将对象之间的关系建立起来，实现了对象间的属性和方法的共享。

### 工作原理：

1. **每个对象都有一个原型（prototype）**：在 JavaScript 中，每个对象（除了 `null`）都有一个原型对象，该原型对象定义了对象的共享属性和方法。

2. **原型链**：对象之间通过原型链相互连接，形成了一条原型链。当访问对象的属性或方法时，JavaScript 引擎会沿着原型链向上查找，直到找到匹配的属性或方法，或者到达原型链的末尾。

3. **构造函数**：构造函数是一种用于创建对象的特殊函数，构造函数通过 `new` 关键字创建对象实例。构造函数的 `prototype` 属性指向新创建的对象实例的原型。

4. **原型继承**：当一个对象需要继承另一个对象的属性和方法时，可以将另一个对象作为自己的原型。通过设置对象的 `prototype` 属性，将父对象指定为子对象的原型，从而实现继承。

### 示例：

```javascript
// 定义一个父对象
function Animal(name) {
  this.name = name;
}
Animal.prototype.sayHello = function() {
  console.log('Hello, my name is ' + this.name);
};

// 定义一个子对象，继承自父对象
function Dog(name, breed) {
  Animal.call(this, name); // 调用父对象的构造函数，继承父对象的属性
  this.breed = breed;
}
Dog.prototype = Object.create(Animal.prototype); // 将 Animal 的原型对象作为 Dog 的原型对象
Dog.prototype.constructor = Dog; // 修正 Dog 构造函数的指向

// 创建 Dog 的实例
const myDog = new Dog('Buddy', 'Labrador');
myDog.sayHello(); // 输出 "Hello, my name is Buddy"
```

在这个示例中，`Dog` 函数继承了 `Animal` 函数的属性和方法。通过 `Object.create()` 方法，`Dog.prototype` 对象的原型被设置为 `Animal.prototype`，从而实现了继承。当访问 `myDog` 实例的属性或方法时，JavaScript 引擎会沿着原型链向上查找，找到了从 `Animal.prototype` 继承的 `sayHello` 方法，从而成功调用了该方法。

通过原型继承，可以实现对象间的属性和方法的共享，减少内存消耗，提高代码的可维护性和扩展性。

# null变量、undefined或未声明的变量之间有什么区别，您将如何检查这些状态？
在 JavaScript 中，`null`、`undefined` 和未声明的变量是三种不同的状态，它们之间有一些区别：

1. **null**：
    - `null` 是 JavaScript 的一个特殊值，表示“空值”或“不存在”。
    - 当变量被赋值为 `null` 时，表示该变量没有值。
    - `null` 是一个对象，但是它表示的是一个空的对象指针。

2. **undefined**：
    - `undefined` 表示变量已声明但尚未赋值，或者对象不存在某个属性时返回的值。
    - 当访问未初始化的变量时，JavaScript 引擎会返回 `undefined`。
    - `undefined` 是一个全局变量，它的值是 JavaScript 的一个原始值。

3. **未声明的变量**：
    - 未声明的变量是指在代码中使用了但是没有通过 `var`、`let` 或 `const` 关键字声明过的变量。
    - 访问未声明的变量会抛出 `ReferenceError` 错误。

### 如何检查这些状态：

1. **null**：可以使用严格相等运算符 `===` 或不严格相等运算符 `==` 来检查变量是否为 `null`。
   ```javascript
   const value = null;
   if (value === null) {
     // 变量为 null
   }
   ```

2. **undefined**：同样可以使用严格相等运算符 `===` 或不严格相等运算符 `==` 来检查变量是否为 `undefined`。
   ```javascript
   let value;
   if (value === undefined) {
     // 变量为 undefined
   }
   ```

3. **未声明的变量**：可以使用 `typeof` 运算符或 `try...catch` 语句来检查变量是否已声明。
   ```javascript
   if (typeof someVariable === 'undefined') {
     // 变量未声明
   }

   // 或者使用 try...catch
   try {
     someVariable;
   } catch (error) {
     // 变量未声明
   }
   ```

总之，要检查变量是否为 `null`、`undefined` 或未声明，可以根据具体情况使用严格相等运算符、`typeof` 运算符或 `try...catch` 语句来判断。

# 什么是闭包，以及如何/为什么使用闭包？
闭包（Closure）是指函数和其相关的引用环境组合而成的实体。具体来说，闭包是在函数内部创建的一个函数，这个内部函数可以访问其外部函数的变量、参数和内部函数以及全局作用域的变量。闭包使得函数可以保留对定义时作用域的引用，即使在其定义所在的作用域之外调用也可以访问这些变量。

### 如何创建闭包：

```javascript
function outerFunction() {
  let outerVariable = 'I am from outer function';

  function innerFunction() {
    console.log(outerVariable); // 内部函数可以访问外部函数的变量
  }

  return innerFunction; // 返回内部函数
}

const myClosure = outerFunction(); // 调用外部函数，返回内部函数
myClosure(); // 执行内部函数，输出 "I am from outer function"
```

### 为什么使用闭包：

1. **保护变量**：通过闭包可以创建私有变量，避免全局作用域的污染。
2. **封装**：将相关的变量和函数封装在一个作用域中，提高代码的模块化和可维护性。
3. **实现数据隐藏**：通过闭包可以隐藏实现细节，只暴露必要的接口。
4. **延长变量的生命周期**：当外部函数执行完毕后，内部函数依然可以访问外部函数的变量，延长了变量的生命周期。
5. **实现柯里化**：通过闭包可以实现柯里化（Currying），即将多参数的函数转换为接受单一参数的函数。

### 示例：

```javascript
function counter() {
  let count = 0;

  return function() {
    count++;
    console.log(count);
  };
}

const increment = counter(); // 调用外部函数，返回内部函数
increment(); // 执行内部函数，输出 1
increment(); // 执行内部函数，输出 2
increment(); // 执行内部函数，输出 3
```

在这个示例中，`counter` 函数返回了一个内部函数，这个内部函数形成了闭包，可以访问外部函数的 `count` 变量。每次调用 `increment` 函数时，`count` 变量都会递增，并输出递增后的值。由于闭包的存在，`count` 变量在外部函数执行完毕后仍然存在于内存中，且不会被垃圾回收，因此可以保持其状态。

# 您使用什么语言结构来迭代对象属性和数组项？
在 JavaScript 中，可以使用不同的语言结构来迭代对象属性和数组项。

### 迭代对象属性：

1. **for...in 循环**：遍历对象的可枚举属性，包括自身和继承的属性。
   ```javascript
   const obj = { a: 1, b: 2, c: 3 };
   for (let key in obj) {
     console.log(key, obj[key]);
   }
   ```

2. **Object.keys() 方法**：返回对象自身的可枚举属性组成的数组，然后可以使用数组的迭代方法如 forEach()、map() 等进行遍历。
   ```javascript
   const obj = { a: 1, b: 2, c: 3 };
   Object.keys(obj).forEach(key => {
     console.log(key, obj[key]);
   });
   ```

3. **Object.entries() 方法**：返回一个数组，包含对象自身的可枚举属性的键值对数组，然后可以使用数组的迭代方法进行遍历。
   ```javascript
   const obj = { a: 1, b: 2, c: 3 };
   Object.entries(obj).forEach(([key, value]) => {
     console.log(key, value);
   });
   ```

### 迭代数组项：

1. **for 循环**：经典的 for 循环可以迭代数组的每一项。
   ```javascript
   const arr = [1, 2, 3, 4, 5];
   for (let i = 0; i < arr.length; i++) {
     console.log(arr[i]);
   }
   ```

2. **forEach() 方法**：数组的 forEach() 方法用于遍历数组的每一项，接受一个回调函数作为参数。
   ```javascript
   const arr = [1, 2, 3, 4, 5];
   arr.forEach(item => {
     console.log(item);
   });
   ```

3. **for...of 循环**：可以使用 for...of 循环来迭代可迭代对象，包括数组。
   ```javascript
   const arr = [1, 2, 3, 4, 5];
   for (const item of arr) {
     console.log(item);
   }
   ```

4. **map()、filter()、reduce() 等方法**：数组的其他迭代方法如 map()、filter()、reduce() 等也可以用于迭代数组项。
   ```javascript
   const arr = [1, 2, 3, 4, 5];
   const doubled = arr.map(item => item * 2);
   console.log(doubled); // 输出 [2, 4, 6, 8, 10]
   ```

总之，JavaScript 提供了多种语言结构来迭代对象属性和数组项，开发者可以根据具体需求选择合适的方法进行迭代。

# 您能描述一下Array.forEach()循环和Array.map()方法之间的主要区别以及为什么您会选择其中一种吗？
`Array.forEach()` 和 `Array.map()` 都是 JavaScript 数组的迭代方法，但它们在使用方式和返回值上有一些不同。

### Array.forEach()：

- **作用**：`forEach()` 方法用于迭代数组的每一项，并对每一项执行指定的回调函数。
- **返回值**：`forEach()` 方法没有返回值，它会直接修改原数组，并且不会创建新数组。
- **使用场景**：适合在迭代数组的过程中执行一些操作，比如修改数组项、输出数组项等。

```javascript
const arr = [1, 2, 3, 4, 5];
arr.forEach(item => {
  console.log(item * 2); // 输出每一项的两倍值
});
```

### Array.map()：

- **作用**：`map()` 方法用于迭代数组的每一项，并对每一项执行指定的回调函数，然后返回一个新数组，新数组的每一项是回调函数的返回值。
- **返回值**：`map()` 方法返回一个新数组，原数组不会被修改。
- **使用场景**：适合在迭代数组的过程中执行一些转换操作，生成一个新数组，而不影响原数组。

```javascript
const arr = [1, 2, 3, 4, 5];
const doubled = arr.map(item => item * 2);
console.log(doubled); // 输出 [2, 4, 6, 8, 10]
```

### 区别和选择：

1. **返回值**：`forEach()` 没有返回值，而 `map()` 返回一个新数组。
2. **影响原数组**：`forEach()` 会修改原数组，而 `map()` 不会修改原数组。
3. **使用场景**：如果只是需要在迭代过程中执行一些操作，而不需要生成新数组，可以使用 `forEach()`；如果需要生成一个新数组，可以使用 `map()`。

我会根据具体需求选择不同的方法。如果我需要在迭代过程中执行一些操作，而不需要生成新数组，我会选择使用 `forEach()`；如果我需要生成一个新数组，而不改变原数组，我会选择使用 `map()`。

# 匿名函数的典型用例是什么？
匿名函数是指没有名称的函数，通常以函数表达式的形式出现。它们在 JavaScript 中有许多典型的用例，其中一些包括：

1. **作为回调函数**：匿名函数经常用作回调函数，传递给其他函数作为参数，用于在异步操作完成或事件发生时执行特定的操作。
   ```javascript
   setTimeout(function() {
     console.log('异步操作完成');
   }, 1000);
   ```

2. **IIFE（立即执行函数表达式）**：匿名函数可以立即执行，常用于创建局部作用域，防止变量污染全局作用域。
   ```javascript
   (function() {
     // 这里是一个匿名函数体
   })();
   ```

3. **事件处理程序**：匿名函数经常用作事件处理程序，用于处理 DOM 元素的事件。
   ```javascript
   button.addEventListener('click', function() {
     console.log('按钮被点击了');
   });
   ```

4. **迭代器和高阶函数**：匿名函数可以用于数组的迭代器方法（如 `map`、`filter`、`reduce` 等）和其他高阶函数。
   ```javascript
   const doubled = [1, 2, 3, 4, 5].map(function(num) {
     return num * 2;
   });
   ```

5. **动态函数**：在一些情况下，需要根据条件动态地创建函数，这时候匿名函数是一个很好的选择。
   ```javascript
   const func = condition ? function() {
     // 条件满足时执行的逻辑
   } : function() {
     // 条件不满足时执行的逻辑
   };
   ```

总之，匿名函数在 JavaScript 中有许多典型的用例，包括作为回调函数、IIFE、事件处理程序、迭代器和高阶函数、动态函数等。它们能够使代码更加简洁、灵活，并且可以在需要时动态地创建和使用。

# 宿主对象和本机对象有什么区别？
"宿主对象"和"本机对象"这两个术语在不同的上下文中有不同的含义。

### 宿主对象（Host Objects）：

- **定义**：宿主对象是指由宿主环境（如浏览器或 Node.js）提供的对象，它们不属于 JavaScript 语言规范，而是由宿主环境实现的。
- **示例**：在浏览器环境中，`window`、`document`、`XMLHttpRequest` 等对象都是宿主对象。在 Node.js 环境中，`global`、`process`、`Buffer` 等对象也是宿主对象。

### 本机对象（Native Objects）：

- **定义**：本机对象是指由 JavaScript 语言规范定义的对象，它们是 JavaScript 核心的一部分，与宿主环境无关。
- **示例**：在 JavaScript 中，`Object`、`Array`、`String`、`Number`、`Function` 等都是本机对象。

### 区别：

1. **来源**：宿主对象是由宿主环境提供的，而本机对象是由 JavaScript 语言规范定义的。
2. **实现**：宿主对象的行为和实现取决于宿主环境，而本机对象的行为和实现是由 JavaScript 引擎实现的。
3. **环境依赖**：宿主对象的存在和行为受到宿主环境的限制，不同的宿主环境可能提供不同的宿主对象；而本机对象是 JavaScript 语言的一部分，不受宿主环境的影响。

总之，宿主对象是由宿主环境提供的，而本机对象是 JavaScript 语言规范定义的，它们在实现、行为和环境依赖等方面有所不同。

# 解释一下 function foo() {} 和 var foo = function() {} 在 foo 用法上的区别
`function foo() {}` 和 `var foo = function() {}` 都可以用来定义一个函数，但它们之间有一些重要的区别，主要涉及到函数的声明方式、函数的提升和作用域。

### function foo() {}：

- **函数声明**：使用 `function` 关键字声明的函数被称为函数声明，它们会被提升到其所在作用域的顶部，并且可以在声明之前调用。
- **示例**：
  ```javascript
  foo(); // 可以在函数声明之前调用
  function foo() {
    console.log('Hello, world!');
  }
  ```

### var foo = function() {}：

- **函数表达式**：将一个函数赋值给一个变量的方式被称为函数表达式。函数表达式不会被提升，它们的定义会在代码执行到达时进行赋值。
- **示例**：
  ```javascript
  foo(); // 会抛出 TypeError: foo is not a function，因为函数表达式尚未赋值
  var foo = function() {
    console.log('Hello, world!');
  };
  ```

### 区别和使用场景：

1. **提升**：函数声明会被提升到其所在作用域的顶部，因此可以在声明之前调用；而函数表达式不会被提升，必须在赋值之后才能调用。
2. **命名**：函数声明会提供一个函数名，可以在函数体内部递归调用自身；函数表达式可以是匿名的，也可以是具名的，但具名函数只能在函数体内部使用自身的名称进行递归调用。
3. **作用域**：函数声明的作用域是整个块级作用域或全局作用域；函数表达式的作用域是当前变量的作用域。

在实际开发中，一般推荐使用函数表达式来定义函数，因为它能够更好地控制函数的作用域，并且可以使代码更易于阅读和理解。如果需要在函数声明之前调用函数，可以使用函数声明，但应谨慎使用，以避免引起代码不易理解的问题。

# 解释Function.prototype.bind
`Function.prototype.bind()` 是 JavaScript 中的一个方法，它用于创建一个新函数，并将指定的对象绑定为新函数的执行上下文（即 this 值）。这个新函数会在调用时将绑定的对象作为其执行上下文。

### 语法：

```javascript
function.bind(thisArg[, arg1[, arg2[, ...]]])
```

- `thisArg`：当新函数被调用时，绑定到新函数的 this 值。
- `arg1, arg2, ...`：新函数调用时传递的参数。

### 返回值：

返回一个新函数，这个新函数的执行上下文被绑定到指定的 `thisArg`，并且在调用时会将指定的参数传递给原函数。

### 示例：

```javascript
const module = {
  x: 42,
  getX: function() {
    return this.x;
  }
};

const unboundGetX = module.getX;
console.log(unboundGetX()); // undefined，因为 this 指向全局对象

const boundGetX = module.getX.bind(module);
console.log(boundGetX()); // 42，通过 bind 方法将 this 绑定到 module 上
```

在这个示例中，`getX()` 方法尝试访问对象的属性 `x`。但是，在 `unboundGetX` 被调用时，它作为一个独立的函数被调用，因此 `this` 指向了全局对象，导致无法正确访问 `module` 对象的属性。但是，通过 `bind()` 方法，我们创建了一个新的函数 `boundGetX`，并将 `module` 对象绑定为其执行上下文，因此在调用 `boundGetX` 时，`this` 将指向 `module` 对象，可以正确访问属性 `x`。

### 使用场景：

- 在需要在将函数传递给回调函数或事件处理程序时，确保函数被调用时具有正确的执行上下文。
- 创建一个新的函数，固定函数的部分参数，从而实现函数的柯里化（Currying）。

总之，`Function.prototype.bind()` 方法是用于在函数被调用时指定其执行上下文，并创建一个新函数的方便方法，它在很多情况下都非常有用。

# 特征检测、特征推断和使用 UA 字符串之间有什么区别？
特征检测（Feature Detection）、特征推断（Feature Inference）和使用 UA 字符串（User Agent String）是在前端开发中用于检测浏览器功能和特性的不同方法，它们之间有一些重要的区别。

### 特征检测（Feature Detection）：

- **定义**：特征检测是通过测试浏览器是否支持特定的功能或特性来确定要执行的代码的方法。这通常涉及使用 JavaScript API 或 CSS 属性进行检测。
- **示例**：通过检查某个对象是否存在某个属性或方法来判断浏览器是否支持某项功能。
- **优点**：更可靠，因为它直接检测浏览器是否支持所需功能，而不依赖于浏览器的标识。
- **缺点**：有时需要更多的代码来检测多个浏览器，并且可能需要更新，以适应新的浏览器或版本。

### 特征推断（Feature Inference）：

- **定义**：特征推断是基于已知的功能和特性的组合来推断浏览器的能力的方法。这通常基于对已知特性的假设和判断。
- **示例**：假设浏览器支持某个功能，因为它支持另一个相关的功能。
- **优点**：简单快捷，不需要编写额外的代码。
- **缺点**：不够可靠，因为它依赖于对已知特性的假设，并且可能在某些情况下错误判断。

### 使用 UA 字符串（User Agent String）：

- **定义**：UA 字符串是浏览器发送给服务器的一个字符串，其中包含有关浏览器类型、版本、操作系统等信息。它可以用来识别用户的浏览器。
- **示例**：通过检查 UA 字符串中的浏览器名称和版本来确定浏览器的能力。
- **优点**：简单快速，不需要使用 JavaScript 或其他脚本语言。
- **缺点**：不可靠，因为用户可以更改 UA 字符串，或者使用浏览器插件来修改它。

### 区别：

1. **可靠性**：特征检测是最可靠的方法，因为它直接测试浏览器是否支持所需功能。特征推断和使用 UA 字符串则不够可靠，因为它们可能依赖于假设或用户可能更改的信息。
2. **复杂性**：特征检测可能需要更多的代码，特征推断和使用 UA 字符串则更简单。
3. **速度**：特征检测可能会稍微慢一些，因为它需要运行 JavaScript 来进行测试，而特征推断和使用 UA 字符串则更快速。

在实际开发中，特征检测通常是首选的方法，特别是在处理现代浏览器和旧版本浏览器时。特征推断和使用 UA 字符串则在一些简单的情况下可能更方便，但应谨慎使用，以避免不准确的判断。

# 解释变量提升
变量提升（Hoisting）是 JavaScript 中的一个特性，它指的是在代码执行阶段，JavaScript 引擎会将变量和函数的声明提升到当前作用域的顶部，但是只提升声明，而不提升赋值。

### 变量提升：

在 JavaScript 中，无论变量是在何处声明的，它们都会被视为在当前作用域的顶部声明。这意味着在声明变量之前，可以使用变量，但是该变量的值将为 `undefined`。

#### 示例：

```javascript
console.log(x); // undefined
var x = 5;
console.log(x); // 5
```

在上面的示例中，变量 `x` 虽然在后面才被赋值，但是由于变量提升的存在，JavaScript 引擎会在代码执行前将其声明，因此第一个 `console.log(x)` 输出 `undefined`。

### 函数提升：

除了变量，JavaScript 还会对函数声明进行提升。函数声明会被提升到当前作用域的顶部，因此在函数声明之前就可以调用函数。

#### 示例：

```javascript
foo(); // "Hello, world!"

function foo() {
  console.log("Hello, world!");
}
```

在这个示例中，即使 `foo()` 函数在声明之前被调用，也不会引发错误，因为函数声明会被提升到当前作用域的顶部。

### 注意事项：

1. 只有声明会被提升，赋值不会被提升。
2. 变量提升和函数提升只会发生在当前作用域内，不会跨越块级作用域。

变量提升是 JavaScript 的一个重要特性，但是可能会导致代码出现一些意料之外的行为。因此，建议在代码中始终在作用域的顶部声明变量和函数，以避免出现不必要的问题。

# 什么是类型强制？在 JavaScript 代码中依赖类型强制的常见陷阱有哪些？
类型强制（Type coercion）是指将一个数据类型转换为另一个数据类型的过程。在 JavaScript 中，类型强制是隐式的，它可以在某些操作中自动发生，而无需显式转换。

### 常见的类型强制情况包括：

1. **字符串拼接**：当使用加号（+）将字符串和非字符串值连接在一起时，非字符串值会被强制转换为字符串。

```javascript
console.log("1" + 2); // "12"
console.log(true + " is true"); // "true is true"
```

2. **数值运算**：当对非数值进行数值运算时，JavaScript 会将其强制转换为数值类型。

```javascript
console.log("5" - 2); // 3
console.log("5" * 2); // 10
```

3. **比较运算符**：在使用比较运算符（如==、!=、===、!==、>、<、>=、<=）时，JavaScript 会尝试将操作数转换为相同的类型，然后进行比较。

```javascript
console.log(1 == "1"); // true
console.log(1 === "1"); // false
```

### 常见的类型强制陷阱包括：

1. **比较运算符的隐式类型转换**：使用非严格相等运算符（==）时，可能会导致意外的类型强制，从而产生错误的比较结果。

```javascript
console.log(0 == "0"); // true
console.log(false == ""); // true
console.log(false == "0"); // true
```

2. **字符串拼接的隐式类型转换**：在字符串拼接时，如果不小心将非字符串值拼接到字符串中，可能会产生意外的结果。

```javascript
console.log("10" + 5); // "105"
console.log("10" - 5); // 5
```

3. **数值运算的隐式类型转换**：在数值运算时，如果不小心将非数值类型作为操作数，可能会导致 NaN（Not a Number）的出现。

```javascript
console.log("hello" - 2); // NaN
console.log(undefined * 5); // NaN
```

为了避免类型强制导致的错误，建议使用严格相等运算符（===）进行比较，以及在需要时使用显式类型转换函数（如 parseInt()、parseFloat()、String()）来明确转换数据类型。此外，保持代码清晰和规范，避免隐式类型转换的使用，可以提高代码的可读性和可维护性。

# 描述事件冒泡
事件冒泡（Event Bubbling）是指在 DOM 结构中，当一个事件被触发时，它会从最具体的元素（文档中嵌套层次最深的元素）开始逐级向上传播，直到到达最不具体的元素（通常是文档的根元素）。这意味着如果一个子元素上触发了某个事件，那么这个事件也会在父元素上触发，甚至在更高层次的祖先元素上也会触发，直到到达根元素。

### 事件冒泡的过程：

1. 当在页面上的某个元素上触发一个事件时，该事件首先在该元素上进行处理，然后逐级向上冒泡至父元素。
2. 然后在父元素上触发同样的事件处理程序，然后继续冒泡到更高层次的祖先元素，直到到达文档的根元素（通常是 `<html>` 元素）。

### 示例：

假设页面结构如下：

```html
<html>
<head>
  <title>事件冒泡示例</title>
</head>
<body>
  <div id="outer">
    <div id="inner">点击这里</div>
  </div>
</body>
</html>
```

当在内部元素 `#inner` 上触发点击事件时，事件将会按照如下顺序冒泡：

1. 点击事件在 `#inner` 元素上触发。
2. 事件冒泡到 `#outer` 元素，触发相同的点击事件。
3. 事件继续冒泡到 `<body>` 元素，再到 `<html>` 元素，最终到达文档根元素。

### 用途：

事件冒泡使得可以在更高级别的父元素上捕获到事件，从而实现对整个元素树的统一事件处理。这种特性可以简化事件处理代码，减少代码的重复性，并且使得代码更具灵活性和可维护性。

### 阻止事件冒泡：

有时候需要阻止事件冒泡，可以使用 `event.stopPropagation()` 方法来阻止事件继续冒泡到更高级别的元素。

```javascript
document.getElementById('inner').addEventListener('click', function(event) {
  event.stopPropagation();
  console.log('点击了内部元素');
});
```

总之，事件冒泡是 DOM 事件传播的一种机制，它使得可以在整个元素树上捕获事件，从而实现统一的事件处理。

# 描述事件捕获
事件捕获（Event Capturing）是 DOM 事件传播的另一种阶段，与事件冒泡相对应。在事件捕获阶段，事件从文档的根节点（通常是 `<html>` 元素）开始，逐级向下传播直到到达目标元素。

### 事件捕获的过程：

1. 当在页面上的某个元素上触发一个事件时，事件首先在文档的根元素上进行捕获阶段的处理。
2. 然后在根元素的子元素中继续进行捕获，直到到达目标元素。

### 示例：

假设页面结构如下：

```html
<html>
<head>
  <title>事件捕获示例</title>
</head>
<body>
  <div id="outer">
    <div id="inner">点击这里</div>
  </div>
</body>
</html>
```

当在内部元素 `#inner` 上触发点击事件时，事件将会按照如下顺序捕获：

1. 点击事件在文档的根元素 `<html>` 上进行捕获阶段的处理。
2. 事件继续向下捕获到 `<body>` 元素。
3. 事件继续向下捕获到 `#outer` 元素，最终到达目标元素 `#inner`。

### 用途：

事件捕获通常用于在事件到达目标元素之前对其进行预处理或拦截。它可以用于实现一些特殊的事件处理逻辑，或者在事件传播到达目标元素之前阻止其继续传播。

### 事件监听器的捕获阶段：

在使用 `addEventListener()` 方法添加事件监听器时，可以通过指定第三个参数为 `true` 来启用事件捕获阶段的监听器。

```javascript
document.getElementById('inner').addEventListener('click', function(event) {
  console.log('点击了内部元素');
}, true);
```

在这个示例中，事件监听器在捕获阶段被触发，因此会在事件传播到达目标元素之前被执行。

总之，事件捕获是 DOM 事件传播的一种阶段，它在事件传播到达目标元素之前捕获到事件，可以用于对事件进行预处理或拦截。

# 解释与 JavaScript 相关的同源策略
同源策略（Same-Origin Policy）是一个重要的 Web 安全策略，它是浏览器中实施的一种安全机制，用于限制一个网页文档或脚本如何与来自不同源（域名、协议或端口）的资源进行交互。

### 同源的定义：

两个 URL 具有相同的源（即同源），当且仅当它们具有相同的协议（scheme）、主机（host）和端口号（port）。

例如，以下两个 URL 是同源的：

- http://example.com/index.html
- http://example.com/script.js

但以下两个 URL 是不同源的：

- http://example.com/index.html
- https://example.com/index.html
- http://example.com/index.html
- http://api.example.com/index.html

### 同源策略的限制：

1. **脚本访问**：一个页面中的脚本（如 JavaScript）只能访问与该页面具有相同源的脚本。这意味着页面上的脚本无法通过 AJAX 请求或 DOM 操作访问其他源的文档或脚本。
2. **Cookie 和 LocalStorage**：浏览器会根据同源策略限制页面对其他源的 Cookie 和 LocalStorage 的读写访问。这意味着页面无法读取其他源下的 Cookie 和 LocalStorage 数据。
3. **DOM 访问**：浏览器通过 DOM API 实施同源策略，禁止页面通过 JavaScript 访问其他源的 DOM。

### 同源策略的目的：

同源策略的目的是保护用户的信息安全和隐私，防止恶意网站通过脚本访问其他网站的敏感信息，从而避免跨站点脚本攻击（Cross-Site Scripting，XSS）和跨站点请求伪造（Cross-Site Request Forgery，CSRF）等安全威胁。

### 如何突破同源策略：

尽管同源策略提供了很好的安全保护，但有时确实需要在不同源之间进行数据交换。为了实现跨域通信，可以使用以下方法：

1. **跨域资源共享（CORS）**：通过在服务器上配置 CORS 头部来允许特定源的跨域请求。
2. **JSONP**：通过动态创建 `<script>` 标签来实现跨域请求。
3. **代理服务器**：在服务器端设置代理，将客户端的请求发送到另一个源，然后将响应返回给客户端。
4. **WebSocket**：使用 WebSocket 协议进行双向通信，不受同源策略的限制。

总之，同源策略是浏览器中实施的一种安全机制，用于限制页面对其他源资源的访问，从而保护用户的信息安全和隐私。

# 什么是严格模式？使用它有哪些优点/缺点？
严格模式（Strict Mode）是 ECMAScript 5 引入的一种新的 JavaScript 运行模式，它通过一些限制和改变 JavaScript 的语法和语义，从而帮助开发者编写更安全、更规范的代码。

### 启用严格模式的方法：

可以在脚本的顶部或函数的顶部通过添加 `"use strict";` 来启用严格模式。

```javascript
"use strict";

// 严格模式下的代码
```

### 严格模式的优点：

1. **提供更严格的语法检查**：严格模式会抛出更多的错误，例如对于使用未声明的变量、重复的函数参数名称等，有助于捕获潜在的错误。
2. **提高代码的运行速度**：由于取消了一些 JavaScript 引擎优化的操作，严格模式下的代码可能会更快地执行。
3. **提供更安全的代码**：严格模式下取消了一些危险的 JavaScript 功能，例如禁止使用 `eval()`、`with` 语句，以及对全局变量赋值的限制等，有助于防止一些常见的安全问题。

### 严格模式的缺点：

1. **不兼容性**：严格模式可能会与一些旧版的 JavaScript 代码不兼容，需要对现有代码进行修改才能启用严格模式。
2. **限制的变化**：一些对旧版 JavaScript 的非标准行为被严格模式修复，可能会影响到一些依赖这些行为的代码。
3. **代码变得更冗长**：由于严格模式增加了对一些代码的限制，可能会导致一些代码变得更冗长，增加了编写和维护的成本。

总的来说，严格模式可以帮助开发者编写更安全、更规范的 JavaScript 代码，提高代码质量和性能。然而，在启用严格模式之前，需要仔细评估其对现有代码的影响，以及是否值得为此进行修改。

# 解释可变对象和不可变对象之间的区别
在编程语言中，可变对象（Mutable Object）和不可变对象（Immutable Object）是两种不同的数据类型，它们在被创建后的行为和特性上有所不同。

### 可变对象（Mutable Object）：

可变对象是指在创建后其内容或状态可以被修改或改变的对象。这意味着可以向可变对象添加、删除或修改其属性或元素，而不会创建一个全新的对象。

#### 示例：

在许多编程语言中，数组和对象通常是可变对象。例如，在 JavaScript 中：

```javascript
let arr = [1, 2, 3];
arr.push(4); // 可以向数组添加新的元素
```

### 不可变对象（Immutable Object）：

不可变对象是指在创建后其内容或状态不可被修改或改变的对象。这意味着不能向不可变对象添加、删除或修改其属性或元素，任何对对象的更改操作都会返回一个新的对象。

#### 示例：

在许多编程语言中，字符串、数字和元组等数据类型通常是不可变对象。例如，在 Python 中：

```python
str1 = "Hello"
str2 = str1 + " World"  # 对字符串进行连接会创建一个新的字符串对象
```

### 区别：

1. **数据变更**：可变对象允许在其创建后修改其内容或状态，而不可变对象不允许这样的修改。
2. **性能**：不可变对象在被创建后无法更改，因此在并发环境下更容易进行线程安全的操作，并且可以进行更多的优化以提高性能。
3. **预测性**：由于不可变对象的状态不会改变，因此在编写和调试代码时更容易预测其行为。

### 何时选择使用可变对象和不可变对象：

- **可变对象**通常更灵活，并且在需要频繁地修改对象内容或状态时更适用。但是，需要注意在并发环境下可能会导致一些问题，例如竞态条件（Race Condition）和数据不一致性等。
- **不可变对象**通常更安全，并且更容易在函数式编程中进行推理和优化。它们也更适合在并发环境下使用，因为它们不会改变状态，从而避免了一些并发问题。

在选择可变对象和不可变对象时，需要根据具体的需求和场景来决定哪种类型更适合。

# 解释可变对象和不可变对象之间的区别，以及如何在自己的代码中实现不变性
可变对象（Mutable Object）和不可变对象（Immutable Object）是两种不同的数据类型，它们在被创建后的行为和特性上有所不同。

### 区别：

1. **数据修改**：
    - **可变对象**：在创建后，可变对象的内容或状态可以被修改或改变。可以向可变对象添加、删除或修改其属性或元素。
    - **不可变对象**：在创建后，不可变对象的内容或状态不能被修改或改变。任何对对象的修改操作都会返回一个新的对象，原始对象保持不变。

2. **性能影响**：
    - **可变对象**：由于可变对象的内容可以被修改，因此可能会在内存中频繁地分配和释放空间，可能会导致性能问题。
    - **不可变对象**：由于不可变对象的内容不可变，因此在创建后无需担心其内容会被修改，可以进行更多的优化以提高性能。

3. **并发安全性**：
    - **可变对象**：在并发环境下，多个线程同时修改可变对象可能会导致竞态条件（Race Condition）和数据不一致性等问题。
    - **不可变对象**：由于不可变对象的内容不可变，因此更容易实现线程安全，避免了一些并发问题。

### 实现不变性的方法：

在自己的代码中实现不变性可以通过以下方式：

1. **使用不可变数据结构**：使用语言或库中提供的不可变数据结构，例如不可变列表、不可变映射等。这些数据结构在修改操作时会返回一个新的对象，而不会修改原始对象。

2. **深拷贝**：在需要修改对象时，先对原始对象进行深拷贝，然后对拷贝后的对象进行修改操作，从而保持原始对象的不变性。

3. **限制可变对象的访问权限**：在设计对象时，尽量将对象的状态设置为私有，并提供只读的接口，从而限制外部代码对对象内容的修改。

4. **使用不可变操作**：尽可能使用不可变操作，避免直接修改可变对象的内容。例如，避免使用直接赋值、数组的 `push()`、`pop()`、`splice()` 等修改方法，而使用不可变的操作方法，例如 `concat()`、`slice()` 等。

5. **使用函数式编程思想**：函数式编程强调纯函数和不可变性，尽可能避免对数据进行修改，而是创建新的数据。采用函数式编程思想可以更容易地实现不变性。

实现不变性可以帮助减少代码中的错误和 bug，提高代码的可维护性和可读性，以及降低在并发环境中出现的问题。

# 解释同步函数和异步函数之间的区别
同步函数和异步函数是指在执行过程中的行为方式不同的函数。它们的主要区别在于函数的执行是否会阻塞代码的执行。

### 同步函数（Synchronous Function）：

同步函数是指在函数执行过程中，代码会按顺序一行一行地执行，直到函数执行完毕并返回结果之后，才会继续执行后续的代码。在同步函数执行期间，代码执行是阻塞的，即后续的代码必须等待同步函数执行完毕才能执行。

#### 示例：

```javascript
function syncFunction() {
    console.log("Start");
    // 模拟同步操作，耗时 2 秒
    for (let i = 0; i < 2000000000; i++) {}
    console.log("End");
}

console.log("Before");
syncFunction();
console.log("After");
```

在上述示例中，"Start"、"End"、"Before" 和 "After" 的输出顺序是固定的，因为同步函数的执行是阻塞的。

### 异步函数（Asynchronous Function）：

异步函数是指在函数执行过程中，代码会立即返回（即不会等待函数执行完毕），而函数的执行通常是在后台进行的，当函数执行完成后，会通过回调函数、Promise、async/await 等机制来处理执行结果。

#### 示例：

```javascript
function asyncFunction() {
    console.log("Start");
    // 模拟异步操作，1 秒后执行回调函数
    setTimeout(() => {
        console.log("Async operation completed");
    }, 1000);
    console.log("End");
}

console.log("Before");
asyncFunction();
console.log("After");
```

在上述示例中，"Start"、"End"、"Before" 和 "After" 的输出顺序不是固定的，因为异步函数的执行不会阻塞后续代码的执行。

### 区别总结：

- **执行方式**：同步函数按顺序一行一行地执行，而异步函数会立即返回，函数的执行通常是在后台进行的。
- **阻塞性**：同步函数的执行是阻塞的，会阻塞后续代码的执行，而异步函数不会阻塞后续代码的执行。
- **回调处理**：异步函数执行完成后通常需要通过回调函数、Promise、async/await 等方式来处理执行结果。

在编写代码时，需要根据实际需求选择使用同步函数还是异步函数，以确保代码的正确性和性能。通常来说，对于耗时较长的操作（如网络请求、文件读写等），建议使用异步函数，以避免阻塞代码的执行。

# 什么是事件循环？调用堆栈和任务队列有什么区别？
事件循环（Event Loop）是 JavaScript 运行时的一个重要概念，它负责管理代码的执行顺序和异步操作的处理。调用堆栈（Call Stack）和任务队列（Task Queue）是事件循环中的两个关键组成部分，它们各自具有不同的作用。

### 调用堆栈（Call Stack）：

调用堆栈是一个存储函数调用的栈结构，它用于跟踪函数的执行上下文（Execution Context）。每当执行一个函数时，都会在调用堆栈中创建一个对应的执行上下文，并将该函数的调用信息推入栈顶，当函数执行完毕后，执行上下文会从栈顶弹出。

#### 特点：
- 同步代码的执行顺序由调用堆栈决定。
- 调用堆栈是单线程的，一次只能执行一个函数。

### 任务队列（Task Queue）：

任务队列是一个存储异步任务的队列，它用于存放在调用堆栈中执行完毕的异步操作及其回调函数。例如，setTimeout、Promise.then、事件回调等异步任务会被放入任务队列中等待执行。

#### 特点：
- 任务队列中的任务不会立即执行，而是等待调用堆栈为空时才会被执行。
- 任务队列中的任务按照先进先出（FIFO）的顺序执行。

### 事件循环（Event Loop）：

事件循环是一个持续运行的进程，它负责不断地从任务队列中取出任务，推入调用堆栈中执行。事件循环的主要作用是保证 JavaScript 的异步操作能够按照正确的顺序执行。

#### 运行机制：
1. 首先，事件循环会检查调用堆栈是否为空。
2. 如果调用堆栈为空，则事件循环会从任务队列中取出一个任务，推入调用堆栈中执行。
3. 当任务执行完毕后，如果任务队列中还有其他任务，则事件循环会重复上述步骤。

### 区别：

- **调用堆栈**：负责跟踪函数的执行上下文，决定同步代码的执行顺序。
- **任务队列**：存放异步任务和其回调函数，等待调用堆栈为空时执行。
- **事件循环**：负责不断地从任务队列中取出任务，推入调用堆栈中执行，以确保异步任务按正确的顺序执行。

综上所述，调用堆栈和任务队列是事件循环中的两个重要组成部分，它们共同协作来保证 JavaScript 的异步操作能够按照正确的顺序执行。

# ES6 类和 ES5 函数构造函数有什么区别
ES6 类（Class）和 ES5 函数构造函数（Constructor Function）都是 JavaScript 中用于创建对象的方式，但它们之间有一些区别。

### ES6 类（Class）：

ES6 引入了类的概念，使得 JavaScript 的面向对象编程更加简洁和直观。类可以看作是一种语法糖，它在底层仍然是基于原型继承实现的。

#### 特点：
1. **语法糖**：类是一种语法糖，它提供了更加直观和易于理解的语法来定义对象和继承关系。
2. **类方法**：通过在类中定义方法，可以更容易地组织和管理对象的行为。
3. **构造函数**：类可以包含构造函数，用于初始化对象的实例。
4. **继承**：类支持使用 `extends` 关键字来实现继承，使得子类可以继承父类的属性和方法。

#### 示例：

```javascript
class Person {
    constructor(name) {
        this.name = name;
    }

    sayHello() {
        console.log(`Hello, my name is ${this.name}`);
    }
}

let person = new Person("Alice");
person.sayHello(); // 输出：Hello, my name is Alice
```

### ES5 函数构造函数（Constructor Function）：

在 ES5 中，常常使用函数构造函数来创建对象，并通过原型继承来实现对象之间的关系。

#### 特点：
1. **函数构造函数**：通过函数构造函数来创建对象，通常在函数内部使用 `this` 关键字来指向新创建的对象。
2. **原型继承**：通过在原型对象上定义属性和方法，实现对象之间的继承关系。
3. **没有类的概念**：在 ES5 中没有类的概念，对象和继承是通过函数和原型来实现的。

#### 示例：

```javascript
function Person(name) {
    this.name = name;
}

Person.prototype.sayHello = function() {
    console.log(`Hello, my name is ${this.name}`);
};

let person = new Person("Bob");
person.sayHello(); // 输出：Hello, my name is Bob
```

### 区别总结：

1. **语法**：ES6 类提供了更加简洁和易于理解的语法，而 ES5 函数构造函数的语法相对更加繁琐。
2. **继承**：ES6 类支持使用 `extends` 关键字来实现继承，而 ES5 函数构造函数通过原型链来实现继承。
3. **可读性**：ES6 类更加直观和易于理解，适合于面向对象编程的场景，而 ES5 函数构造函数在一些情况下可读性较差。

综上所述，ES6 类和 ES5 函数构造函数都是 JavaScript 中用于创建对象的方式，选择哪种方式取决于个人的编程习惯和项目需求。

# 您能否提供新箭头函数=>语法的用例？这个新语法与其他函数有何不同？
当然可以！箭头函数（Arrow Function）是 ES6 中引入的一种新的函数定义语法，它提供了更简洁的语法来声明函数，并且改变了函数内部的 `this` 绑定规则。

### 箭头函数的语法：

箭头函数使用 `=>` 符号来定义，语法形式如下：

```javascript
(param1, param2, ...) => { statements }
```

其中，`param1, param2, ...` 是函数的参数列表，`{ statements }` 是函数体，可以是一个表达式或一系列语句。

### 用例：

1. **基本用法**：

```javascript
// 传统函数
function add(a, b) {
    return a + b;
}

// 箭头函数
let addArrow = (a, b) => a + b;

console.log(add(2, 3));        // 输出：5
console.log(addArrow(2, 3));   // 输出：5
```

2. **单个参数的简写**：

```javascript
// 传统函数
function square(x) {
    return x * x;
}

// 箭头函数
let squareArrow = x => x * x;

console.log(square(4));        // 输出：16
console.log(squareArrow(4));   // 输出：16
```

3. **返回对象字面量**：

```javascript
// 传统函数
function createPerson(name, age) {
    return {
        name: name,
        age: age
    };
}

// 箭头函数
let createPersonArrow = (name, age) => ({ name: name, age: age });

console.log(createPerson("Alice", 30));         // 输出：{ name: 'Alice', age: 30 }
console.log(createPersonArrow("Bob", 25));      // 输出：{ name: 'Bob', age: 25 }
```

### 与其他函数的不同：

1. **this 绑定**：箭头函数没有自己的 `this` 绑定，它会捕获所在上下文的 `this` 值，并且不能通过 `bind()`、`call()`、`apply()` 方法来改变 `this` 的值。

2. **arguments 对象**：箭头函数没有自己的 `arguments` 对象，但可以访问外部函数的 `arguments` 对象。

3. **没有 `new.target`**：箭头函数没有自己的 `new.target` 值，它的 `new.target` 值指向外层函数的 `new.target` 值或者 `undefined`。

4. **不能作为构造函数**：箭头函数不能用作构造函数，不能通过 `new` 关键字来实例化。

箭头函数通常更适用于简单的函数表达式和回调函数，由于其简洁的语法和更直观的 `this` 绑定规则，使得代码更易读和维护。然而，在某些情况下，传统的函数声明和表达式仍然更适用，特别是在需要自己的 `this` 绑定和使用 `arguments` 对象时。

# 在构造函数中对方法使用箭头语法有什么好处？
在构造函数中使用箭头语法定义方法可能并不是一个好主意，因为箭头函数具有词法作用域的 `this` 绑定。这意味着在箭头函数中，`this` 的值是在定义函数时确定的，而不是在运行时确定的。因此，在构造函数中使用箭头函数定义方法会导致以下问题：

1. **错误的 `this` 绑定**：在箭头函数中，`this` 绑定到了定义该箭头函数的词法作用域，通常是在创建对象时的作用域。这意味着在使用箭头函数定义的方法中，`this` 将不会指向实例化的对象，而是指向构造函数的作用域，这通常不是预期的行为。

2. **不能使用 `new` 关键字**：由于箭头函数不能作为构造函数使用，因此无法通过 `new` 关键字来实例化对象。如果在构造函数中使用箭头函数定义方法，那么无法通过 `new` 关键字来创建实例，这可能会导致意外行为或错误。

因此，通常建议在构造函数中使用传统的函数语法来定义方法，以确保正确的 `this` 绑定和能够通过 `new` 关键字来实例化对象。箭头函数更适合用于非构造函数的场景，例如普通函数或对象方法的定义，这样可以更清晰地表达函数的意图并避免混淆。

# 高阶函数的定义是什么？
高阶函数（Higher-Order Function）是指接受一个或多个函数作为参数，并/或者返回一个新函数的函数。换句话说，它是操作其他函数的函数。

### 特征：

1. **接受函数作为参数**：高阶函数可以接受一个或多个函数作为参数，用于对传入的函数进行操作或处理。

2. **返回函数**：高阶函数可以返回一个新的函数，这个函数可以是原始函数的改造或者是根据传入参数生成的新函数。

### 示例：

#### 接受函数作为参数：

```javascript
// 高阶函数，接受一个函数作为参数
function map(array, fn) {
    let result = [];
    for (let i = 0; i < array.length; i++) {
        result.push(fn(array[i]));
    }
    return result;
}

// 定义一个函数，用于将数组中的元素转为大写
function toUpperCase(str) {
    return str.toUpperCase();
}

let arr = ["apple", "banana", "orange"];
let newArr = map(arr, toUpperCase); // 使用高阶函数 map 将数组中的每个元素转为大写
console.log(newArr); // 输出：["APPLE", "BANANA", "ORANGE"]
```

#### 返回函数：

```javascript
// 高阶函数，返回一个新函数
function createLogger(prefix) {
    return function(message) {
        console.log(`[${prefix}] ${message}`);
    };
}

let infoLogger = createLogger("INFO"); // 创建一个输出信息日志的函数
let errorLogger = createLogger("ERROR"); // 创建一个输出错误日志的函数

infoLogger("User logged in"); // 输出：[INFO] User logged in
errorLogger("Failed to connect to database"); // 输出：[ERROR] Failed to connect to database
```

在上述示例中，`map` 函数和 `createLogger` 函数都是高阶函数。`map` 函数接受一个函数作为参数，用于对数组中的每个元素进行转换；`createLogger` 函数返回一个新的函数，用于输出带有特定前缀的日志信息。

通过使用高阶函数，可以使代码更加灵活和可复用，提高代码的抽象程度和可维护性。

# 你能给出一个解构对象或数组的例子吗？
当你需要从对象或数组中提取数据并将其赋值给变量时，解构赋值（Destructuring Assignment）是一种非常方便的方式。下面是一个解构对象和数组的例子：

### 解构对象：

```javascript
// 定义一个对象
const person = {
    name: 'John',
    age: 30,
    country: 'USA'
};

// 从对象中解构出变量
const { name, age, country } = person;

console.log(name);     // 输出：'John'
console.log(age);      // 输出：30
console.log(country);  // 输出：'USA'
```

在这个例子中，`{ name, age, country } = person` 表示从 `person` 对象中解构出 `name`、`age` 和 `country` 这三个属性，并分别赋值给变量 `name`、`age` 和 `country`。

### 解构数组：

```javascript
// 定义一个数组
const colors = ['red', 'green', 'blue'];

// 从数组中解构出变量
const [firstColor, secondColor, thirdColor] = colors;

console.log(firstColor);   // 输出：'red'
console.log(secondColor);  // 输出：'green'
console.log(thirdColor);   // 输出：'blue'
```

在这个例子中，`[firstColor, secondColor, thirdColor] = colors` 表示从 `colors` 数组中解构出第一个元素赋值给 `firstColor`、第二个元素赋值给 `secondColor`、第三个元素赋值给 `thirdColor`。

解构赋值能够简化代码，使得从对象和数组中提取数据更加方便和直观。

# 你能举一个使用 ES6 模板文字生成字符串的例子吗？
当你需要动态生成字符串时，ES6 模板字符串（Template Literals）是一种非常方便的方式。它允许你在字符串中插入变量、表达式，并且支持多行字符串的书写。下面是一个使用 ES6 模板字符串生成字符串的例子：

```javascript
// 定义变量
const name = 'Alice';
const age = 25;

// 使用模板字符串生成字符串
const greeting = `Hello, my name is ${name} and I am ${age} years old.`;

console.log(greeting);
```

在这个例子中，反引号（``）用于定义模板字符串，`${}` 用于插入变量或表达式。在 `${}` 内部可以放置任何合法的 JavaScript 表达式，它会被求值并替换为对应的结果。最后，将生成的字符串赋值给变量 `greeting`，并输出结果。

运行上述代码，输出结果将是：

```
Hello, my name is Alice and I am 25 years old.
```

使用 ES6 模板字符串能够使得字符串的生成更加简洁和可读，特别是在需要动态拼接字符串的情况下，可以提高代码的可维护性。

# 你能给出一个 curry 函数的例子并说明为什么这种语法具有优势吗？
Currying 是一种将接受多个参数的函数转换为一系列接受单个参数的函数的技术。这种技术使得函数具有更高的灵活性和可组合性。下面是一个简单的 curry 函数的例子：

```javascript
// Curry 函数
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function(...nextArgs) {
                return curried.apply(this, args.concat(nextArgs));
            };
        }
    };
}

// 示例函数
function add(a, b, c) {
    return a + b + c;
}

// 使用 curry 函数对示例函数进行柯里化
const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)); // 输出：6
console.log(curriedAdd(1, 2)(3)); // 输出：6
console.log(curriedAdd(1)(2, 3)); // 输出：6
console.log(curriedAdd(1, 2, 3)); // 输出：6
```

在上面的例子中，curry 函数接受一个函数作为参数，并返回一个新的函数，这个新函数接受任意数量的参数，并根据原始函数的参数数量来判断何时执行原始函数。

Currying 的优势包括：

1. **参数复用**：Currying 可以将多参数函数转换为一系列单参数函数，使得参数可以被复用。这意味着可以轻松地创建新的函数，这些函数在某些参数固定的情况下可以重复使用。

2. **函数组合**：Currying 使得函数的组合变得更加容易。通过将一个函数的输出作为另一个函数的输入，可以创建复杂的函数组合，从而实现更高层次的抽象和模块化。

3. **延迟执行**：Currying 可以延迟函数的执行，使得函数在接收到所有参数之后才执行。这种延迟执行的特性可以用于惰性求值等场景，提高程序的性能和效率。

总的来说，Currying 是一种非常有用的技术，它使得函数更具灵活性和可组合性，能够简化代码并提高代码的可读性和可维护性。

# 使用spread syntax有什么好处以及它与rest syntax有何不同？
Spread 语法（展开语法）和 Rest 语法（剩余参数语法）都是 ES6 中引入的语法特性，它们分别用于处理数组和对象中的元素或属性。它们之间的主要区别在于使用的上下文和语法。

### Spread 语法：

Spread 语法用于将数组或对象“展开”为单独的元素或属性。在数组中，它可以将数组中的元素展开为单独的值，而在对象中，它可以将对象中的属性展开为单独的键值对。

#### 示例：

```javascript
// Spread 语法在数组中的应用
const array1 = [1, 2, 3];
const array2 = [...array1, 4, 5];

console.log(array2); // 输出：[1, 2, 3, 4, 5]

// Spread 语法在对象中的应用
const obj1 = { foo: 'bar' };
const obj2 = { ...obj1, baz: 'qux' };

console.log(obj2); // 输出：{ foo: 'bar', baz: 'qux' }
```

### Rest 语法：

Rest 语法用于将一系列元素或属性“收集”为一个数组或对象。它通常用于函数的参数列表中，用于处理不定数量的参数。

#### 示例：

```javascript
// Rest 语法在函数参数中的应用
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 输出：15
```

### 区别：

1. **上下文**：Spread 语法用于展开数组或对象，而 Rest 语法用于收集参数或属性。

2. **语法**：Spread 语法使用三个点（`...`）作为前缀，放置在数组或对象之前，而 Rest 语法也使用三个点（`...`），但是放置在函数参数列表中的形参前。

3. **应用场景**：Spread 语法通常用于创建新的数组或对象，或者在函数调用中传递多个参数。而 Rest 语法通常用于处理不定数量的参数，将它们收集为一个数组或对象。

总的来说，Spread 语法和 Rest 语法在处理数组和对象时提供了更加灵活和简洁的方式，能够简化代码并提高开发效率。它们是 ES6 中非常实用的语法特性之一。

# 讨论在使用 JavaScript 编码时如何使用面向对象编程原则
在 JavaScript 中使用面向对象编程（OOP）原则可以帮助你更好地组织和管理代码，提高代码的可维护性、可复用性和可扩展性。下面是一些在 JavaScript 编码中如何使用面向对象编程原则的建议：

### 1. 封装（Encapsulation）：

封装是指将数据和操作封装在一个对象中，通过暴露公共接口来访问和操作数据，而隐藏内部实现细节。在 JavaScript 中，你可以使用闭包、私有变量和方法，或者 ES6 中的类来实现封装。

```javascript
// 使用闭包实现封装
function Counter() {
    let count = 0;

    this.increment = function() {
        count++;
    };

    this.getCount = function() {
        return count;
    };
}

const counter = new Counter();
counter.increment();
console.log(counter.getCount()); // 输出：1
```

### 2. 继承（Inheritance）：

继承是指通过创建新的类（子类）来复用现有类（父类）的属性和方法。在 JavaScript 中，你可以使用原型链继承、类继承或者混合继承来实现继承。

```javascript
// 使用原型链继承实现继承
function Animal(name) {
    this.name = name;
}

Animal.prototype.walk = function() {
    console.log(`${this.name} is walking.`);
};

function Dog(name, breed) {
    Animal.call(this, name);
    this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
    console.log(`${this.name} is barking.`);
};

const dog = new Dog('Buddy', 'Golden Retriever');
dog.walk(); // 输出：Buddy is walking.
dog.bark(); // 输出：Buddy is barking.
```

### 3. 多态（Polymorphism）：

多态是指对象可以根据上下文采用不同的行为。在 JavaScript 中，你可以通过方法重写或者函数覆盖来实现多态。

```javascript
class Shape {
    draw() {
        console.log('Drawing a shape.');
    }
}

class Circle extends Shape {
    draw() {
        console.log('Drawing a circle.');
    }
}

class Square extends Shape {
    draw() {
        console.log('Drawing a square.');
    }
}

const shapes = [new Circle(), new Square()];

shapes.forEach(shape => shape.draw());
// 输出：
// Drawing a circle.
// Drawing a square.
```

### 总结：

使用面向对象编程原则可以使 JavaScript 代码更加模块化、可扩展和可维护。封装可以隐藏内部实现细节，继承可以实现代码复用，而多态可以使对象更具灵活性。然而，在实践中，需要根据具体情况选择合适的设计模式和实现方式，以确保代码的可读性和性能。

# event.target和 event.currentTarget和有什么区别
在 JavaScript 中，事件对象（Event Object）包含了有关事件的各种信息，其中包括 `event.target` 和 `event.currentTarget`，它们都代表了触发事件的元素，但它们之间有一些区别。

### event.target：

- `event.target` 属性返回触发事件的元素，即事件最初发生的目标元素。
- 对于直接触发事件的元素而言，`event.target` 和 `this` 指向相同的元素。
- 如果事件是由子元素触发并冒泡到父元素，则 `event.target` 是子元素，而不是父元素。

### event.currentTarget：

- `event.currentTarget` 属性返回绑定事件处理程序的元素，即事件当前正在处理的元素。
- 在事件冒泡阶段，`event.currentTarget` 始终指向绑定事件处理程序的元素。
- 与 `event.target` 不同，`event.currentTarget` 不会随着事件的冒泡而改变，它始终保持不变。

#### 示例：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Event Target vs CurrentTarget</title>
    <style>
        div {
            padding: 20px;
            margin: 10px;
            background-color: lightblue;
        }
    </style>
</head>
<body>
    <div id="outer">
        <div id="inner">Click me</div>
    </div>

    <script>
        document.getElementById('outer').addEventListener('click', function(event) {
            console.log('Target:', event.target.id); // 输出：inner
            console.log('Current Target:', event.currentTarget.id); // 输出：outer
        });
    </script>
</body>
</html>
```

在这个示例中，当点击内部 `<div>` 元素时，`event.target` 是指向被点击的 `<div>` 元素，即内部 `<div>` 元素，而 `event.currentTarget` 始终指向外部 `<div>` 元素。

# event.preventDefault()和event.stopPropagation()和有什么区别？
`event.preventDefault()` 和 `event.stopPropagation()` 都是用于处理事件对象的方法，它们之间有着不同的作用和效果。

### event.preventDefault()：

- `event.preventDefault()` 方法用于阻止事件的默认行为，即取消事件的默认动作。
- 常见的默认行为包括表单提交、链接跳转、按钮点击等。
- 在事件处理程序中调用 `event.preventDefault()` 可以防止默认行为的发生。
- 该方法通常用于避免页面的刷新、防止表单的提交、取消链接的跳转等。

#### 示例：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>event.preventDefault()</title>
</head>
<body>
    <a href="https://www.example.com" id="link">Click me</a>

    <script>
        document.getElementById('link').addEventListener('click', function(event) {
            event.preventDefault(); // 阻止链接的默认跳转行为
            console.log('Link clicked, but default behavior prevented.');
        });
    </script>
</body>
</html>
```

### event.stopPropagation()：

- `event.stopPropagation()` 方法用于停止事件的传播，即阻止事件继续向父元素或者祖先元素传播。
- 如果一个元素上绑定了多个事件处理程序，并且其中一个事件处理程序调用了 `event.stopPropagation()` 方法，那么其他绑定的事件处理程序将不会被触发。
- 这个方法只会阻止事件在 DOM 树上的传播，不会影响事件的默认行为。

#### 示例：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>event.stopPropagation()</title>
    <style>
        div {
            padding: 20px;
            margin: 10px;
            background-color: lightblue;
        }
    </style>
</head>
<body>
    <div id="outer">
        <div id="inner">Click me</div>
    </div>

    <script>
        document.getElementById('inner').addEventListener('click', function(event) {
            event.stopPropagation(); // 阻止事件冒泡到外部 div 元素
            console.log('Inner div clicked, event propagation stopped.');
        });

        document.getElementById('outer').addEventListener('click', function(event) {
            console.log('Outer div clicked.');
        });
    </script>
</body>
</html>
```

在这个示例中，当点击内部 `<div>` 元素时，`event.stopPropagation()` 阻止了事件冒泡到外部 `<div>` 元素，因此外部 `<div>` 元素的点击事件不会被触发。


# AJAX、axios、fetch的区别

**AJAX**

Gmail开发人员发现IE里面有个XMLHTTPRequest对象来请求数据时，可以实现无刷新数据请求，所以使用这个特性，进行网络数据请求，这就是AJAX的由来。

AJAX不是一个单词，他的全称是Asynchronous JavaScript and XML，就是异步的JavaScript和XML，它是一套用于创建快速动态网页的技术标准，使用步骤如下：

1. 创建异步XMLHttpRequest对象
2. 设置请求参数，包括请求的方法和URL等
3. 发送请求
4. 注册事件，事件状态变更会及时响应监听
5. 在监听里面获取并处理返回数据

所以AJAX的核心就是XMLHttpRequest对象，这是一个非常早的实现方法，也是兼容性最好的，已经成为了浏览器标准，虽然我们现在都使用其它的API规范，但对象名字暂时还是用XML命名



**axios**

axios是一个基于Promise的HTTP库，可以用在浏览器和node.js中，它底层还是基于XMLHttpRequest对象的，你可以认为它是一个方便的封装库，除了基础请求数据，它还增加了如下功能：

1. 对PromiseAPI的支持
2. 支持请求拦截和响应、转换请求数据和响应数据、取消请求
3. 可以自动转换JSON数据
4. 支持防御XSRF

**fetch**

fetch就不是XMLHttpRequest对象了，fetch是原生的js对象，也就是说，它不依赖浏览器，fetch提供了一个理解的请求替换方案，可以提供给其它技术使用。我们主要需要了解下fetch和ajax的本质区别：

1. fetch返回的是Promise，所以如果HTTP状态码是404之类的，fetch也是成功返回的，只有在网络连接错误的情况下，才会reject
2. fetch不发送cookies

fetch的请求写法会比AJAX简单许多，但我想，最主要的问题是，无法区分HTTP状态码了，这个在编程时还是比较常用的，所以我们目前还是使用axios比较多，而很少使用fetch


# JS函数柯里化

把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

好处：参数复用、延迟执行 bind方法的底层实现

```js
function sub_curry(fn) {
  var args = [].slice.call(arguments, 1);
  return function() {
    return fn.apply(this, args.concat([].slice.call(arguments)));
  };
}

function curry(fn, length) {

  length = length || fn.length;

  var slice = Array.prototype.slice;

  return function() {
    if (arguments.length < length) {
      var combined = [fn].concat(slice.call(arguments));
      return curry(sub_curry.apply(this, combined), length - arguments.length);
    } else {
      return fn.apply(this, arguments);
    }
  };
}
```

这是基于MVC的JavaScript Web富应用开发的`bind()`方法实现：

```js
Function.prototype.bind = function(oThis) {
  if (typeof this !== "function") {
    throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
  }

  var aArgs = Array.prototype.slice.call(arguments, 1),
    fToBind = this,
    fNOP = function() {},
    fBound = function() {
      return fToBind.apply(
        this instanceof fNOP && oThis ? this : oThis || window,
        aArgs.concat(Array.prototype.slice.call(arguments))
      );
    };

  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();

  return fBound;
};
```

# JavaScript的this指向问题

### 默认绑定

- 全局环境下，this默认绑定到window

```js
console.log(this === window); //true
```

- 函数独立调用时，this默认绑定到window

```js
function foo(){
    console.log(this === window);
}
foo();//true
```

- 被嵌套的函数独立调用时，this默认绑定到window

```javascript
var a = 0;
var obj = {
    a : 2,
    foo : function (){
        function test(){
            console.log(this);
        }
        test();
    }
}
obj.foo();
```

上面代码虽然`test()`函数被嵌套在`obj.foo()`函数中，但`test()`函数是独立调用，而不是方法调用。所以this默认绑定到window

### **立即执行函数**

实际是函数声明后立即调用执行，内部的this指向了window

```js
var a = 0;
function foo(){
    (function test(){
        console.log(this.a);
    })()
};
var obj = {
    a : 2,
    foo:foo
}
obj.foo();//0
```

等价于上例

```js
var a = 0;
var obj = {
    a : 2,
    foo : function(){
        function test(){
            console.log(this.a);
        }
        test();
    }
}
obj.foo();//0
```

### **闭包**

类似地，`test()`函数是独立调用，而不是方法调用，所以this默认绑定到window

> 注意：函数共有4中调用方法

```js
var a = 0;
function foo() {
    function test() {
        console.log(this.a);
    }
    test();
}
var obj = {
    a: 2;
    foo: foo
}
obj.foo();//0
```

### 隐式丢失

隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到window。**这种情况容易出错却又常见**

【**函数别名**】

```js
var a = 0;
function foo(){
    console.log(this.a);
}
var obj = {
    a: 1,
    foo:foo
}
//把obj.foo赋予别名bar，造成了隐式丢失，因为只是把foo()函数赋给了bar，而bar与obj对象则毫无关系
var bar = obj.foo;
bar();//0
```

**【内置函数】**

内置函数与上例类似，也会造成隐式丢失

```js
var a = 0;
function foo(){
    console.log(this.a);
}
var obj = {
    a : 2,
    foo:foo
}
setTimeout(obj.foo,100);//0 只是把foo函数进行赋值
```

### 严格模式

【1】严格模式下，独立调用的函数的this指向undefined

```text
function fn(){
    'use strict';
    console.log(this);//undefined
}
fn();

function fn(){
    console.log(this);//window
}
fn();
```

### 箭头函数的this指向

1、在使用=>定义函数的时候，this的指向是定义时所在的对象，而不是使用时所在的对象；
2、不能够用作构造函数，这就是说，不能够使用new命令，否则就会抛出一个错误；
3、不能够使用arguments对象；

### call & apply & bind

当函数通过Function对象的原型中继承的方法 call() 和 apply() 方法调用时， 其函数内部的this值可绑定到 call() & apply() 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它。

Call和apply的不同在于传参的方式，call是，多个。Apply是一个数组

通过bind方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。

# JavaScript系列之立即执行函数IIFE

**IIFE(Immediately Invoked Functions Expressions)**其实可以就字面上直接来理解，Immediately就是立即的意思，invoked则是执行某个函数时「执行」的意思，function expression是一种用来创建函数的方法，**总的来说，就是用函数表达式的方式建立函数后并立即执行它**。

下面我们将做更进一步的介绍和说明。

## 函数的声明

JavaScript 中有两种常见的声明函数的方法，分别是通过**function 命令**或**函数表达式声明**，来看个简单的例子：

```js
// function 命令 
function  sayHi ( name )  { 
  console . log ( 'Hi'  + name ) ; 
} 
sayHi( 'miqilin' ) ;

// 函数表达式
var  sayHello  =  function ( name )  { 
  console . log ( 'Hello '  + name ) ; 
} 
sayHello( 'miqilin' ) ;
```

## 立即执行函数(IIFE)

那么什么是**IIFE**呢？如同文章一开始所叙述的，**IIFE指的就是通过函数表达式的方式来创建函数，并且立即执行它**。那我们要怎么做呢？

首先我们可以用console.log的方式，先来看一下，我们刚刚创建的sayHello打印出来会长什么样子呢？

```js
// 函数表达式
var  sayHello  =  function ( name )  { 
  console . log ( 'Hello '  + name ) ; 
} 
console.log(sayHello);
```

结果会发现，直接把sayHello打印出来后，它会直接返回整个函数的代码内容，这是尚未"执行（Invoked）"代码前的结果。

![img](https://pic2.zhimg.com/80/v2-4475fb1d65c00ce361aadcb608430711_720w.jpg)

如果是IIFE就在这段代码的最后，加上一个执行的指令，也就是括号( )：

![img](https://pic4.zhimg.com/80/v2-8151b9505bc62df0e9e2998c531a49ff_720w.jpg)

上图就可以看出，在我们定义函数的同时，这段函数就会立即被执行了，当然最后的( )中可以加入参数：

![img](https://pic3.zhimg.com/80/v2-0f71e6c3ef39e23a45e779c2f4b35c0e_720w.jpg)

那如果我们把前面的声明变量去了呢，变成一个匿名函数：

```js
//不可行的做法
function ( name )  { 
  console.log( 'Hello '  + name ) ; 
}
```

但是这么做是不可行的，因为JavaScript引擎在解析代码的时候，你用function作为开头，引擎会认为你现在要输入function 命令去创建函数，**可是你却没有给该function名称，于是它无法正确理解这段代码便抛出错误**：

![img](https://pic2.zhimg.com/80/v2-64f2cf0f7fa3b3de250103075aa6fe85_720w.jpg)

所以，这时候我们要做的是告诉JavaScript 引擎说，这一整个并不是function 命令。要达到这样的目的，我们要让引擎在解析代码的时候，不是以读到function 作为开头。

为了要达到这样的目的，我们最常使用的做法就是用括号()将function(){ ...}包起来，像是这样：

```js
(function ( name )  { 
  console.log( 'Hello '  + name ) ; 
});
```

**因为我们只会在括号内放入表达式，例如(3+2)，而不会放命令在括号内，所以JavaScript就会以表达式的方式来读取这段函数**。

在这种情况下，这个函数会被建立，但是不会被存在任何变量当中，也不会被执行。

结合刚刚上面IIFE的概念，我们可以在创建这个函数的同时，将这个函数加以执行，我们同样只需要在最后加上括号()就可以了：

![img](https://pic1.zhimg.com/80/v2-0b849117f6ac9e24345f4a4d97b93934_720w.jpg)

这样IIFE的型式，会在许多的JavaScript框架中都看得到，比如jQuery，jQuery用了这样的手法将`window`与`undefined`保留起来：

```js
(function( window, undefined ) {

  // 略...

})( window );
```

其中`undefined`是可以被修改的，虽然jQuery在IIFE定义了两个参数，但只传了一个`winodw`，就是为了保持`undefined`原本的样子。

**通过这样的方式，我们可以「直接执行某个函数」，一个很重要的一点是，这样做不仅避免了外界访问此 IIFE 内的变量，而且又不会污染全局作用域**。

## IIFE执行过程解析

先看段IIFE实例代码：

```js
//IIFE 
(function(name){
  var greeting = 'Hello';
  console.log(greeting+ ' ' +name);
})("miqilin");
```

让我们看看，当我们在执行这段代码的过程中，JavaScript引擎实际发生了什么事吧！

首先，当我执行这段代码时，会先建立全局执行上下文（Global Execution Context），但这时候这个执行上下文里面是没有任何内容的，因为我们并没有在全局这层建立任何变量（如果有的话，变量的名称会先提升在全局上下文中。）

![img](https://pic3.zhimg.com/80/v2-91d51a4e12ae493be6c3215d2262bc3e_720w.jpg)

接着，JavaScript引擎会执行到我们所建立的这段IIFE，它会将这个匿名函数储存在全局执行上下文。

![img](https://pic3.zhimg.com/80/v2-9de7d1d4ba84a5c800421d0f677938ee_720w.jpg)

由于我们在函数的最后有加上( )，所以这段函数会立即被执行，也因此，JavaScript会为这个匿名函数建立一个新的执行上下文。

![img](https://pic2.zhimg.com/80/v2-3e5589547b326926662978deb2c4a53d_720w.jpg)

接着，它会去逐行执行我们这个函数中的代码内容，它发现到我们的代码中建立了一个变量，名称是"greeting"，因此，这个变量就被建立在函数的这个执行上下文中，而不是被建立在全局上下文中。

![img](https://pic3.zhimg.com/80/v2-cec6f2f4133e9df52b659bb20dcf53c2_720w.jpg)

因此，通过IIFE，我们可以发现，在IIFE中所建立的变量，都不会影响到全局执行上下文所建立的变量，这里再次提一下，通过IIFE，它避免了我们的变量间可能会互相干扰覆盖的情况。

## IIFE的实际应用

让我们先回到上面的代码，这时候我们在函数的外面，声明一个同样的变量名(greeting)。

```js
//全局执行上下文
var greeting = 'Hi';

//IIFE
(function(name){
  var greeting = 'Hello';
  console.log(greeting+ ' ' +name);
})("miqilin");

console.log(greeting);
```

这时候的打印出的顺序为：

![img](https://pic2.zhimg.com/80/v2-a322c4f6955077aced86a0ab1a82f609_720w.jpg)

你会发现，虽然同样都是调用greeting这个变量，但是一个是在函数执行上下文内的greeting，一个是在全局执行上下文的greeting，两者是不会互相影响的。

同样把它画成上面一样的图形，它们两个是不同的执行上下文被储存在不同的内存中，所以不会相互影响。

![img](https://pic4.zhimg.com/80/v2-9d307837e6e0257a1d0cdf2d7300eda3_720w.jpg)

如此，我们可以很直观地确定，放在IIFE里面的变量，并不会影响到其他外层的变量，也不会被外层的变量影响到。

## 如果执意要影响外层变量呢？

虽然我们使用IIFE的主要目的就是希望不同执行上下文之间的变量不要互相影响，但如果我们还是想让函数执行上下文这层的变量能够同时影响到全局执行上下文的变量时，我们可以怎么操作呢？

首先，我们得多一个参数，叫做global，在最后带入参数的地方，我们填入对象window，由于我们知道对象是引用类型的特性，因此我们可以直接针对window里面的对象去做改变，像这里，我就可以直接把global层次的对象改成hola（global.greeting = 'Hola'）：

```js
//全局执行上下文
var greeting = 'Hi';

//IIFE
(function(global, name){
  var greeting = 'Hello';
  global.greeting = 'Hola';
  console.log(greeting+ ' ' +name);
})(window, "miqilin");

console.log(greeting);
```

结果如下，原本在全局执行上下文的Hi，被变换为Hola了：

![img](https://pic1.zhimg.com/80/v2-a41538bf6ec5b26a49896d3ab8996d7c_720w.jpg)

这操作够骚吧！哈哈~

## 一道IIFE经典面试题

题目是这样的：假设想通过循环+ setTimeout来做到，在五秒钟之内，每秒钟依序通过`console.log`打印出：`0 1 2 3 4`

```js
for( var i = 0; i < 5; i++ ) {
  window.setTimeout(function() {
    console.log(i);
  }, 1000);
}
```

真的是这样吗？我们来看看执行的结果：

```text
//过了接近一秒五个五同时打出
5
5
5
5
5
```

为什么会这样呢？

我们知道， JavaScript是一个「异步」的语言，所以当我们执行这段代码时，`for`循环并不会等待`window.setTimeout`结束后才继续，而是在执行阶段就**一口气跑完**。

也就是说，当`window.setTimeout`内的回调函数执行时，拿到的`i`已经是跑完`for()`循环的`5`。

![img](https://pic3.zhimg.com/80/v2-ce4eeb80dfbc1909cc2aab594c8c7a76_720w.jpg)

那么要怎么解决这个问题呢？

我们可以把`window.setTimeout`包装成一个IIFE，这个问题就迎刃而解了：

```js
for( var i = 0; i < 5; i++ ) {

  // 为了凸显差异，我们将传入后的参数改名为 x
  // 当然由于作用域的不同，要继续在内部沿用 i 也是可以的。
  (function(x){
    window.setTimeout(function() {
      console.log(x);
    }, 1000);
  })(i);
}
```

这时候你会发现，执行的结果就会是我们预期的`0 1 2 3 4`了，但还是有一个问题：就是`0 1 2 3 4`还是在一秒钟后同时出现啊？怎么解决？

嘿嘿，相信聪明的你已经发现，由于`for`循环在一瞬间就跑完，等于那一瞬间它向`window`依序注册了五次timer，每个timer都只等待一秒钟，当然同时出现喽。

所以我们稍微修改一下：

```js
for( var i = 0; i < 5; i++ ) {

  (function(x){
    // 将原来的 1000 改成 1000 * x
    window.setTimeout(function() {
      console.log(x);
    }, 1000 * x);
  })(i);
}
```

像这样，就可以依序打印出我们想要的结果喽！

[注] ES6以后新增了`let`与`const`，且改以`{ }`作为它的块级作用域。

换句话说，将上例中的`for`改为`let`就可以做到保留`i`在执行循环当下的「值」，打出一样的效果：

```js
for( let i = 0; i < 5; i++ ) {
  window.setTimeout(function() {
    console.log(i);
  }, 1000*(i+1));
}
```

块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再那么必要了。

# Promise的理解和常见问题

### 1、Promise 出现的原因，或者解决了什么问题

在 Promise 出现以前，在我们处理多个异步请求嵌套时，代码往往是这样的。。。

```js
let fs = require('fs')

fs.readFile('./name.txt','utf8',function(err,data){
  fs.readFile(data, 'utf8',function(err,data){
    fs.readFile(data,'utf8',function(err,data){
      console.log(data);
    })
  })
})
```

为了拿到回调的结果，我们必须一层一层的嵌套，可以说是相当恶心了。而且基本上我们还要对每次请求的结果进行一系列的处理，使得代码变的更加难以阅读和难以维护，这就是传说中臭名昭著的**回调地狱**～产生**回调地狱**的原因归结起来有两点：

1.**嵌套调用**，第一个函数的输出往往是第二个函数的输入；

2.**处理多个异步请求并发**，开发时往往需要同步请求最终的结果。

原因分析出来后，那么问题的解决思路就很清晰了：

1.**消灭嵌套调用**：通过 Promise 的链式调用可以解决；

2.**合并多个任务的请求结果**：使用 Promise.all 获取合并多个任务的错误处理。

Promise 正是用一种更加友好的代码组织方式，解决了异步嵌套的问题。

### 2、从零开始，手写 Promise

Promise 的基本特征：

1. promise 有三个状态：`pending`，`fulfilled`，or `rejected`
2. `new promise`时， 需要传递一个`executor()`执行器，执行器立即执行；
3. `executor`接受两个参数，分别是`resolve`和`reject`；
4. promise 的默认状态是 `pending`；
5. promise 有一个`value`保存成功状态的值，可以是`undefined/thenable/promise`；
6. promise 有一个`reason`保存失败状态的值；
7. promise 只能从`pending`到`rejected`, 或者从`pending`到`fulfilled`，状态一旦确认，就不会再改变；
8. promise 必须有一个`then`方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected；
9. 如果调用 then 时，promise 已经成功，则执行`onFulfilled`，参数是`promise`的`value`；
10. 如果调用 then 时，promise 已经失败，那么执行`onRejected`, 参数是`promise`的`reason`；
11. 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调`onRejected`；

```js
const PENDING = 'PENDING';
const FULFILLED = 'FULFILLED';
const REJECTED = 'REJECTED';

class Promise {
  constructor(executor) {
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    // 存放成功的回调
    this.onResolvedCallbacks = [];
    // 存放失败的回调
    this.onRejectedCallbacks= [];

    let resolve = (value) => {
      if(this.status ===  PENDING) {
        this.status = FULFILLED;
        this.value = value;
        // 依次将对应的函数执行
        this.onResolvedCallbacks.forEach(fn=>fn());
      }
    } 

    let reject = (reason) => {
      if(this.status ===  PENDING) {
        this.status = REJECTED;
        this.reason = reason;
        // 依次将对应的函数执行
        this.onRejectedCallbacks.forEach(fn=>fn());
      }
    }

    try {
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }

  then(onFulfilled, onRejected) {
    if (this.status === FULFILLED) {
      onFulfilled(this.value)
    }

    if (this.status === REJECTED) {
      onRejected(this.reason)
    }

    if (this.status === PENDING) {
      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onResolvedCallbacks.push(() => {
        onFulfilled(this.value)
      });

      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onRejectedCallbacks.push(()=> {
        onRejected(this.reason);
      })
    }
  }
}
```

测试一下：

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('成功');
  },1000);
}).then(
  (data) => {
    console.log('success', data)
  },
  (err) => {
    console.log('faild', err)
  }
)
```

控制台等待 `1s` 后输出：

```js
"success 成功"
```

ok！大功告成，异步问题已经解决了！

熟悉设计模式的同学，应该意识到了这其实是一个**发布订阅模式**，这种`收集依赖 -> 触发通知 -> 取出依赖执行`的方式，被广泛运用于发布订阅模式的实现。

### Promise 的 API

- Promise.resolve()
- Promise.reject()
- Promise.prototype.catch()
- Promise.prototype.finally()
- Promise.all()  所有都执行完才执行
- Promise.race(）其中一个执行完就开始执行

# ajax原理



ajax的核心就是基于浏览器提供的XMLHttpRequest对象实现的



原理：由事件触发，创建一个XMLHttpRequest对象，把HTTP方法和目标，以及请求返回后的回调函数设置到XMLHttpRequest对象，通过向服务器发送请求，请求发送后继续响应用户的界面交互，只有等到请求真正从服务器返回的时候才调用callback()函数，对响应数据进行处理。



```javascript
1     //创建XMLHttpRequest对象，为考虑兼容性问题，老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象
2     var ajax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
3     
4     //设定请求的类型，服务器URL，以及是否异步处理
5     ajax.open("get","test.ashx?name=jcx&id="+new Date(),true);
6                 
7     ajax.onreadystatechange=function(){
9          //4:请求已完成，且响应已就绪    
10         if(ajax.readyState==4){
12             //200:成功
13             if(ajax.status==200){
15             	  //处理结果
16                alert(ajax.responseText);
17              }else{
19                   alert("AJAX服务器返回错误！");
20              }
21          }       
23     }
24     //将请求发送到服务器
26     ajax.send();
```

# event loop（事件循环机制）

## JS的事件循环

1. 在执行主线程的任务时，如果有异步任务，会进入到Event Table并注册回调函数，当指定的事情完成后，会将这个回调函数放到 **callback queue** 中
2. 在主线程执行完毕之后，会去读取 **callback queue**中的回调函数，进入主线程执行
3. 不断的重复这个过程，也就是常说的Event Loop（事件循环）了



## 异步任务

异步任务又分为宏任务和微任务、他们之间的区别主要是执行顺序的不同。

##### 微任务：原生的Promise和process.nextTick

##### **process.nextTick**的执行优先级高于**Promise**的

##### 宏任务：整体代码 script和setTimeout、setImmediate

**setTimeout**的执行优先级高于 **setImmediate** 的



## 宏任务与微任务的执行过程

> 微任务和宏任务的问题应该是前端面试中比较常见的，他们都从属于异步任务，主要区别在于他们的执行顺序，Event Loop的走向和取值



![img](https://pic3.zhimg.com/80/v2-1dd1305e20e2df08e186d6c2bfc8ab3e_720w.jpg)

## 测试结果

```js
<script>
   console.log("start");
   process.nextTick(() => {
     console.log("a");
     setImmediate(() => {
       console.log("d");
     });
     new Promise(res => res()).then(() => {
       console.log("e");
       process.nextTick(() => {
         console.log("f");
       });
       new Promise(r => {
         r()
       })
       .then(() => {
         console.log("g");
       });
       setTimeout(() => {
         console.log("h");
       });
     });
   });
   
   setImmediate(() => {
     console.log("b");
     process.nextTick(() => {
       console.log("c");
     });
     new Promise(res => res()).then(() => {
       console.log("i");
     });
   });
   console.log("end");
</script>
```



```text
第一轮循环：
1、打印  start 
2、打印  end    
3、nextTick放到微任务队列里nextTick1   
4、setImmediate放到宏任务队列里setImmediate1
第一轮循环打印出的是 start end
当前宏任务队列：setImmediate1
当前微任务队列：nextTick1 

第二轮循环：
1、执行所有微任务
2、打印  a
3、setImmediate放到宏任务队列里setImmediate2
4、打印  e
5、nextTick放到微任务队列里nextTick1   
6、then放到微任务队列里then1
7、setTimeout放到宏任务队列里setTimeout1
第二轮循环打印出的是 start end a e
当前宏任务队列：setImmediate1 setImmediate2 setTimeout1
当前微任务队列：nextTick1 then1

第三轮循环：
1、执行所有微任务
2、执行微任务nextTick1，打印 f
3、执行微任务then1，打印 g
4、执行所有宏任务
5、由于setTimeout高于setImmediate，所以执行setTimeout1 ，打印 h
6、执行宏任务setImmediate1 打印  b
7、nextTick放到微任务队列里nextTick1 
8、then放到微任务队列里then1
第三轮循环打印出的是 start end a e f g h b
当前宏任务队列：setImmediate2
当前微任务队列：nextTick1 then1

第四轮循环：
1、执行微任务
2、执行微任务nextTick1，打印 c
3、执行微任务then1，打印 i
4、执行宏任务setImmediate2 打印 d
第四轮循环打印出的是 start end a e f g h b c i d 
```

如果有任务就先执行微任务

通过上面步骤的讲解，看一下下面的执行顺序练习

```js
console.log('1');

setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})
process.nextTick(function() {
    console.log('6');
})
new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})
```

结果是什么

```text
最终打印顺序为：1 7 6 8 2 4 3 5 9 11 10 12
```

# generate函数用法

### 总结一下js中异步问题的解决方案

主流的解决方法主要有以下几种：

1. 回调函数
2. 事件触发
3. 发布/订阅者模式
4. promise
5. generate



### 创建一个generate函数

```js
function* gen(){
    yield 1
    yield 2
    return 3
}
```

区别于普通函数的地方在于function后面的*号，以及函数内部的yield。
*号是定义方式，带有 * 号表示是一个generate函数，yield是其内部独特的语法。

```js
function* gen(){
	yield 1
	yield 2
	return 3
}

  let g=gen();

  console.log(g.next())//{value:1,done:false}

  console.log(g.next())//{value:2,done:false}

  console.log(g.next())//{value:3,done:true}

  console.log(g.next())//{value:undefined,done:true}
```

调用generate函数会生成一个遍历器对象，不会立即执行，需要调用next执行，执行到带有yield的那一步，next会返回一个对象，对象中value表示yield或return后的值，done表示函数是否已经执行结束（是否已经执行到return）。之后每次执行next都会从上一个yield开始继续执行

#### 使用场景：页面抽奖，防止抽奖次数在页面被篡改


# javascript中的六种继承方式



继承的操作需要有一个父类，这里使用构造函数外加原型来创建一个：

```js
// super
function Person(name){
	this.name = name;
}
Person.prototype.job = 'frontend';
Person.prototype.sayHello = function() {
	console.log('Hello '+this.name);
}
var person = new Person('jia ming');
person.sayHello(); // Hello jia ming
```

### 原型链继承

```js
// 原型链继承
function Child() {
	this.name = 'child';
}
Child.prototype = new Person();
var child = new Child();
console.log(child.job); // frontend
// instanceof 判断元素是否在另一个元素的原型链上
// child是Person类的实例
console.log(child instanceof Person); // true
```

**关键点**：子类原型等于父类的实例`Child.prototype = new Person()`

原型链的详细讲解自己之前有一篇文章说到[深入理解原型对象和原型链](https://juejin.im/post/5acf22aef265da238c3b0f78)

**特点**：

1. 实例可继承的属性有：实例的构造函数的属性，父类构造函数的属性，父类原型上的属性。（新实例不会继承父类实例的属性）

**注意事项**：

1. 新实例无法向父类构造函数传参
2. 继承单一
3. 所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改）

### 借用构造函数

```js
// 借用构造函继承
function Child() {
	Person.call(this, 'reng');
}
var child = new Child();
console.log(child.name); // reng
console.log(child instanceof Person); // false
child.sayHello(); // 报错，继承不了父类原型上的东西
```

**关键点**：用`call`或`apply`将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））`Person.call(this, 'reng')`

针对`call, apply, bind`的使用，之前有篇文章[谈谈JavaScript中的call、apply和bind](https://juejin.im/post/5cf648c45188253a2b01ccb1)提到。

**特点**：

1. 只继承了父类构造函数的属性，没有继承父类原型的属性
2. 解决了**原型链继承**的注意事项（缺点）1，2，3
3. 可以继承多个构造函数的属性（call可以多个）
4. 在子实例中可以向父实例传参

**注意事项**：

1. 只能继承父类构造函数的属性
2. 无法实现构造函数的复用。（每次用每次都要重新调用）
3. 每个新实例都有构造函数的副本，臃肿

### 组合继承

组合继承是`原型链继承和借用构造函数继承`的组合。

```js
// 组合继承
function Child(name) {
	Person.call(this, name);
}
Child.prototype = new Person();
var child = new Child('jia');
child.sayHello(); // Hello jia
console.log(child instanceof Person); // true
```

**关键点**：结合了两种模式的优点--向父类传参（call）和复用（prototype）

**特点**：

1. 可以继承父类原型上的属性，可以传参，可复用
2. 每个新实例引入的构造函数属性是私有的

**注意事项**：

1. 调用了两次父类的构造函数（耗内存）
2. 子类的构造函数会代替原型上的那个父类构造函数（call相当于拿到了父类构造函数的副本）

### 原型式继承

```js
// 先封装一个函数容器，用来承载继承的原型和输出对象
function object(obj) {
	function F() {}
	F.prototype = obj;
	return new F();
}
var super0 = new Person();
var super1 = object(super0);
console.log(super1 instanceof Person); // true
console.log(super1.job); // frontend
```

**关键点**：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了可以随意增添属性的实例或对象。`Object.create()`就是这个原理。

**特点**：

1. 类似于复制一个对象，用函数来包装

**注意事项**：

1. 所有的实例都会继承原型上的属性
2. 无法实现复用。（新实例属性都是后面添加的）

**Object.create()方法规范了原型式继承。**这个方法接收两个参数，一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。

```js
// 传一个参数的时候
var anotherPerson = Object.create(new Person());
console.log(anotherPerson.job); // frontend
console.log(anotherPerson instanceof Person); // true
// 传两个参数的时候
var anotherPerson = Object.create(new Person(), {
	name: {
		value: 'come on'
	}
});
anotherPerson.sayHello(); // Hello come on
```

### 寄生式继承

```js
function object(obj) {
	function F(){}
	F.prototype = obj;
	return new F();
}
var sup = new Person();
// 以上是原型式继承，给原型式继承再套个壳子传递参数
function subobject(obj) {
	var sub = object(obj);
	sub.name = 'ming';
	return sub;
}
var sup2 = subobject(sup);
// 这个函数经过声明后就成了可增添属性的对象
console.log(sup2.name); // 'ming'
console.log(sup2 instanceof Person); // true
```

**关键点**：就是给原型式继承外面套个壳子。

**特点**：

1. 没有创建自定义类型，因为只是套了个壳子，返回对象，这个函数顺理成章就成了创建的新对象。

**注意事项**：

1. 没用到原型，无法复用

### 寄生组合继承

它跟**组合继承**一样，都比较常用。

**寄生**：在函数内返回对象然后调用

**组合**：

1. 函数的原型等于另一个实例
2. 在函数中用apply或call引入另一个构造函数，可传参

```js
// 寄生
function object(obj) {
	function F(){}
	F.prototype = obj;
	return new F();
}
// object是F实例的另一种表示方法
var obj = object(Person.prototype);
// obj实例（F实例）的原型继承了父类函数的原型
// 上述更像是原型链继承，只不过只继承了原型属性

// 组合
function Sub() {
	this.age = 100;
	Person.call(this); // 这个继承了父类构造函数的属性
} // 解决了组合式两次调用构造函数属性的特点

// 重点
Sub.prototype = obj;
console.log(Sub.prototype.constructor); // Person
obj.constructor = Sub; // 一定要修复实例
console.log(Sub.prototype.constructor); // Sub
var sub1 = new Sub();
// Sub实例就继承了构造函数属性，父类实例，object的函数属性
console.log(sub1.job); // frontend
console.log(sub1 instanceof Person); // true
```

**重点**：修复了组合继承的问题

在上面的问题中，你可能发现了这么一个注释`obj.constructor = Sub; // 一定要修复实例`。为什么要修正子类的构造函数的指向呢？

因为在不修正这个指向的时候，在获取构造函数返回的时候，在调用同名属性或方法取值上可能造成混乱。比如下面：

```js
function Car() { }
Car.prototype.orderOneLikeThis = function() {  // Clone producing function
    return new this.constructor();
}
Car.prototype.advertise = function () {
    console.log("I am a generic car.");
}

function BMW() { }
BMW.prototype = Object.create(Car.prototype);
BMW.prototype.constructor = BMW;              // Resetting the constructor property
BMW.prototype.advertise = function () {
    console.log("I am BMW with lots of uber features.");
}

var x5 = new BMW();

var myNewToy = x5.orderOneLikeThis();

myNewToy.advertise(); // => "I am BMW ..." if `BMW.prototype.constructor = BMW;` is not 
                      // commented; "I am a generic car." otherwise.
```


# js - 观察者模式与订阅发布模式



发布订阅模式与观察者模式的不同，“第三者” （事件中心）出现。目标对象并不直接通知观察者，而是通过事件中心来派发通知。



# 三、两种模式的关联和区别

发布订阅模式更灵活，是进阶版的观察者模式，指定对应分发。

1. 观察者模式维护单一事件对应多个依赖该事件的对象关系；
2. 发布订阅维护多个事件（主题）及依赖各事件（主题）的对象之间的关系；
3. 观察者模式是目标对象直接触发通知（全部通知），观察对象被迫接收通知。发布订阅模式多了个中间层（事件中心），由其去管理通知广播（只通知订阅对应事件的对象）；
4. 观察者模式对象间依赖关系较强，发布订阅模式中对象之间实现真正的解耦。



```javascript
var pubsub = (function(){
    var q = {}
    topics = {},
    subUid = -1;
    //发布消息
    q.publish = function(topic, args) {
        //判断有没有当前的话题
        if(!topics[topic]) {return;}
        var subs = topics[topic],//当前话题订阅者数组
        len = subs.length;
        while(len--) {
            subs[len].func(topic, args);
        }
        return this;
    };
    //向订阅中心添加订阅
    //接收两个参数 要订阅的话题，处理程序
    q.subscribe = function(topic, func) {
        //如果当前话题已经有订阅者，获取到订阅者数组
        //一个话题名下的 订阅者事件可以是多个fn1, fn2, fn3
        topics[topic] = topics[topic] ? topics[topic] : [];

        //给每个订阅者添加唯一的token
        var token = (++subUid).toString();
        topics[topic].push({
            token : token,
            func : func
        });
        return token;
    };
    //取消订阅
    q.unsubscribe = function(token){
        Object.keys(topics).map( key => {
            topics[key].map((fn, fnIndex) => {
                if(fn.token == token){
                    topics[key].splice(fnIndex,1)
                }
            })
        })
    }
    return q;
})();
//触发的事件(订阅者的处理程序)
var logmsg1 = function(topics, data) {
    console.log("logging1:" + topics + ":" + data);
}

var logmsg2 = function(topic, data) {
    console.log("logging2:" + topic + ":" + data,'我是订阅者2');
}
//监听指定的消息'msgName'
var sub1 = pubsub.subscribe('msgName', logmsg1);
var sub2 = pubsub.subscribe('msgName', logmsg2);
//pubsub.unsubscribe(sub1)
//发布消息'msgName'
pubsub.publish('msgName', 'hello world');
//发布无人监听的消息'msgName1'
pubsub.publish('anotherMsgName', 'me too!');
```


# js判断数据类型

Typeof判断基本类型和function类型

instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。原理：var L = A.__proto__;var R = B.prototype;判断A的__proto__ 是否指向B的prototype

判断数据类型最好用这个方法Object.prototype.toString.call


# js浅拷贝与深拷贝的区别和实现方式

##### 如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。

### 1. 如果是基本数据类型，名字和值都会储存在栈内存中

```html
var a = 1;
b = a; // 栈内存会开辟一个新的内存空间，此时b和a都是相互独立的
b = 2;
console.log(a); // 1
```

当然，这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。

### 2. 如果是引用数据类型，名字存在栈内存中，值存在堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值

##### 比如浅拷贝：

![img](https:////upload-images.jianshu.io/upload_images/15037426-33f5ceb9d7cb0a6e.png?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp)

当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。



![img](https:////upload-images.jianshu.io/upload_images/15037426-7bf9efc3a6e90bea.png?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp)

而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。

![img](https:////upload-images.jianshu.io/upload_images/15037426-aba3349a798ab52b.png?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp)


那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，岂不就达到深拷贝的效果了

![img](https:////upload-images.jianshu.io/upload_images/15037426-3cc2e0e955d177e3.png?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp)

### 3. 实现浅拷贝的方法

（1）for···in只循环第一层

```html
// 只复制第一层的浅拷贝
function simpleCopy(obj1) {
   var obj2 = Array.isArray(obj1) ? [] : {};
   for (let i in obj1) {
   obj2[i] = obj1[i];
  }
   return obj2;
}
var obj1 = {
   a: 1,
   b: 2,
   c: {
         d: 3
      }
}
var obj2 = simpleCopy(obj1);
obj2.a = 3;
obj2.c.d = 4;
alert(obj1.a); // 1
alert(obj2.a); // 3
alert(obj1.c.d); // 4
alert(obj2.c.d); // 4
```

（2）Object.assign方法

```html
var obj = {
    a: 1,
    b: 2
}
var obj1 = Object.assign(obj);
obj1.a = 3;
console.log(obj.a) // 3
```

（3）直接用=赋值

```html
let a=[0,1,2,3,4],
    b=a;
console.log(a===b);
a[0]=1;
console.log(a,b);
```

![img](https:////upload-images.jianshu.io/upload_images/15037426-6a06b6f2ee711a5f.png?imageMogr2/auto-orient/strip|imageView2/2/w/248/format/webp)

### 4. 实现深拷贝的方法

（1）采用递归去拷贝所有层级属性

```html
function deepClone(obj){
    let objClone = Array.isArray(obj)?[]:{};
    if(obj && typeof obj==="object"){
        for(key in obj){
            if(obj.hasOwnProperty(key)){
                //判断ojb子元素是否为对象，如果是，递归复制
                if(obj[key]&&typeof obj[key] ==="object"){
                    objClone[key] = deepClone(obj[key]);
                }else{
                    //如果不是，简单复制
                    objClone[key] = obj[key];
                }
            }
        }
    }
    return objClone;
}    
let a=[1,2,3,4],
    b=deepClone(a);
a[0]=2;
console.log(a,b);
```

结果：

![img](https:////upload-images.jianshu.io/upload_images/15037426-66f503dd14d2bd0f.png?imageMogr2/auto-orient/strip|imageView2/2/w/407/format/webp)

（2） 通过JSON对象来实现深拷贝

```html
function deepClone2(obj) {
  var _obj = JSON.stringify(obj),
    objClone = JSON.parse(_obj);
  return objClone;
}
```

缺点： 无法实现对对象中方法的深拷贝，会显示为undefined
（3）通过jQuery的extend方法实现深拷贝

```html
var array = [1,2,3,4];
var newArray = $.extend(true,[],array); // true为深拷贝，false为浅拷贝
```

（4）lodash函数库实现深拷贝

```html
let result = _.cloneDeep(test)
```

（5）Reflect法

```html
// 代理法
function deepClone(obj) {
    if (!isObject(obj)) {
        throw new Error('obj 不是一个对象！')
    }

    let isArray = Array.isArray(obj)
    let cloneObj = isArray ? [...obj] : { ...obj }
    Reflect.ownKeys(cloneObj).forEach(key => {
        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
    })

    return cloneObj
}
```

（6）手动实现深拷贝

```html
let obj1 = {
   a: 1,
   b: 2
}
let obj2 = {
   a: obj1.a,
   b: obj1.b
}
obj2.a = 3;
alert(obj1.a); // 1
alert(obj2.a); // 3
```

（7）如果对象的value是基本类型的话，也可以用Object.assign来实现深拷贝，但是要把它赋值给一个空对象

```html
var obj = {
    a: 1,
    b: 2
}
var obj1 = Object.assign({}, obj); // obj赋值给一个空{}
obj1.a = 3;
console.log(obj.a)；// 1
```

![img](https:////upload-images.jianshu.io/upload_images/15037426-1c7b29547b2a8794.png?imageMogr2/auto-orient/strip|imageView2/2/w/332/format/webp)

（8）用slice实现对数组的深拷贝

```html
// 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝
// 当数组里面的值是引用数据类型，比如Object，Array时，属于浅拷贝
var arr1 = ["1","2","3"]; 
var arr2 = arr1.slice(0);
arr2[1] = "9";
console.log("数组的原始值：" + arr1 );
console.log("数组的新值：" + arr2 );
```

![img](https:////upload-images.jianshu.io/upload_images/15037426-a412661f28396034.png?imageMogr2/auto-orient/strip|imageView2/2/w/341/format/webp)

（9）用concat实现对数组的深拷贝

```html
// 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝
var arr1 = ["1","2","3"];
var arr2 = arr1.concat();
arr2[1] = "9";
console.log("数组的原始值：" + arr1 );
console.log("数组的新值：" + arr2 );
// 当数组里面的值是引用数据类型，比如Object，Array时，属于浅拷贝
var arr1 = [{a:1},{b:2},{c:3}];
var arr2 = arr1.concat();
arr2[0].a = "9";
console.log("数组的原始值：" + arr1[0].a ); // 数组的原始值：9
console.log("数组的新值：" + arr2[0].a ); // 数组的新值：9
```

![img](https:////upload-images.jianshu.io/upload_images/15037426-5f64889271b63ce7.png?imageMogr2/auto-orient/strip|imageView2/2/w/326/format/webp)

（10）直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果。

```html
function deepClone(initalObj, finalObj) {    
  var obj = finalObj || {};    
  for (var i in initalObj) {        
    var prop = initalObj[i];        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况
    if(prop === obj) {            
      continue;
    }        
    if (typeof prop === 'object') {
      obj[i] = (prop.constructor === Array) ? [] : Object.create(prop);
    } else {
      obj[i] = prop;
    }
  }    
  return obj;
}
```

（11）使用扩展运算符实现深拷贝

```html
// 当value是基本数据类型，比如String，Number，Boolean时，是可以使用拓展运算符进行深拷贝的
// 当value是引用类型的值，比如Object，Array，引用类型进行深拷贝也只是拷贝了引用地址，所以属于浅拷贝
var car = {brand: "BMW", price: "380000", length: "5米"}
var car1 = { ...car, price: "500000" }
console.log(car1); // { brand: "BMW", price: "500000", length: "5米" }
console.log(car); // { brand: "BMW", price: "380000", length: "5米" }
```

# var,let和const的区别是什么

1.var声明的变量会挂载在window上，而let和const声明的变量不会

2.var声明变量存在变量提升，let和const不存在变量提升

3.let和const声明形成块作用域

4.同一作用域下let和const不能声明同名变量，而var可以

5.const一旦声明必须赋值,不能使用null占位；声明后不能再修改 ；如果声明的是复合类型数据，可以修改其属性

# 事件冒泡机制

## 什么是事件机制

JavaScript 事件机制描述的是事件在 DOM 里面的传递顺序，以及我们可以对这些事件做出如何的响应。

DOM事件流（event flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。

事件捕获（event capturing）： 通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始**由外到内**进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。

事件冒泡（dubbed bubbling）： 与事件捕获恰恰相反，事件冒泡顺序是**由内到外**进行事件传播，直到根节点。无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播，它就像一跟引线，只有通过引线才能将绑在引线上的鞭炮（事件监听器）引爆， 试想一下，如果引线不导火了，那鞭炮就只有一响了！！！



dom标准事件流的触发的先后顺序为 ：**先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡**。

不同的浏览器对此有着不同的实现，IE10及以下不支持捕获型事件，所以就少了一个事件捕获阶段，IE11、Chrome 、Firefox、Safari等浏览器则同时存在。

说到事件冒泡与捕获就不得不提一下两个用于事件绑定的方法addEventListener 、

attachEvent 。当然还有其它的事件绑定的方式这里不做介绍。

addEventListener(event, listener, useCapture)

·参数定义：event---（事件名称，如click，不带on）， listener---事件监听函数，

useCapture---是否采用事件捕获进行事件捕捉， **默认为false，即采用事件冒泡方式**

addEventListener在 IE11、Chrome 、Firefox、Safari等浏览器都得到支持。

attachEvent(event,listener)

·参数定义：event---（事件名称，如onclick，带on）， listener---事件监听函数。

attachEvent主要用于IE浏览器，并且仅在IE10及以下才支持，IE11已经废了这个方法了

（微软还是挺识趣的，慢慢向标准靠拢）。



## 事件冒泡



![img](https://pic1.zhimg.com/80/v2-8d1ec6aa261e2d59a53c39fa1c26e0b4_720w.jpg)



事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的元素





```html
<html lang="zh-cn">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>js事件机制</title>
<style>
#parent{
width: 200px; height:200px;
text-align: center; line-height: 3;


background: green;
}
#child{
width: 100px; height: 100px; margin: 0 auto; background: orange;
}
</style>
</head>
<body>
<div id="parent"> 父元素
<div id="child"> 子元素
</div>
</div>
<script type="text/javascript">
var parent = document.getElementById("parent"); var child = document.getElementById("child");

document.body.addEventListener("click",function(e){ console.log("click-body");
},false);

parent.addEventListener("click",function(e){ console.log("click-parent");
},false);

child.addEventListener("click",function(e){ console.log("click-child");
},false);
</script>
</body>
</html>
```

通过"addEventListener"方法，采用事件冒泡方式给dom元素注册click事件，点击子元素会发生什么呢？如果你对事件冒泡有一定了解的话那你肯定知道上面的代码会输出的顺

序，没错，如下图所示：





![img](https://pic4.zhimg.com/80/v2-4bef23206f0e321d666e02ee5d0b725b_720w.jpg)



事件触发顺序是由内到外的，这就是事件冒泡，虽然只点击子元素，但是它的父元素也会触发相应的事件，其实这是合理的，因为子元素在父元素里面，点击子元素也就相当于变相的点击了父元素，这样理解对吧？这里有同学可能要问了，如果点击子元素不想触发父元素的事件怎么办？肯定可以的，那就是停止事件传播---**event.stopPropagation();**



## 事件捕获



![img](https://pic3.zhimg.com/80/v2-4343c6e6c329539c8b5f490b24c4324e_720w.jpg)



不太具体的节点更早接受事件，而最具体的元素最后接受事件，和事件冒泡相反修改上面栗子中的代码，给parent元素注册一个捕获事件，如下

```js
var parent = document.getElementById("parent");
var child = document.getElementById("child");

document.body.addEventListener("click",function(e){ console.log("click-body");
},false);

parent.addEventListener("click",function(e){ console.log("click-parent---事件传播");
},false);
//新增事件捕获事件代码
parent.addEventListener("click",function(e){ console.log("click-parent--事件捕获");
},true);
child.addEventListener("click",function(e){ console.log("click-child");
},false);
```

如果你看明白了我前面说的那些，你就知道这个栗子的输出顺序了。



![img](https://pic3.zhimg.com/80/v2-f547b5f8964729c11bfadbcf61b0cb5e_720w.jpg)



父元素通过事件捕获的方式注册了click事件，所以在事件捕获阶段就会触发，然后到了目标阶段，即事件源，之后进行事件传播，parent同时也用冒泡方式注册了click事件，所以这里会触发冒泡事件，最后到根节点。这就是整个事件流程。



## DOM事件流



![img](https://pic4.zhimg.com/80/v2-60edebb07f5ff8ba765ee882cd8a3e97_720w.jpg)



DOM2级事件规定事件流包括三个阶段，事件捕获阶段，处于目标阶段，时间冒泡阶段， 首先发生的是事件捕获，为截取事件提供机会，然后是实际目标接受事件，最后是冒泡阶段

注：Opera、Firefox、Sarfari都支持DOM事件流，IE不支持事件流，只支持时间冒泡



当一个事件发生以后，它会在不同的DOM节点之间传播（propagation）。这种传播分为三个阶段：



![img](https://pic4.zhimg.com/80/v2-bda0cf942578c876f71a3b9c34beab8b_720w.jpg)





第一阶段：从window对象传导到目标节点，称为“捕获阶段”(capture phase)。第二阶段：在目标节点上触发，称为“目标阶段”(target phase)。

第三阶段：从目标节点传导回window对象，称为“冒泡阶段”(bubbling phase)。



## 事件委托

事件委托其实也叫事件代理。

定义：事件代理就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。(delegation)。

```js
var ul = document.querySelector('ul'); ul.addEventListener('click', function(event){
if(event.target.tagName.toLowerCase() === 'li'){
//...
}})
```

上面代码的click 事件的监听函数定义在<ul> 节点，但是实际上，它处理额是子节点<li> 的click事件。这样的好处是，只要定义一个监听函数，就能处理多个子节点的事件，且以后再添加子节点，监听函数依然有效。

**那什么样的事件可以用事件委托，什么样的事件不可以用呢？**

适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress 。值得注意的是，mouseover 和mouseout 虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。

不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。

更加详细内容可查看：[Js 中事件绑定、事件代理和事件委托](https://link.zhihu.com/?target=https%3A//blog.lbinin.com/frontEnd/JavaScript/JS-Event-Binding.html%23%E5%B0%81%E8%A3%85)



## 误区

## 在同一个对象上注册事件，并不一定按照注册顺序执行



之所以如此是因为事件目的地节点既绑定了冒泡事件也绑定了捕获事件，此时的执行顺序按照绑定的先后顺序执行（情况比较少见）。

举例

```html
<html lang="zh-cn">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>js事件机制</title>
<style>
#parent{
width: 200px; height:200px;
text-align: center; line-height: 3; background: green;
}

#child{
width: 100px; height: 100px; margin: 0 auto; background: orange;
}
</style>
</head>
<body>
<div id="parent"> 父元素
<div id="child"> 子元素
</div>
</div>
<script type="text/javascript">
var parent = document.getElementById("parent"); var child = document.getElementById("child");

// document.body.addEventListener("click",function(e){
//	console.log("click-body");
// },false); child.addEventListener("click",function(e){ console.log("click-child");
},false);

child.addEventListener("click",function(e){ console.log("click-child-捕获");
},true); parent.addEventListener("click",function(e){
console.log("click-parent");
},false);



parent.addEventListener("click",function(e){ console.log("click-parent-捕获");
},true);




</script>
</body>
</html>
```



点击子DIV执行结果：

![img](https://pic2.zhimg.com/80/v2-94b29591c105f62c573e5c359fcc17a5_720w.jpg)





交换子div事件，如下：

```html
<html lang="zh-cn">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>js事件机制</title>
<style>
#parent{
width: 200px; height:200px;
text-align: center; line-height: 3; background: green;
}
#child{
width: 100px; height: 100px; margin: 0 auto; background: orange;
}
</style>
</head>
<body>
<div id="parent"> 父元素
<div id="child"> 子元素
</div>
</div>
<script type="text/javascript">
var parent = document.getElementById("parent"); var child = document.getElementById("child");

// document.body.addEventListener("click",function(e){
//	console.log("click-body");
// },false);

child.addEventListener("click",function(e){ console.log("click-child-捕获");


},true);
child.addEventListener("click",function(e){ console.log("click-child");
},false);


parent.addEventListener("click",function(e){ console.log("click-parent");
},false);


parent.addEventListener("click",function(e){ console.log("click-parent-捕获");
},true);



</script>
</body>
</html>
```

点击子DIV执行结果：



![img](https://pic3.zhimg.com/80/v2-8de4bc9b39f72503a3597074f6ae6cca_720w.jpg)





由于子DIV上绑定了捕获和冒泡事件，所以此时的执行顺序是按照绑定的执行顺序。实际这种情况很少。



## event.stopPropagation();就是阻止事件的冒泡



这个表述不能说他错误，但是是不完整的，他除了阻止事件的冒泡，还阻止事件的继续捕获，简而言之就是阻止事件的进一步传播 。下面的例子可以看到：





```html
<html lang="zh-cn">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>js事件机制</title>
<style>

#parent{
width: 200px; height:200px;
text-align: center; line-height: 3; background: green;
}
#child{
width: 100px; height: 100px; margin: 0 auto; background: orange;
}
</style>
</head>
<body>
<div id="parent"> 父元素
<div id="child"> 子元素
</div>
</div>
<script type="text/javascript">
var parent = document.getElementById("parent"); var child = document.getElementById("child");


child.addEventListener("click",function(e){ console.log("click-child-捕获");
},true);
//	child.addEventListener("click",function(e){
//	console.log("click-child");
// },false);

// parent.addEventListener("click",function(e){
//	console.log("click-parent");
// },false);

parent.addEventListener("click",function(e){ event.stopPropagation();
console.log("click-parent-捕获");
},true);



</script>
</body>
</html>
```

执行结果：



![img](https://pic4.zhimg.com/80/v2-da81d0755a159ba169c3ec3d4cd203cb_720w.jpg)





## return false;阻止默认行为

return false;事件处理过程中，阻止了事件冒泡，也阻止了默认行为（比如刚才它就没有执行超链接的跳转）

return false 不仅阻止了事件往上冒泡，而且阻止了事件本身。event.stopPropagation() 则只阻止事件的进一步传播，不阻止事件本身。



![img](https://pic2.zhimg.com/80/v2-c720c37b9df96abc3c0332fe837c2719_720w.jpg)


# **什么是函数式编程**

我们常见的编程范式有两种：命令式和声明式，比如我们熟悉的面向对象思想就属于命令式，而函数式编程属于声明式。而且顺带说一句，函数式编程里面提到的“函数”不是我们理解的编程中的“function”概念，而是数学中的函数，即变量之间的映射。

那么，函数式编程和我们熟知的声明式编程区别是什么？一句话来做总结：**函数式编程关心数据的映射，命令式编程关心解决问题的步骤**

举个例子，如果编写一个函数来实现把数组的每个数字都变成它本身的2倍，命令式编程的思路应该是：遍历一次数组，并且把每个数字乘以2，代码如下：

```js
const solution = (arr) => {
  const newArr = [];
    for(let i = 0;i < arr.length;i++) {
    newArr.push(arr[i]*2);
  }
  return newArr;
}
```

但是如果从函数式编程的思维去思考，无非就是数组A的每个元素是数组B每个元素的两倍，存在一个映射：[a, b, c, d, ...] => [2a, 2b, 2c, 2d, ...]，代码如下：

```js
const solution = (arr) => {
    return arr.map(item => {
    return item*2;
  })
}
```

从上面这两个简单的例子可以看出来，函数式编程与命令式编程的思路最大的不同在于：函数式更关心数据的映射。

在前端开发领域中，有很多函数式的使用，比如React框架，它本身的设计理念就是View = Fn(Data)，而且还有函数式组件以及高阶组件等等，无一不都透露着对函数式编程的实践。

## **纯函数**

纯函数是函数式编程中一个很重要的概念，它的定义是：纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，且不依赖外部环境。

比如说对于数组的方法slice和splice来说（例子来自于函数式编程指北）：

```js
var xs = [1,2,3,4,5];

// 纯的
xs.slice(0,3);
//=> [1,2,3]

xs.slice(0,3);
//=> [1,2,3]

xs.slice(0,3);
//=> [1,2,3]


// 不纯的
xs.splice(0,3);
//=> [1,2,3]

xs.splice(0,3);
//=> [4,5]

xs.splice(0,3);
//=> []
```

可以从例子里看出，对于slice来说，它对于相同的输入总能返回相同的输出；而splice直接在原数组上作出改变，产生了可观察到的副作用，即改变了数组。

再来一个例子

```js
// 不纯的
var minimum = 21;

var checkAge = function(age) {
  return age >= minimum;
};


// 纯的
var checkAge = function(age) {
  var minimum = 21;
  return age >= minimum;
};
```

很明显，在不纯的版本中，checkAge的返回结果直接依赖于外部的变量minimum，这样子就做不到对于相同的输入总是返回相同的输出了，因为只要外部环境的变量一变，直接影响到函数的输出。

## **副作用**

前面一直在说副作用，到底什么是副作用？哪些影响可以被算作是副作用？

副作用的定义是：副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。

副作用包含但不限于：

- 更改文件系统
- 往数据库插入记录
- 发送一个 http 请求
- 可变数据
- 打印/log
- 获取用户输入
- DOM 查询
- 访问系统状态

可以看出来，只要是跟外部环境发生了交互的行为都会带来副作用，与外部环境交互了就可能会影响到函数的输出，函数式编程之所以这么在乎副作用，就是因为函数式编程的哲学就是假定副作用是造成不正当行为的主要原因。

## **优势**

纯函数因为它的纯和没有副作用，可以带来以下几个好处

### **可预测性**

因为纯函数没有副作用，对于同一个输入来说，我们可以预测到它的输出，这对于前端常见的共享状态以及修改很有用。

再看看Redux，在它的官方文档里面提到：

```text
To specify how the state tree is transformed by actions, you write pure reducers. Reducers are just pure functions that take the previous state and an action, and return the next > state. Remember to return new state objects, instead of mutating the previous state.
```

很明显，Redux要求你使用纯函数的方式来写reducer，可预测、无副作用的纯函数正中下怀。

### **可缓存性**

因为对于纯函数，固定的输入可以得到固定的输出，所以可利用这一点来做缓存。

例如

```js
var memoize = function(f) {
  var cache = {};

  return function() {
    var arg_str = JSON.stringify(arguments);
    cache[arg_str] = cache[arg_str] || f.apply(f, arguments);
    return cache[arg_str];
  };
};

var squareNumber  = memoize(function(x){ return x*x; });

squareNumber(4);
//=> 16

squareNumber(4); // 从缓存中读取输入值为 4 的结果
//=> 16

squareNumber(5);
//=> 25

squareNumber(5); // 从缓存中读取输入值为 5 的结果
//=> 25
```

## **柯里化**

柯里化（curry）的理念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

举个例子

```js
var add = function(x) {
  return function(y) {
    return x + y;
  };
};

var increment = add(1);
var addTen = add(10);

increment(2);
// 3

addTen(2);
// 12
```

上面这个例子定义了一个add函数，它接受参数x并且返回一个函数，调用add函数之后，返回的函数就以闭包的形式记住了第一个参数x。

柯里化在日常编程中的使用主要体现在“预加载函数”，即提前缓存一部分参数，以便在未来使用。例如在vue源码中，就有一个柯里化的经典使用：

```js
export function createPatchFunction (backend) {
  let i, j
  const cbs = {}
  const { modules, nodeOps } = backend
  
  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    //...
  }
}
```

因为vue需要支持web和weex，而且patch操作里面的逻辑在不同的平台上基本相同，只是把虚拟DOM映射到真实元素的操作方法不一样，所以提前把相关的API传入createPatchFunction，返回一个固化好平台操作元素API的patch方法，以后使用的时候只需要传入oldVnode和vnode等等参数就好了，这种利用柯里化的技巧值得学习。

## **组合**

考虑一下存在如下的方法：

```js
var toUpperCase = function(x) { return x.toUpperCase(); };
var exclaim = function(x) { return x + '!'; };
var shout = function(x){
  return exclaim(toUpperCase(x)); // 不优雅
};

shout("send in the clowns");
//=> "SEND IN THE CLOWNS!"
```

这种方法里面套方法的做法，看起来略难受且不优雅，如果使用组合的方式，可以修改成下面这样：

```js
var shout = compose(exclaim, toUpperCase);

shout("send in the clowns");
//=> "SEND IN THE CLOWNS!"
```

组合式的写法可以让我们在开发中用拼装来代替直接封装，使代码更加优雅，比如Redux中的compose方法：

Composes functions from right to left.
This is a functional programming utility, and is included in Redux as a convenience. You might want to use it to apply several store enhancers in a row.
**Arguments**
(arguments): The functions to compose. Each function is expected to accept a single parameter. Its return value will be provided as an argument to the function standing to the left, and so on. The exception is the right-most argument which can accept multiple parameters, as it will provide the signature for the resulting composed function.
Returns
(Function): The final function obtained by composing the given functions from right to left.

```js
import { createStore, applyMiddleware, compose } from 'redux'
import thunk from 'redux-thunk'
import DevTools from './containers/DevTools'
import reducer from '../reducers'

const store = createStore(
  reducer,
  compose(applyMiddleware(thunk), DevTools.instrument())
)
```


# 什么是原型和原型链



## JavaScript 原型

原型的英文应该叫做 `prototype`，任何一个对象都有原型，我们可以通过非标准属性 `__proto__` 来访问一个对象的原型：

```js
// 纯对象的原型默认是个空对象
console.log({}.__proto__); // => {}

function Student(name, grade) {
  this.name = name;
  this.grade = grade;
}

const stu = new Student('xiaoMing', 6);
// Student 类型实例的原型，默认也是一个空对象
console.log(stu.__proto__); // => Student {}
```

`__proto__` 是非标准属性，如果要访问一个对象的原型，建议使用 ES6 新增的 `Reflect.getPrototypeOf` 或者 `Object.getPrototypeOf()` 方法。非标准属性意味着未来可能直接会修改或者移除该属性，说不定以后出了个新标准用 `Symbol.proto` 作为 key 来访问对象的原型，那这个非标准属性可能就要被移除了。

```js
console.log({}.__proto__ === Object.getPrototypeOf({})); // => true
```

我们可以通过对 `__proto__` 属性直接赋值的方式修改对象的原型，更推荐的做法是使用使用 ES6 的 `Reflect.setPrototypeOf` 或 `Object.setPrototypeOf`。不论哪一种方式，被设置的值的类型只能是对象或者 null，其它类型不起作用：

```js
const obj = { name: 'xiaoMing' };
// 原型为空对象
console.log(obj.__proto__); // => {}

obj.__proto__ = 666;
// 非对象和 null 不生效
console.log(obj.__proto__); // => {}

// 设置原型为对象
obj.__proto__ = { a: 1 };
console.log(obj.__proto__); // => { a: 1 }
console.log(Reflect.getPrototypeOf(obj)); // => { a: 1 }
```

## 构造器和 prototype

构造器的英文就是 `constructor`，在 JavaScript 中，**函数都可以用作构造器**。构造器我们也可以称之为类，Student 构造器不就可以称之为 Student 类嘛。我们可以通过 new 构造器来构造一个实例。习惯上我们对用作构造器的函数使用大驼峰命名：

```js
function Apple() {}
const apple = new Apple();
console.log(apple instanceof Apple); // => true
```

**任何构造器都有一个 prototype 属性，默认是一个空的纯对象，所有由构造器构造的实例的原型都是指向它。**

```js
// 实例的原型即 apple1.__proto__
console.log(apple1.__proto__ === Apple.prototype); // => true
console.log(apple2.__proto__ === Apple.prototype); // => true
```

下面的测试结果可以证明构造器的 prototype 属性默认是个空对象，注意这里说的空对象指的是该对象没有可遍历属性：

```js
console.log(Apple.prototype); // => Apple {}
console.log(Object.keys(Apple.prototype)); // => []
console.log(Apple.prototype.__proto__ === {}.__proto__); // true
```

构造器的 `prototype` 有一个 `constructor` 属性，指向构造器本身：

```js
console.log(Apple.prototype.constructor === Apple); // => true
```

这个 `constructor` 属性是不可遍历的，可以理解为内部是这样定义该属性的：

```js
Object.defineProperty(Apple.prototype, 'constructor', {
  value: Student,
  writable: true,
  // 不可枚举，无法通过 Object.keys() 获取到
  enumerable: fasle,
});
```

`__proto__` ，`prototype`，`constructor`，`Apple`函数，实例 `apple` 和原型对象 `[[prototype]]` 之间的关系：



![img](https://pic3.zhimg.com/80/v2-0705dfd2e7c902f4035cbda56eec5892_720w.jpg)



有些人可能会把 `__proto__` 和 `prototype` 搞混淆。从翻译的角度来说，它们都可以叫原型，但是其实是完全不同的两个东西。

`__proto__` 存在于所有的对象上，`prototype` 存在于所有的函数上，他俩的关系就是：函数的 `prototype` 是所有使用 new 这个函数构造的实例的 `__proto__`。函数也是对象，所以函数同时有 `__proto__` 和`prototype`。

**注意**：如果我文章中提到了构造器的原型，指的是构造器的 `__proto__`，而不是构造器的 prototype 属性。

## 原型链

那么**对象的原型**有什么特点呢？

> 当在一个对象 obj 上访问某个属性时，如果不存在于 obj，那么便会去对象的原型也就是 `obj.__proto__` 上去找这个属性。如果有则返回这个属性，没有则去对象 obj 的原型的原型也就是 `obj.__proto__.__proto__`去找，重复以上步骤。一直到访问**纯对象**的原型也就是 `Object.prototype`，没有的话续往上找也就是 `Object.prototype.__proto__`，其实就是 null，直接返回 undefined。

举个例子：

```js
function Student(name, grade) {
  this.name = name;
  this.grade = grade;
}

const stu = new Student();
console.log(stu.notExists); // => undefined
```

访问 `stu.notExists` 的整个过程是：

1. 先看 `stu` 上是否存在 `notExists`，不存在，所以看 `stu.__proto__`
2. `stu.__proto__` 上也不存在 `notExists` 属性，再看 `stu.__proto__.__proto__`，其实就是**纯对象**的原型：`Object.prototype`
3. **纯对象**的原型上也不存在 `notExists` 属性，再往上，到 `stu.__proto__.__proto__.__proto__` 上去找，其实就是 null
4. null 不存在 `notExists` 属性，返回 undefined

可能有读者看了上面会有疑问，对象的原型一直查找最后会找到**纯对象**的原型？测试一下就知道了：

```js
console.log(stu.__proto__.__proto__ === {}.__proto__); // => true
```

**纯对象**的原型的原型是 null：

```js
console.log(new Object().__proto__.__proto__); // => null
```

## 原型的用途

在使用构造器定义一个类型的时候，我们一般会将类的方法定义在原型上，和 this 的指向特性简直是绝配。

```js
function Engineer(workingYears) {
  this.workingYears = workingYears;
}

// 不能使用箭头函数，箭头函数的 this 在声明的时候就根据上下文确定了
Engineer.prototype.built = function () {
  // this 这里就是执行函数调用者
  console.log(`我已经工作 ${this.workingYears} 年了, 我的工作是拧螺丝...`);
};

const engineer = new Engineer(5);
// this 会正确指向实例，所以 this.workingYears 是 5
engineer.built(); // => 我已经工作 5 年了, 我的工作是拧螺丝...
console.log(Object.keys(engineer)); // => [ 'workingYears' ]
```

通过这种方式，所有的实例都可以访问到这个方法，并且这个方法只需要占用一份内存，节省内存，this 的指向还能正确指向类的实例。

不过这种方式定义的方法无法通过 Object.keys() 访问，毕竟不是自身的属性：

```js
const obj = {
  func() {},
};

console.log(Object.keys(obj)); // => [ 'func' ]

function Func() {}
Func.prototype.func = function () {};
console.log(Object.keys(new Func())); // => []
```

如果你就是要定义实例属性的话还是只能通过 `this.xxx = xxx` 的方式定义实例方法了：

```js
function Engineer(workingYears) {
  this.workingYears = workingYears;
  this.built = function () {
    console.log(`我已经工作 ${this.workingYears} 年了, 我的工作是拧螺丝...`);
  };
}

const engineer = new Engineer(5);
console.log(Object.keys(engineer)); // => [ 'workingYears', 'built' ]
```

其实 JavaScript 中很多方法都定义在构造器的原型上，例如 Array.prototype.slice，Object.prototype.toString 等。

## 原型继承

在讲`原型继承` 之前我们先讲讲`继承`这个词。我觉得，通俗意义上的`继承`是说：**如果类 A 继承自类 B，那么 A 的实例继承了 B 的实例属性**。

`原型继承`的这个`继承`和通俗意义上的`继承`还不太一样，它是要：**A 的实例能够继承 B 的原型上的属性**。

给原型继承下个定义：

```js
对于类 A 和类 B，如果满足 A.prototype.__proto__ === B.prototype，那么 A 原型继承 B
```



![img](https://pic3.zhimg.com/80/v2-85e5c2bfafc2f35abe3c71cd86980f56_720w.jpg)



其实上面的定义太严格了，我觉得只要 B 的 prototype 在 A 的原型链上就行了，这样就已经可以在 A 的实例上访问 B 原型上的属性了，上面的定义可以说是直接继承，但是可以二级或更多级的继承嘛。

如何实现原型继承呢？最简单的方式就是直接设置 `A.prototype === new B()`，让 A 的 prototype 是 B 的实例即可：

```js
function A() {}
function B() {
  this.xxx = '污染 A 的原型';
}

A.prototype = new B();

console.log(A.prototype.__proto__ === B.prototype); // => true
```

但是这种方式会导致 B 的实例属性污染 A 的原型。解决办法就是通过一个空的函数桥接一下，空的函数总不会有实例属性污染原型链喽：

```js
function A(p) {
  this.p = p;
}

function B() {
  this.xxx = '污染原型';
}

// 空函数
function Empty() {}

Empty.prototype = B.prototype;
A.prototype = new Empty();
// 修正 constructor 指向
A.prototype.constructor = A;

// 满足原型继承的定义
console.log(A.prototype.__proto__ === B.prototype); // => true

const a = new A('p');
console.log(a instanceof A); // => true

const b = new B();
console.log(b instanceof B); // => true

// a 也是 B 的实例
console.log(a instanceof B); // => true
console.log(a.__proto__.__proto__ === B.prototype); // => true
```

## JavaScript 和原型相关语法特性

其实由很多语法特性是和原型有关系的，讲到原型那么我们就再继续讲讲 JavaScrip 语法特性中涉及到原型的一些知识点。

### new 运算符原理

当我们对函数使用 new 的时候发生了什么。

使用代码来描述就是：

```js
function isObject(value) {
  const type = typeof value;
  return value !== null && (type === 'object' || type === 'function');
}

/**
 * constructor 表示 new 的构造器
 * args 表示传给构造器的参数
 */
function New(constructor, ...args) {
  // new 的对象不是函数就抛 TypeError
  if (typeof constructor !== 'function') throw new TypeError(`${constructor} is not a constructor`);

  // 创建一个原型为构造器的 prototype 的空对象 target
  const target = Object.create(constructor.prototype);
  // 将构造器的 this 指向上一步创建的空对象，并执行，为了给 this 添加实例属性
  const result = constructor.apply(target, args);

  // 上一步的返回如果是对象就直接返回，否则返回 target
  return isObject(result) ? result : target;
}
```

简单测试一下：

```js
function Computer(brand) {
  this.brand = brand;
}

const c = New(Computer, 'Apple');
console.log(c); // => Computer { brand: 'Apple' }
```

### instanceof 运算符原理

instanceof 用于判断对象是否是某个类的实例，如果 obj instance A，我们就说 obj 是 A 的实例。

它的原理很简单，一句话概括就是：**obj instanceof 构造器 A，等同于判断 A 的 prototype 是不是 obj 的原型（也可能是二级原型）**。

代码实现：

```js
function instanceOf(obj, constructor) {
  if (!isObject(constructor)) {
    throw new TypeError(`Right-hand side of 'instanceof' is not an object`);
  } else if (typeof constructor !== 'function') {
    throw new TypeError(`Right-hand side of 'instanceof' is not callable`);
  }

  // 主要就这一句
  return constructor.prototype.isPrototypeOf(obj);
}
```

简单测试一下：

```js
function A() {}
const a = new A();

console.log(a instanceof A); // => true
console.log(instanceOf(a, A)); // => true
```

## 原型污染

在去年 2019 年秋天我还在国内某大厂实习的时候，lodash 爆出了一个严重的安全漏洞：[Lodash 库爆出严重安全漏洞，波及 400 万+项目](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/tfZq2PZylGfMjOp8h8eeTw)。这个安全漏洞就是由于**原型污染**导致的。

原型污染指的是：

> 攻击者通过某种手段修改 JavaScript 对象的原型

虽然说任何一个原型被污染了都有可能导致问题，但是我们一般提原型污染说的就是 `Object.prototype` 被污染。

### 原型污染的危害

### 性能问题

举个最简单的例子：

```js
Object.prototype.hack = '污染原型的属性';
const obj = { name: 'xiaoHong', age: 18 };
for (const key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(obj[key]);
  }
}

/* =>
xiaoHong
18
*/
```

原型被污染会增加遍历的次数，每次访问对象自身不存在的属性时也要访问下原型上被污染的属性。

### 预防原型污染

其实原型污染大多发生在调用会修改或者扩展对象属性的函数时，例如 lodash 的 defaults，jquery 的 extend。预防原型污染最主要还是要有防患意识，养成良好的编码习惯。

### Object.create(null)

笔者看过一些类库的源码时，经常能看到这种操作，例如 [EventEmitter3](https://link.zhihu.com/?target=https%3A//github.com/primus/eventemitter3/blob/master/index.js%23L23)。通过 Object.create(null) 创建没有原型的对象，即便你对它设置`__proto__` 也没有用，因为它的原型一开始就是 null，没有 `__proro__` 的 `setter`。

```js
const obj = Object.create(null);
obj.__proto__ = { hack: '污染原型的属性' };
const obj1 = {};
console.log(obj1.__proto__); // => {}
```

### Object.freeze(obj)

可以通过 Object.freeze(obj) 冻结对象 obj，被冻结的对象不能被修改属性，成为不可扩展对象。前面也说过不能修改不可扩展对象的原型，会抛 TypeError：

```js
const obj = Object.freeze({ name: 'xiaoHong' });
obj.xxx = 666;
console.log(obj); // => { name: 'xiaoHong' }
console.log(Object.isExtensible(obj)); // => false
obj.__proto__ = null; // => TypeError: #<Object> is not extensible
```

距离我从之前实习的公司离职也有将近三个月了，我记得那时候每次 `npm install` 都显示检查出几十个依赖漏洞。肯定是好久都没升级才会积累那么多漏洞，反正我是不敢随便升级，之前一个 bug 查了好半天结果是因为 axios 的升级导致的。也不知道到现在有没有升级过 。

## 一道最近校招面试碰到的和原型相关的面试题

最近面试某大厂碰到下面这道面试题：

```js
function Page() {
  return this.hosts;
}
Page.hosts = ['h1'];
Page.prototype.hosts = ['h2'];

const p1 = new Page();
const p2 = Page();

console.log(p1.hosts);
console.log(p2.hosts);
```

运行结果是：先输出 `undefiend`，然后报错 `TypeError: Cannot read property 'hosts' of undefined`。

为什么 `console.log(p1.hosts)` 是输出 `undefiend` 呢，前面我们提过 new 的时候如果 return 了对象，会直接拿这个对象作为 new 的结果，因此，`p1` 应该是 `this.hosts` 的结果，而在 `new Page()` 的时候，this 是一个以 `Page.prototype` 为原型的 `target` 对象，所以这里 `this.hosts` 可以访问到 `Page.prototype.hosts` 也就是 `['h2']`。这样 `p1` 就是等于 `['h2']`，`['h2']` 没有 `hosts` 属性所以返回 `undefined`。

为什么 `console.log(p2.hosts)` 会报错呢，`p2` 是直接调用 `Page` 构造函数的结果，直接调用 `page` 函数，这个时候 `this` 指向全局对象，全局对象并没 `hosts` 属性，因此返回 `undefined`，往 `undefined` 上访问 `hosts` 当然报错。

# 什么是变量提升

## 前沿

大家对变量提升(`hoisting`)一定不陌生了，这篇文章希望可以建立一个系统的规则，以后碰到变量提升，可以重新看这篇文章，根据文中的规则找到答案。最终，我们可以记住这个规则，很自然的理解变量提升。

------

## 例子

相信大家对这个例子不陌生了：

```js
a = 2;

var a;

console.log( a ); /// 2
```

为什么这段话`a` 在声明之前就可以赋值了呢？

再看下这个例子：

```js
console.log( a );  //undefined

var a = 2;
```

为什么这个又是输出`undefined`呢？

别担心，看完整个文章你就会知道运用怎样的规则来推断结果了。

------

## 作用域浅析

在这里我们对作用域不做详细的讲解，**作用域可以想象成可访问对象的集合**。

打个通俗的比方，现在有个公寓管理公司，底下有多个公寓。`高级管理员A`， 他有所有公寓所有房间的钥匙，所以他能打开所有公寓所有房间，并能拿出所有房间的物品。`中级管理员B`，只有某一栋公寓所有房间的钥匙，他能拿出所有此公寓所有房间的物品，但是不能拿出其他公寓的物品。原因就是管理员B在拿物品时（程序执行代码时）， 并没用其他公寓的信息（其他作用域内信息）。

![img](https://pic1.zhimg.com/80/v2-21fb482c93e01ff248c5f7cc3abe084c_720w.jpg)

> **为了简单，本篇文章只涉及同一个作用域下，不同作用域的交互之后几篇会讲到**

大家可以想像成进入到全局作用域或者某个函数作用域时，引擎会产生一个`json object` 当作资料库， 之后代码执行的时候会从这个`json` 中找值。

```js
var pseudoContext = {

}
```

------

## JavaScript解析器

一般来说，大家可能觉得JavaScript解析器会在 run-time 运行时一行一行的来解析代码。

事实上当解释器到达一个作用域后，会先编译代码，然后再一行一行解析。

当JavaScript引擎运行到某个作用域后 ( 在第一个例子中，作用域是 `global` 全局作用域 )

它会有两个步骤

\1. **初始化阶段 ( Creation Stage)** [当进入一个作用域，逐行运行代码之前]

\+ 创建 `var` 变量， `function` 函数和函数的`arguments` 参数

\2. **代码执行阶段 (Activation/Code Execution Stage)**

\+ 给变量和函数赋值，以及执行代码

------

> **初始化阶段 ( Creation Stage)**
> 在初始化阶段，进入一个作用域时会发生：
> \1. 如果作用域是函数内部，把函数参数放进前面的`context json` 中
> \2. 扫描当前作用域寻找函数：
> \+ 每发现一个函数，就把名字和函数指针放进前面的json中
> \+ 如果函数名已经存在，覆盖之前的函数指针 3. 扫描当前作用域寻找变量：
> \+ 每发现一个变量 `var`，就把名字放进前面的`json`中，并把值设>成 `undefined`
> \+ 如果变量名已经存在，不会覆盖，忽略然后继续扫描
>
> **代码执行阶段 (Activation/Code Execution Stage)**
> 逐行执行代码，并且赋值之前为`undefined`的变量`var`

------

## 例子1

我们回到之前的例子：

```js
a = 2;

var a;

console.log( a ); /// 2
```

我们把之前讲的规则拿来套用：

1. 首先进入全局作用域，初始化一个空的模拟作用域 `json`

2. 逐步执行代码之前，执行初始化阶段

3. 1. 作用域不是函数内部，没用函数参数，忽略
2. 扫描未发现函数，忽略
3. 扫描发现变量`var a`, 放进json里并设置成`undefined`

4. 此时我们的 `json`：

```js
pseudoContext = {

      a = undefined
}
a = 2
```

4.扫描完成，逐行执行代码

```js
a = 2
```

5.扫描我们的作用域，发现`pseudoContext`里存在`a`，赋值成`2`

```js
pseudoContext = {
      a = 2
}
```

6.下一步：

```js
console.log( a );
```

7.在作用域`pseudoContext` 中找到 `a`， 发现有值，输出`2`

------

## 例子2

```js
console.log( a );  //undefined

var a = 2;
```

1. 首先进入全局作用域，初始化一个空的模拟作用域`json`

2. 逐步执行代码之前，执行初始化阶段

3. 1. 作用域不是函数内部，没用函数参数，忽略
2. 扫描未发现函数，忽略
3. 扫描发现变量`var a`, 放进json里并设置成`undefined`

4. 此时我们的`json`：

```js
pseudoContext = {
   variables: {
      a = undefined
   }
}
```

4.扫描完成，逐行执行代码

```js
console.log( a );
json`里`a`是`undefined`， 所以输出`undefined
```

------

## 更复杂的例子3

```js
console.log(typeof foo); // function pointer
console.log(typeof bar); // undefined

var foo = 'hello',
    bar = function() {
        return 'world';
    };

function foo() {
        return 'hello';
}
```

1.首先进入全局作用域，初始化一个空的模拟作用域`json`

2.逐步执行代码之前，执行初始化阶段

3.作用域不是函数内部，没用函数参数，忽略

4.扫描发现函数`foo`（第9行）， 声明并赋值

5.此时的 json:

```text
pseudoContext = {
    foo = function pointer
} 
```

6.扫描发现变量`var foo`, 因为`foo`名字已经存在了，依照之前规则 "**如果变量名已经存在，不会覆盖，忽略然后继续扫描**", 忽略

7.扫描发现变量 `var bar`, 赋值成`undefined`
**引擎会先函数扫描，再变量扫描**

8.此时我们的`json`：

```js
pseudoContext = {
    foo = function pointer,
    bar = undefined
}
```

扫描完成，逐行执行代码

```js
console.log(typeof foo);
json`里`foo` 是`function pointer`，返回`function
```

下一步：

```js
console.log(typeof bar);
json`里`bar`是`undefined`，输出`undefined
```

------

## `let` 和 `const`

希望以上讲的大家都能理解，再来说说`let`和`const`，这两个和`var`不同 他们在所谓的 时间静止区 `temporal dead zone (TDZ)`(不知道谁取的这么中二的名字)。

- 当进入一个作用域时，我们不会把它加在我们`json`里
- 一开始`get`或者`set`的时候就会报错 `ReferenceError`
- 逐行执行时，如果有`let``const`声明，就会在作用域`json`里创建，如果赋值了，就会在作用域`json`里赋值

```js
b   // Uncaught ReferenceError: b is not defined
let b =2
```

------

## 总结

希望大家看了这篇文章对变量提升有更深的理解，变量提升只是表象，只是一个js解析器和作用域共同产生的一个结果。之后会更加详细的讲解一下作用域


# 什么是立即执行函数？有什么作用？

这是 JS 中的一个常见概念，面试时经常会被问到，请「用自己的语言」简述

1. 立即执行函数是什么
2. 立即执行函数有什么用途



\-------------------------------------------

回答：

## 1. 立即执行函数是什么

立即执行函数就是

1. 声明一个匿名函数
2. 马上调用这个匿名函数





![img](https://pic3.zhimg.com/80/d043f5554b4db3baf464606c15ab4c06_720w.png)

上面是一个典型的立即执行函数。



- 首先声明一个匿名函数 function(){alert('我是匿名函数')}。
- 然后在匿名函数后面接一对括号 ()，调用这个匿名函数。



**那么为什么还要用另一对括号把匿名函数包起来呢？**

其实是为了兼容 JS 的语法。

如果我们不加另一对括号，直接写成

```text
function(){alert('我是匿名函数')}()
```

浏览器会报语法错误。想要通过浏览器的语法检查，必须加点小东西，比如下面几种

```text
(function(){alert('我是匿名函数')} ()) // 用括号把整个表达式包起来
(function(){alert('我是匿名函数')}) () //用括号把函数包起来
!function(){alert('我是匿名函数')}() // 求反，我们不在意值是多少，只想通过语法检查。
+function(){alert('我是匿名函数')}()
-function(){alert('我是匿名函数')}()
~function(){alert('我是匿名函数')}()
void function(){alert('我是匿名函数')}()
new function(){alert('我是匿名函数')}()
```

## 2. 立即执行函数有什么用？

只有一个作用：创建一个独立的作用域。

这个作用域里面的变量，外面访问不到（即避免「变量污染」）。

以一个[著名的面试题](https://link.zhihu.com/?target=http%3A//js.jirengu.com/didu/1)为例：

```text
var liList = ul.getElementsByTagName('li')
for(var i=0; i<6; i++){
  liList[i].onclick = function(){
    alert(i) // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5
  }
}
```

为什么 alert 的总是 6 呢，因为 i 是贯穿整个作用域的，而不是给每个 li 分配了一个 i，如下：



![img](https://pic1.zhimg.com/80/d9da14084ed79b36d947bf68dda96074_720w.png)

那么怎么解决这个问题呢？用立即执行函数给每个 li 创造一个独立作用域即可（当然还有其他办法）：



```text
var liList = ul.getElementsByTagName('li')
for(var i=0; i<6; i++){
  !function(ii){
    liList[ii].onclick = function(){
      alert(ii) // 0、1、2、3、4、5
    }
  }(i)
}
```

在立即执行函数执行的时候，i 的值被赋值给 ii，此后 ii 的值一直不变。

i 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。

以上，就是立即执行函数的基本概念。


# 什么是闭包？闭包的优缺点？

出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。

那就是在函数内部，再定义一个函数。

```js
function f1(){
　　var n=999;
　　function f2(){
　　　　alert(n); // 999
　　}
}
```

**闭包的概念**

上面代码中的f2函数，就是闭包。

各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。

**使用闭包的注意点**

（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

**闭包有哪些应用场景**

*闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。*

# 什么是防抖和节流

## 1、概念

### 函数防抖（debounce）

> 函数防抖，就是指触发事件后在规定时间内函数只能执行一次，如果在 规定时间内又触发了事件，则会重新计算函数执行时间。

简单的说，当一个动作连续触发，则只执行最后一次。
如，坐公交，司机需要等最后一个人进入才能关门。每次进入一个人，司机就会多等待几秒再关门。

### 函数节流（throttle）

> 限制一个函数在规定时间内只能执行一次。

如，乘坐地铁，过闸机时，每个人进入后3秒后门关闭，等待下一个人进入。

## 2、可视化工具

为了更好的理解，我们可以通过这个可视化工具来感受一下三种环境（正常情况、函数防抖情况 debounce、函数节流 throttle）下，对于mousemove事件回调的执行情况。【[可视化的工具](https://link.zhihu.com/?target=http%3A//demo.nimius.net/debounce_throttle/) 】
我自己实验的截图如下：

![img](https://pic3.zhimg.com/80/v2-8bfbf8694b7be7384d709105de0f684a_720w.jpg)


竖线的疏密代表事件执行的频繁程度。可以看到，正常情况下，竖线非常密集，函数执行的很频繁。而debounce（函数防抖）则很稀疏，只有当鼠标停止移动时才会执行一次。throttle（函数节流）分布的较为均已，每过一段时间就会执行一次。

## 3、常见应用场景

### 函数防抖的应用场景

连续的事件，只需触发一次回调的场景有：

- 搜索框搜索输入。只需用户最后一次输入完，再发送请求
- 手机号、邮箱验证输入检测
- 窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

### 函数节流的应用场景

间隔一段时间执行一次回调的场景有：

- 滚动加载，加载更多或滚到底部监听
- 谷歌搜索框，搜索联想功能
- 高频点击提交，表单重复提交

## 4、实现原理及代码封装

### 以页面元素滚动监听的例子，来进行解析：

### 函数节流：规定延迟时间（delay）内只执行最开始触发的函数

```js
// 函数节流
let canRun = true;
document.addEventListener('scroll', function(){
    // 判断是否已空闲，如果在执行中，则直接return
    if(!canRun) return;
    canRun = false;
    setTimeout(() => {
        console.log("函数节流");
        canRun = true;
    }, 300);
});
```

**封装一下后是这样的：**

```js
const throttle = function(fn,delay) {
    let canRun = true;
  return function() {
    const context = this
    let args = arguments;
        if(!canRun) return; // 注意，这里不能用timer来做标记，因为setTimeout会返回一个定时器id
        canRun = false;
    setTimeout(() => {
        fn.apply(context,args) 
        canRun = true;
    },delay)
  }
}
```

### 函数防抖：上个函数在规定延迟时间（delay）内未开始执行就接连触发的函数只执行最后触发的函数

```js
// 函数防抖
let timer = false;
document.addEventListener('scroll', function(){
    clearTimeout(timer); // 清除未执行的代码，重置回初始化状态
    timer = setTimeout(function(){
        console.log("函数防抖");
    }, 300);
});
```

**封装一下是这样的：**

```js
const decounce = function(fn, delay) {
  let timer = null
  return function() {
    const context = this
    let args = arguments
    clearTimeout(timer) // 每次调用debounce函数都会将前一次的timer清空，确保只执行一次
    timer = setTimeout(() => {
      fn.apply(context, args)
    }, delay)
  }
}
```

# 手写async await的实现

```js
function asyncToGenerator(generatorFunc) {
  // 返回的是一个新的函数
  return function() {
  
    // 先调用generator函数 生成迭代器
    // 对应 var gen = testG()
    const gen = generatorFunc.apply(this, arguments)
 
    // 返回一个promise 因为外部是用.then的方式 或者await的方式去使用这个函数的返回值的
    // var test = asyncToGenerator(testG)
    // test().then(res => console.log(res))
    return new Promise((resolve, reject) => {
    
      // 内部定义一个step函数 用来一步一步的跨过yield的阻碍
      // key有next和throw两种取值，分别对应了gen的next和throw方法
      // arg参数则是用来把promise resolve出来的值交给下一个yield
      function step(key, arg) {
        let generatorResult
        
        // 这个方法需要包裹在try catch中
        // 如果报错了 就把promise给reject掉 外部通过.catch可以获取到错误
        try {
          generatorResult = gen[key](arg)
        } catch (error) {
          return reject(error)
        }
 
        // gen.next() 得到的结果是一个 { value, done } 的结构
        const { value, done } = generatorResult
 
        if (done) {
          // 如果已经完成了 就直接resolve这个promise
          // 这个done是在最后一次调用next后才会为true
          // 以本文的例子来说 此时的结果是 { done: true, value: 'success' }
          // 这个value也就是generator函数最后的返回值
          return resolve(value)
        } else {
          // 除了最后结束的时候外，每次调用gen.next()
          // 其实是返回 { value: Promise, done: false } 的结构，
          // 这里要注意的是Promise.resolve可以接受一个promise为参数
          // 并且这个promise参数被resolve的时候，这个then才会被调用
          return Promise.resolve(
            // 这个value对应的是yield后面的promise
            value
          ).then(
            // value这个promise被resove的时候，就会执行next
            // 并且只要done不是true的时候 就会递归的往下解开promise
            // 对应gen.next().value.then(value => {
            //    gen.next(value).value.then(value2 => {
            //       gen.next()
            //
            //      // 此时done为true了 整个promise被resolve了
            //      // 最外部的test().then(res => console.log(res))的then就开始执行了
            //    })
            // })
            function onResolve(val) {
              step("next", val)
            },
            // 如果promise被reject了 就再次进入step函数
            // 不同的是，这次的try catch中调用的是gen.throw(err)
            // 那么自然就被catch到 然后把promise给reject掉啦
            function onReject(err) {
              step("throw", err)
            },
          )
        }
      }
      step("next")
    })
  }
}
```


# 手写深拷贝

先问这么几个问题，

- 首先为什么要深拷贝？不希望数据被修改或者只需要部分修改数据。
- 怎么实现深拷贝？简单需求用 JSON 反序列化，复杂需求用递归克隆。
- 手写深拷贝的优点？体现扎实的 JS 基础。
- 至于缺点以及如何解决稍后再回答

### 简单需求

最简单的手写深拷贝就一行，通过 **JSON 反序列化**来实现

```js
const B = JSON.parse(JSON.stringify(A))
```

缺点也是显而易见的，**JSON value不支持的数据类型，都拷贝不了**

1. 不支持函数
2. 不支持undefined（**支持null**）
3. 不支持循环引用，比如 `a = {name: 'a'}`; `a.self = a`; `a2 = JSON.parse(JSON.stringify(a))`
4. 不支持Date，会变成 ISO8601 格式的字符串
5. 不支持正则表达式
6. 不支持Symbol

如何支持这些复杂需求，就需要用到**递归克隆**了。

### 复杂需求

**核心**有三点：

1. 递归
2. 对象分类型讨论
3. 解决循环引用（环）

下面给出我的模板：

```js
class DeepClone {
  constructor() {
    this.cacheList = [];
  }
  clone(source) {
    if (source instanceof Object) {
      const cache = this.findCache(source);
      if (cache) return cache; // 如果找到缓存，直接返回
      else {
        let target;
        if (source instanceof Array) {
          target = new Array();
        } else if (source instanceof Function) {
          target = function () {
            return source.apply(this, arguments);
          };
        } else if (source instanceof Date) {
          target = new Date(source);
        } else if (source instanceof RegExp) {
          target = new RegExp(source.source, source.flags);
        }
        this.cacheList.push([source, target]); // 把源对象和新对象放进缓存列表
        for (let key in source) {
          if (source.hasOwnProperty(key)) { // 不拷贝原型上的属性，太浪费内存
            target[key] = this.clone(source[key]); // 递归克隆
          }
        }
        return target;
      }
    }
    return source;
  }
  findCache(source) {
    for (let i = 0; i < this.cacheList.length; ++i) {
      if (this.cacheList[i][0] === source) {
        return this.cacheList[i][1]; // 如果有环，返回对应的新对象
      }
    }
    return undefined;
  }
}
```

补充一句，如果您想看详细的测试与运行结果，请参见 [我的 GitHub →](https://link.zhihu.com/?target=https%3A//github.com/venaissance/source-deepClone)

递归克隆看起来很强大，但是完美无缺吗？其实还是有不小的距离：

1. 对象类型支持不够多（Buffer，Map，Set等都不支持）
2. 存在递归爆栈的风险

如果要解决这些问题，实现一个”完美“的深拷贝，只能求教上百行代码的 [Lodash.cloneDeep()](https://link.zhihu.com/?target=https%3A//github.com/lodash/lodash/blob/master/cloneDeep.js) 了 。

让我们再引申一下，深拷贝有局限吗？

## 深拷贝的局限

如果需要对一个复杂对象进行频繁操作，每次都完全深拷贝一次的话性能岂不是太差了，因为大部分场景下都只是更新了这个对象的某几个字段，而其他的字段都不变，对这些不变的字段的拷贝明显是多余的。那么问题来了，浅拷贝不更新，深拷贝性能差，怎么办？

这里推荐3个可以实现”部分“深拷贝的库：

1. [Immutable.js](https://link.zhihu.com/?target=https%3A//immutable-js.github.io/immutable-js/) Immutable.js 会把对象所有的 key 进行 hash 映射，将得到的 hash 值转化为二进制，从后向前每 5 位进行分割后再转化为 Trie 树。Trie 树利用这些 hash 值的公共前缀来减少查询时间，最大限度地减少无谓 key 的比较。关于 Trie 树（字典树）的介绍，可以看我的博客[算法基础06-字典树、并查集、高级搜索、红黑树、AVL 树](https://zhuanlan.zhihu.com/p/136103651)
2. [seamless-immutable](https://link.zhihu.com/?target=https%3A//github.com/rtfeldman/seamless-immutable)，如果数据量不大但想用这种类似 updateIn 便利的语法的话可以用 seamless-immutable。这个库就没有上面的 Trie 树这些幺蛾子了，就是为其扩展了 updateIn、merge 等 9 个方法的普通简单对象，利用 Object.freeze 冻结对象本身改动, 每次修改返回副本。感觉像是阉割版，性能不及 Immutable.js，但在部分场景下也是适用的。
3. [Immer.js](https://link.zhihu.com/?target=https%3A//github.com/immerjs/immer)，通过用来数据劫持的 Proxy 实现：对原始数据中每个访问到的节点都创建一个 Proxy，修改节点时修改副本而不操作原数据，最后返回到对象由未修改的部分和已修改的副本组成。（这不就是 Vue3 数据响应式原理嘛）

## 总结

看完这一段，你现在能回答怎么实现深拷贝了吗？概括成一句就是：**简单需求用 JSON 反序列化，复杂需求用递归克隆**。

对于递归克隆的深拷贝，核心有三点：

1. **对象分类**
2. **递归**
3. 用**缓存**对付**环**

# 请描述一下 cookies，sessionStorage 和 localStorage 的区别？

### **cookie:**

o  cookie是网站为了**标示用户身份**而储存在用户本地终端（Client Side）上的数据（通常经过加密）。

o  cookie数据**始终在同源的http请求中携带**（即使不需要），记会在浏览器和服务器间来回传递。

**sessionStorage****和localStorage**不会自动把数据发给服务器，仅在本地保存。

### **存储大小：**

o  cookie数据大小不能超过4k。

o  sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

###  **有期时间**：

o  localStorage  存储**持久数据**，浏览器关闭后数据不丢失除非主动删除数据；

o  sessionStorage 数据在当前浏览器窗口关闭后自动删除。

o  cookie      设置的cookie**过期时间之前**一直有效，即使窗口或浏览器关闭

### **作用域不同:**

o  sessionStorage**不在**不同的浏览器窗口中共享，即使是同一个页面；

o  localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。

# 谈一谈对浏览器的强缓存和协商缓存的理解

浏览器缓存主要有以下几个优点：

1. 减少重复数据请求，避免通过网络再次加载资源，节省流量。
2. 降低服务器的压力，提升网站性能。
3. 加快客户端加载网页的速度， 提升用户体验。

浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：

1. 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。
2. 在 `chrome` 中强缓存（虽然没有发出真实的 `http` 请求）的请求状态码返回是 `200 (from cache)`；而协商缓存如果命中走缓存的话，请求的状态码是 `304 (not modified)`。 不同浏览器的策略不同，在 `Fire Fox`中，`from cache` 状态码是 304.

> 其中 from cache 会分为 from disk cache 和 from memory cache. 从内存中获取最快，但是是 session 级别的缓存，关闭浏览器之后就没有了。

![img](https://pic4.zhimg.com/80/v2-f894421b4f38f0efe640985b48401bbb_720w.png)



### 请求流程

浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤：

1. 浏览器会获取该缓存资源的 `header` 中的信息，根据 `response header` 中的 `expires` 和 `cache-control` 来判断是否命中强缓存，如果命中则直接从缓存中获取资源。
2. 如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 `IF-Modified-Since` 或者 `IF-None-Match`, 它们的值分别是第一次请求返回 `Last-Modified`或者 `Etag`，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段。

借用网上的一张图片



![img](https://pic1.zhimg.com/80/v2-566dd2c739ba080c5b3a35e889d34d68_720w.jpg)



### 强缓存

强缓存是根据返回头中的 `Expires` 或者 `Cache-Control` 两个字段来控制的，都是表示资源的缓存有效时间。

- `Expires` 是 `http 1.0` 的规范，值是一个`GMT` 格式的时间点字符串，比如 `Expires:Mon,18 Oct 2066 23:59:59 GMT` 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存。有一个缺点是，失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。而服务器的时间跟用户的实际时间是不一样是很正常的，所以 `Expires` 在实际使用中会带来一些麻烦。
- `Cache-Control`这个字段是 `http 1.1` 的规范，一般常用该字段的 `max-age` 值来进行判断，它是一个相对时间，比如 .`Cache-Control:max-age=3600` 代表资源的有效期是 3600 秒。并且返回头中的 `Date` 表示消息发送的时间，表示当前资源在 `Date ~ Date +3600s` 这段时间里都是有效的。不过我在实际使用中常常遇到设置了 `max-age` 之后，在 `max-age` 时间内重新访问资源却会返回 `304 not modified` ，这是由于服务器的时间与本地的时间不同造成的。当然 `Cache-Control` 还有其他几个值可以设置， 不过相对来说都很少用了：
- `no-cache` 不使用本地缓存。需要使用协商缓存。
- `no-store`直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 `network` 中的 `disabled cache`。
- `public` 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。
- `private` 只能被终端用户的浏览器缓存。

如果 `Cache-Control`与 `Expires` 同时存在的话， `Cache-Control` 的优先级高于 `Expires` 。

### 协商缓存

协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, `Last-Modified` 或者 `Etag`，则后续请求则会带上对应的请求字段 `If-Modified-Since`或者 `If-None-Match`，若响应头没有 `Last-Modified` 或者 `Etag` 字段，则请求头也不会有对应的字段。

- `Last-Modified/If-Modified-Since` 二者的值都是GMT格式的时间字符串， `Last-Modified` 标记最后文件修改时间， 下一次请求时，请求头中会带上 `If-Modified-Since` 值就是 `Last-Modified` 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 `304 Not Modified` ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 `304 Not Modified` 的响应时，`response header` 中不会再添加的 `Last-Modified` 去试图更新本地缓存的 `Last-Modified`， 因为既然资源没有变化，那么 `Last-Modified` 也就不会改变；如果资源有变化，就正常返回返回资源内容，新的 `Last-Modified` 会在 `response header` 返回，并在下次请求之前更新本地缓存的 `Last-Modified`，下次请求时，`If-Modified-Since`会启用更新后的 `Last-Modified`。
- `Etag/If-None-Match`， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 `ETag`字段返回给浏览器，接收到 `If-None-Match` 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。与 `Last-Modified` 不一样的是，当服务器返回 `304 Not Modified` 的响应时，由于在服务器上`ETag` 重新计算过，`response header`中还会把这个 `ETag` 返回，即使这个 `ETag` 跟之前的没有变化。

> HTTP中并没有指定如何生成 ETag，可以由开发者自行生成，哈希是比较理想的选择。

### 为什么要有 Etag

`HTTP1.1` 中 `Etag` 的出现主要是为了解决几个 `Last-Modified` 比较难解决的问题：

- 一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，`If-Modified-Since` 能检查到的粒度是秒级的，使用 `Etag` 就能够保证这种需求下客户端在1秒内能刷新 N 次 cache。
- 某些服务器不能精确的得到文件的最后修改时间。

### 优先级

```js
Cache-Control  > expires > Etag > Last-Modified
```

### 用户行为对缓存的影响

~~简单说就是 F5 刷新的时候，会暂时禁用强缓存~~

经过对qq、fire fox 、safari 、chrome 这几个浏览器的访问同一个页面测试我发现，不同的浏览器在 F5 刷新的时候 ，同一个文件 qq 、fire fox 浏览器会返回 `304 Not Nodified`，在请求头中不携带 `Expires/Cache-Control`； 而 chrome 和 safari 刷新的时候，会返回 `200 from cache`， 没有真正发起请求，走强缓存。可见不同的浏览器反馈是不一致的，所以下面表格中"F5刷新"时 `Expires/Cache-Control` 会无效我认为是存在一定争议的。

而 Ctrl + F5 强制刷新的时候，会暂时禁用强缓存和协商缓存。

> 在写这篇博客时，对于我仅仅测试了一个浏览器之后便写了无效(因为网上大多数帖子写了无效，我也以为我验证通过了)，对指出这个问题的群友，表示感谢，希望其他人不会被我误导。

![img](https://pic1.zhimg.com/80/v2-d1cc1a5d73f3c794ca12fd107a1de688_720w.jpg)

### 如何设置强缓存和协商缓存

1. 后端服务器，写入代码逻辑中：

```js
res.setHeader('max-age': '3600 public') res.setHeader(etag: '5c20abbd-e2e8') res.setHeader('last-modified': Mon, 24 Dec 2018 09:49:49 GMT)
```

1. `Nginx` 配置

```js
add_header Cache-Control "max-age=3600"
```

一般来说，通过 nginx 静态资源服务器，会默认给资源带上强缓存、协商缓存的 header 字段。



![img](https://pic3.zhimg.com/80/v2-6069d7667cf18a19e46ebc09cd5b31de_720w.jpg)



### 两个示例

1. 如果在 `cache-control`定义的 `max-age` 时间之内，`js`, `css` 文件会走强缓存，`http` 状态码是 200， 跟服务器也并不会有交互。但是第一个文件 `index.html` 文件, 每次回车或者刷新都是状态码都是 304 ，因为它的请求头中默认每次都携带了 `Cache-Control: max-age=0` 。



![img](https://pic4.zhimg.com/80/v2-a1f482db9e5ceec4c7c168b841c7890b_720w.png)





![img](https://pic1.zhimg.com/80/v2-0c7046464103e332d7c9026d9038da74_720w.jpg)



1. `js``css` 文件 `cache-control` 超时之后，重新按回车会走协商缓存，请求服务器发现资源没有改变，于是返回 304 ，浏览器从缓存中获取内容，从 `size` 中也可以看出端倪， 几百 B 的包不是静态资源的体积。



![img](https://pic2.zhimg.com/80/v2-e2bbd3280d84d735327cadb2630bc3e5_720w.png)



### 三级缓存原理（大白话）

最后总结一下浏览器的三级缓存原理：

1. 先去内存看，如果有，直接加载
2. 如果内存没有，择取硬盘获取，如果有直接加载
3. 如果硬盘也没有，那么就进行网络请求
4. 加载到的资源缓存到硬盘和内存

# 跨域是请求不能发送还是后端拒绝

如果你当前网址跟请求的网址不同源，即协议、主机、端口不同，发送的请求即为“跨域请求”。浏览器发送跨域请求时，会预先发送option请求到你所请求的服务器，判断服务器是否支持跨域请求，如果支持，浏览器则继续发送正常get请求，如果不支持，则浏览器无法正常发送get请求。
