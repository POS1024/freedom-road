# 在构建新网站或维护网站时，您能解释一下您用来提高性能的一些技术吗？
在构建新网站或维护现有网站时，提高性能是确保用户体验和站点效率的重要方面。以下是一些常见的技术和策略，用于优化网站性能：

### 前端性能优化

1. **压缩和合并文件：**
    - **CSS 和 JavaScript 压缩**：使用工具如 UglifyJS、Terser、CSSNano 来压缩代码，移除不必要的空格、注释等。
    - **文件合并**：将多个 CSS 和 JavaScript 文件合并成一个文件，减少 HTTP 请求的数量。

2. **使用内容分发网络（CDN）：**
    - **CDN**：将静态资源（如图像、CSS、JavaScript 文件）分发到多个地理位置的服务器，减少延迟并提高加载速度。

3. **图片优化：**
    - **图像压缩**：使用工具如 ImageOptim、TinyPNG、JPEG-Optimizer 压缩图像大小而不明显损失质量。
    - **现代图像格式**：使用 WebP 等现代图像格式，提供更好的压缩比。

4. **延迟加载（Lazy Loading）：**
    - **图片和视频延迟加载**：只在用户滚动到可视区域时加载图片和视频，减少初始加载时间。
    - **惰性加载脚本**：使用 `async` 或 `defer` 属性异步加载 JavaScript 文件，避免阻塞渲染。

5. **浏览器缓存：**
    - **缓存静态资源**：通过设置适当的 HTTP 头（如 `Cache-Control`、`ETag`），使浏览器缓存静态资源，减少重复请求。

6. **使用 HTTP/2：**
    - **HTTP/2**：支持并行请求、头部压缩和服务器推送，显著提高页面加载性能。

7. **减少重绘和重排：**
    - **优化 DOM 操作**：减少直接操作 DOM 的次数，使用文档片段或批量更新。
    - **避免大型、复杂的 CSS 选择器**：使用简单、具体的选择器，提高渲染性能。

8. **启用压缩：**
    - **Gzip/Brotli 压缩**：启用服务器端压缩，减少传输的 HTML、CSS、JavaScript 文件大小。

### 后端性能优化

1. **服务器端缓存：**
    - **页面缓存**：缓存动态生成的页面，减少对数据库的请求。
    - **对象缓存**：缓存常用的数据对象，如数据库查询结果。

2. **数据库优化：**
    - **索引**：创建适当的数据库索引，提高查询性能。
    - **查询优化**：优化 SQL 查询，避免全表扫描，减少查询时间。
    - **数据库连接池**：使用连接池减少连接创建的开销。

3. **使用内容管理系统（CMS）的优化插件：**
    - **缓存插件**：使用缓存插件如 W3 Total Cache、WP Super Cache（针对 WordPress）。
    - **优化数据库插件**：如 WP Optimize，清理冗余数据，提高数据库性能。

### 其他优化技术

1. **减少 HTTP 请求：**
    - **精灵图（Sprite）**：将多个小图标合并成一张图片，通过 CSS 显示对应部分，减少请求数量。
    - **内联小型资源**：将小型 CSS 和 JavaScript 文件内联到 HTML 中，减少请求数量。

2. **使用高效的字体加载：**
    - **字体格式**：使用 WOFF2 等现代字体格式，减小字体文件大小。
    - **字体显示策略**：使用 `font-display` 属性控制字体加载行为，避免闪烁。

3. **优化 CSS 和 JavaScript 的加载顺序：**
    - **关键渲染路径**：优化关键渲染路径，确保关键 CSS 和 JavaScript 最先加载和解析。
    - **异步加载非关键资源**：延迟加载非关键 CSS 和 JavaScript，避免阻塞渲染。

### 性能监测和分析

1. **使用性能监测工具：**
    - **Google Lighthouse**：评估网站性能并提供优化建议。
    - **WebPageTest**：分析页面加载过程，提供详细的性能报告。
    - **Google PageSpeed Insights**：获取页面性能评分和改进建议。

2. **持续性能监测：**
    - **使用监控服务**：如 New Relic、Pingdom，持续监控网站性能，及时发现和解决性能问题。

通过结合使用这些技术和策略，可以显著提高网站的性能，提供更好的用户体验和更高的站点效率。

# 在最近的项目中，您个人采取了哪些措施来提高代码的可维护性？
在最近的项目中，为了提高代码的可维护性，我采取了一些重要的措施。这些措施涵盖了代码组织、规范、文档、测试和工具使用等方面，确保代码不仅在当前项目中易于维护，而且在未来的更新和扩展中也保持良好的可维护性。

### 1. **代码组织和结构**

- **模块化设计**：将代码拆分成独立且功能单一的模块，每个模块只负责一种特定的功能，减少耦合度，提高重用性。
- **文件和目录结构**：采用清晰且有逻辑的文件和目录结构，使得代码更易于导航和理解。例如，将代码分为 `components`、`services`、`utils` 等目录。

### 2. **编码规范**

- **使用代码规范工具**：如 ESLint（针对 JavaScript/TypeScript）、Prettier 等，确保代码风格一致，避免常见的语法错误。
- **遵循编码标准**：采用团队或行业标准的编码规范，如 Airbnb JavaScript Style Guide，确保代码风格一致性和可读性。

### 3. **注释和文档**

- **注释**：在复杂或关键的代码段添加适当的注释，解释代码的目的和逻辑，帮助其他开发者快速理解。
- **文档生成工具**：使用工具如 JSDoc、Typedoc 自动生成代码文档，提供详细的 API 说明和使用示例。
- **README 文件**：在每个模块或项目根目录下提供详细的 README 文件，包含项目简介、安装步骤、使用指南和贡献指南。

### 4. **测试**

- **单元测试**：为核心功能编写单元测试，使用 Jest、Mocha、Chai 等测试框架，确保代码的正确性和稳定性。
- **集成测试**：进行集成测试，验证不同模块之间的交互，使用 Cypress、Selenium 等工具。
- **测试覆盖率**：使用工具如 Istanbul 生成测试覆盖率报告，确保关键代码路径都有测试覆盖。

### 5. **版本控制**

- **Git 分支策略**：采用 Git Flow 或 GitHub Flow 分支管理策略，明确开发、测试和发布分支，确保代码变更的可追溯性和稳定性。
- **详细的提交信息**：遵循约定式提交（Conventional Commits）规范，撰写清晰且有意义的提交信息，帮助理解变更历史。

### 6. **代码审查**

- **代码审查流程**：在每次合并之前进行代码审查，通过 Pull Request 的方式让团队成员进行审查和反馈，发现潜在问题和改进建议。
- **审查工具**：使用 GitHub、GitLab 或 Bitbucket 提供的代码审查工具，确保代码质量和一致性。

### 7. **自动化和持续集成**

- **持续集成（CI）**：使用 CI 工具如 GitHub Actions、Travis CI、Jenkins，自动化测试和构建流程，确保每次代码提交都经过测试验证。
- **自动化部署**：使用持续部署（CD）工具，自动化部署流程，确保代码变更能快速、安全地发布到生产环境。

### 实例应用

在最近的一个前端项目中，我采取了以下具体措施来提高代码的可维护性：

1. **模块化设计**：将组件和功能分为独立的模块，如表单组件、API 服务、实用函数等，每个模块单独维护和测试。
2. **使用 ESLint 和 Prettier**：设置 ESLint 和 Prettier 配置文件，在代码提交时自动格式化和检查代码，保持一致的代码风格。
3. **编写单元测试和集成测试**：为关键功能编写单元测试，并使用 Cypress 进行端到端测试，确保功能的正确性和稳定性。
4. **详细的 README 文件**：在项目根目录和各个模块目录下编写详细的 README 文件，提供安装、使用和开发指南。
5. **代码审查和 CI/CD**：通过 Pull Request 进行代码审查，使用 GitHub Actions 设置持续集成和持续部署流程，自动化测试和部署，提高开发效率。

这些措施显著提高了项目的可维护性，使得团队成员能够更快地理解和修改代码，同时减少了引入错误的风险。

# 您能描述一下创建网页时的工作流程吗？
创建网页时的工作流程通常包括以下几个主要步骤，从项目规划到最终部署，每个步骤都需要精心策划和执行。以下是一个典型的工作流程：

### 1. **项目规划**

- **需求分析**：与客户或项目负责人讨论需求，明确项目目标、功能要求和用户需求。
- **竞品分析**：分析竞争对手的网站，了解行业标准和最佳实践。
- **用户研究**：研究目标用户群体，创建用户画像，明确用户需求和行为习惯。

### 2. **信息架构和线框图**

- **信息架构**：制定网站的整体结构和导航体系，确定主要页面和内容层级。
- **线框图**：创建低保真线框图，展示页面布局和主要元素的位置，确保页面结构合理。

### 3. **设计**

- **视觉设计**：根据线框图制作高保真设计稿，确定颜色、字体、图片和其他视觉元素，确保设计符合品牌形象和用户体验原则。
- **设计工具**：使用设计工具如 Adobe XD、Sketch、Figma 等进行设计，方便与团队协作和原型展示。
- **原型设计**：创建可交互的原型，模拟用户体验，方便进行用户测试和反馈收集。

### 4. **前端开发**

- **HTML 构建**：编写 HTML 代码，搭建页面结构，使用语义化标签提高可访问性和 SEO。
- **CSS 样式**：编写 CSS 代码，进行页面样式和布局设计，确保响应式设计适应不同设备。
- **JavaScript 开发**：编写 JavaScript 代码，实现页面交互和动态效果，使用框架如 React、Vue 或 Angular 提高开发效率。

### 5. **后端开发**

- **服务器设置**：配置服务器环境，选择合适的服务器架构和技术栈（如 Node.js、Python、Ruby）。
- **数据库设计**：设计数据库结构，选择合适的数据库类型（如 MySQL、PostgreSQL、MongoDB），进行数据建模。
- **API 开发**：编写后端代码，创建 RESTful API 或 GraphQL API，实现数据处理和业务逻辑。

### 6. **集成和测试**

- **前后端集成**：将前端页面与后端 API 进行集成，确保数据交互顺畅。
- **功能测试**：进行功能测试，确保所有功能正常运行，使用工具如 Jest、Mocha 进行单元测试和集成测试。
- **用户测试**：进行用户测试，收集用户反馈，进行必要的调整和优化。

### 7. **优化和性能调优**

- **代码优化**：优化代码结构和逻辑，提高代码可维护性和性能，减少冗余代码。
- **性能优化**：优化页面加载速度，压缩和合并文件，使用内容分发网络（CDN），进行图片和资源的懒加载。
- **SEO 优化**：进行搜索引擎优化，编写有效的 meta 标签，优化内容结构和关键词使用。

### 8. **部署和发布**

- **测试环境部署**：将代码部署到测试环境，进行全面的测试和验收。
- **生产环境部署**：将代码部署到生产环境，配置服务器和数据库，确保网站稳定运行。
- **持续集成/持续部署（CI/CD）**：设置 CI/CD 流程，使用工具如 GitHub Actions、Travis CI、Jenkins，自动化构建、测试和部署。

### 9. **维护和更新**

- **监控和分析**：使用监控工具如 Google Analytics、New Relic 监控网站性能和用户行为，及时发现和解决问题。
- **定期更新**：根据用户反馈和业务需求，定期更新和优化网站功能和内容。
- **安全维护**：进行安全审计和漏洞修复，确保网站安全性。

### 实际应用

在最近的一个电商网站项目中，我遵循了上述工作流程，具体步骤如下：

1. **需求分析**：与客户讨论电商网站的功能需求，如产品展示、购物车、支付系统等。
2. **信息架构**：制定网站的导航结构和主要页面，包括首页、产品页、购物车页、结账页等。
3. **设计**：使用 Figma 创建高保真设计稿，并与客户反复沟通确认设计细节。
4. **前端开发**：使用 React 构建前端页面，编写响应式 CSS，确保在移动设备上的良好体验。
5. **后端开发**：使用 Node.js 和 Express.js 开发后端 API，连接 MongoDB 数据库，处理用户数据和订单信息。
6. **测试**：进行全面的功能测试和用户测试，收集反馈并进行优化。
7. **优化和性能调优**：优化页面加载速度，使用 CDN 和懒加载技术，提高用户体验。
8. **部署和发布**：使用 GitHub Actions 设置 CI/CD 流程，自动化构建、测试和部署代码到 AWS 服务器。
9. **维护和更新**：监控网站性能，定期发布更新，处理用户反馈，确保网站持续稳定运行。

通过这样的工作流程，确保项目从初期规划到最终部署都能够有条不紊地进行，提高了项目的质量和交付效率。

# 解释 CSS 动画与 JavaScript 动画的一些优缺点。
CSS 动画和 JavaScript 动画各有其优缺点，具体选择哪一种取决于项目需求、性能要求以及开发人员的熟悉程度。以下是两者的优缺点比较：

### CSS 动画

#### 优点

1. **性能优化：**
    - **硬件加速**：CSS 动画通常由浏览器优化并且可以利用硬件加速，特别是对于简单的动画如变换、透明度和滚动效果。
    - **浏览器优化**：浏览器可以更高效地处理 CSS 动画，因为它们在合成层运行，不需要重绘或重排。

2. **简洁语法：**
    - **易于使用**：使用 `@keyframes` 和 `transition` 属性，定义和管理动画相对简单且直观，适合简单的动画效果。
    - **CSS 样式集中**：所有的样式和动画逻辑都集中在 CSS 文件中，保持 HTML 和 JavaScript 文件的整洁。

3. **减少 JavaScript 负担：**
    - **分离关注点**：将动画逻辑从 JavaScript 中分离出来，有助于维护和组织代码。

#### 缺点

1. **灵活性有限：**
    - **复杂动画**：对于复杂的动画效果（如需要计算中间帧或交互动画），CSS 动画可能难以实现或不够灵活。
    - **事件驱动**：CSS 动画缺乏与 JavaScript 事件的深度交互，无法动态控制动画的中途状态。

2. **浏览器兼容性：**
    - **部分属性不支持**：一些 CSS 动画属性可能在旧版浏览器中不受支持，需要考虑兼容性问题。

### JavaScript 动画

#### 优点

1. **高度灵活性：**
    - **复杂动画**：可以通过计算和逻辑实现非常复杂和细致的动画效果，适用于游戏或高度交互的用户界面。
    - **动态控制**：能够实时控制动画的各个方面，轻松实现暂停、恢复、加速等操作。

2. **事件驱动：**
    - **深度交互**：可以结合用户交互（如鼠标移动、点击等）实时更新动画，提供更丰富的用户体验。

3. **库和框架支持：**
    - **丰富的动画库**：有许多优秀的 JavaScript 动画库（如 GSAP、Anime.js）提供强大的功能和简便的 API，大大简化动画开发。

#### 缺点

1. **性能问题：**
    - **可能更耗资源**：JavaScript 动画可能比 CSS 动画更耗费浏览器资源，特别是在处理大量 DOM 元素或复杂计算时。
    - **主线程运行**：JavaScript 动画运行在浏览器的主线程上，可能会导致页面重绘和重排，从而影响性能。

2. **代码复杂性：**
    - **增加代码量**：复杂的动画逻辑会增加 JavaScript 代码量，可能导致代码维护性和可读性下降。

### 实际应用场景

#### 选择 CSS 动画的场景：
- **简单的过渡和转换**：如 hover 效果、淡入淡出、元素位置变化等。
- **加载动画**：简单的加载动画或循环动画。
- **状态变更**：当元素状态变更时触发的动画，如按钮点击后的视觉反馈。

#### 选择 JavaScript 动画的场景：
- **复杂和精细的动画**：如游戏动画、交互复杂的界面动画、需要动态计算中间帧的动画。
- **用户交互动画**：依赖于用户输入的动画效果，如拖拽、滑动等。
- **需要动态控制的动画**：如播放控制（暂停、继续、跳转）等功能。

### 综合考虑

在实际项目中，开发人员经常结合使用 CSS 和 JavaScript 动画。例如，使用 CSS 处理简单的过渡效果，而使用 JavaScript 处理需要复杂逻辑和用户交互的动画效果。这样的组合可以发挥两者的优势，同时减少性能开销和代码复杂性。

# CORS 代表什么？它解决什么问题？
CORS（Cross-Origin Resource Sharing，跨域资源共享）是一种机制，允许受限制的资源（如字体、JavaScript）从一个域加载到另一个域。它通过使用额外的 HTTP 头来告知浏览器，允许来自源（domain）的哪些资源请求可以被接受。

### CORS 解决的问题

在现代浏览器中，出于安全考虑，存在一种称为“同源策略”（Same-Origin Policy）的限制。该策略禁止在一个源（域名、协议和端口）加载的网页从另一个源请求资源。这个策略防止了恶意网站读取用户敏感数据。

例如，如果你在 `http://example.com` 上访问一个页面，这个页面试图通过 AJAX 请求访问 `http://api.anotherdomain.com/data`，浏览器会阻止这个请求，因为它们不属于同一个源。

### CORS 具体解决的问题

1. **跨域请求**：
    - 同源策略限制了跨域请求，CORS 允许服务器明确指出哪些域名可以访问其资源，解决了跨域请求的问题。

2. **资源共享**：
    - 在微服务架构中，不同服务之间需要共享资源，CORS 允许不同域的服务安全地相互访问资源。

3. **第三方 API 访问**：
    - 前端应用需要访问第三方 API，CORS 允许服务器定义哪些域可以访问其 API，使得前端应用可以安全地进行跨域数据请求。

### CORS 的工作机制

CORS 的工作通过 HTTP 头来实现，主要包括以下几个步骤和头部：

1. **简单请求**：
    - 如果请求是“简单请求”，浏览器会直接发送请求，并且服务器通过响应头决定是否允许跨域请求。简单请求包括 `GET`、`POST`（Content-Type 为 `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`）和 `HEAD` 方法。

   ```http
   GET /data HTTP/1.1
   Host: api.anotherdomain.com
   Origin: http://example.com

   HTTP/1.1 200 OK
   Access-Control-Allow-Origin: http://example.com
   ```

2. **预检请求（Preflight Request）**：
    - 对于非简单请求（如 `PUT`, `DELETE`, `Content-Type` 为 JSON 的 `POST` 请求），浏览器会先发送一个 `OPTIONS` 请求，称为预检请求，询问服务器是否允许实际请求。

   ```http
   OPTIONS /data HTTP/1.1
   Host: api.anotherdomain.com
   Origin: http://example.com
   Access-Control-Request-Method: POST

   HTTP/1.1 200 OK
   Access-Control-Allow-Origin: http://example.com
   Access-Control-Allow-Methods: POST
   ```

3. **响应头**：
    - `Access-Control-Allow-Origin`：指定允许访问资源的源。
    - `Access-Control-Allow-Methods`：指定允许的 HTTP 方法。
    - `Access-Control-Allow-Headers`：指定允许的请求头。
    - `Access-Control-Allow-Credentials`：指示是否允许发送 Cookie。
    - `Access-Control-Expose-Headers`：允许前端 JavaScript 代码访问的响应头。
    - `Access-Control-Max-Age`：指示预检请求的缓存时间。

### 例子

假设你有一个 API 服务器位于 `http://api.example.com`，你希望允许位于 `http://frontend.example.com` 的前端应用访问这个 API，可以在服务器上配置 CORS：

```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://frontend.example.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type
Access-Control-Allow-Credentials: true
```

### 实际应用

- **前端开发**：在前端开发中，经常需要跨域请求数据，例如在 React 或 Vue.js 项目中请求第三方 API 数据。
- **后端开发**：后端服务器需要配置 CORS 头，以允许前端应用安全地访问其资源。
- **微服务架构**：在微服务架构中，服务之间需要跨域请求和数据共享，CORS 配置是常见的需求。

通过正确配置 CORS，可以安全且灵活地解决跨域资源访问问题，确保前端和后端服务之间的数据交换安全可靠。

# 您能解释一下当您在浏览器中输入 URL 时会发生什么吗？
当在浏览器中输入 URL 并按下回车键时会发生的步骤：

### 1. **URL 解析**

首先，浏览器会解析你输入的 URL，例如 `https://www.example.com/path?query=string#fragment`。URL 被分解成以下几个部分：
- **协议**：`https`
- **域名**：`www.example.com`
- **路径**：`/path`
- **查询字符串**：`?query=string`
- **片段标识符**：`#fragment`

### 2. **DNS 解析**

浏览器需要将域名 `www.example.com` 转换成 IP 地址。以下是详细的解析过程：
1. **浏览器缓存**：浏览器首先会检查自身的 DNS 缓存，看是否有该域名的 IP 地址。
2. **操作系统缓存**：如果浏览器缓存没有，浏览器会查询操作系统的 DNS 缓存。
3. **路由器缓存**：如果操作系统缓存也没有，操作系统会查询本地网络设备（如路由器）的 DNS 缓存。
4. **ISP DNS 服务器**：如果路由器缓存也没有，路由器会向 ISP（互联网服务提供商）的 DNS 服务器发送查询请求。
5. **递归查询**：ISP 的 DNS 服务器如果没有缓存该域名，会递归查询其他 DNS 服务器，直到找到权威 DNS 服务器以获得该域名的 IP 地址。

DNS 解析结果是一个或多个 IP 地址，浏览器选择其中一个用于后续步骤。

### 3. **TCP 连接**

获得 IP 地址后，浏览器会与目标服务器建立 TCP 连接。TCP 连接的建立过程称为“三次握手”：
1. **客户端发送 SYN 包**：客户端向服务器发送一个 SYN（同步序列编号）包，请求建立连接。
2. **服务器回复 SYN-ACK 包**：服务器收到 SYN 包后，回复一个 SYN-ACK（同步序列编号和确认编号）包，表示同意建立连接。
3. **客户端回复 ACK 包**：客户端收到 SYN-ACK 包后，回复一个 ACK（确认编号）包，确认连接建立。

### 4. **发送 HTTP/HTTPS 请求**

TCP 连接建立后，浏览器会根据 URL 协议发送 HTTP 或 HTTPS 请求：

- **HTTP 请求**：直接发送 HTTP 请求。
- **HTTPS 请求**：先进行 TLS 握手，建立加密连接。TLS 握手过程：
    1. **客户端发送 ClientHello 消息**：包含支持的加密算法、协议版本等信息。
    2. **服务器回复 ServerHello 消息**：包含服务器选择的加密算法和服务器证书。
    3. **客户端验证服务器证书**：验证证书是否合法，可信任。
    4. **生成会话密钥**：客户端生成会话密钥，并使用服务器的公钥加密发送给服务器。
    5. **建立加密连接**：服务器解密会话密钥，客户端和服务器使用会话密钥进行加密通信。

然后浏览器发送 HTTP 请求报文，包含：
- **请求行**：如 `GET /path HTTP/1.1`
- **请求头**：如 `Host: www.example.com`、`User-Agent`、`Accept` 等
- **请求体**：对于 POST 等方法包含请求数据

### 5. **服务器处理请求**

服务器收到请求后，处理该请求并生成响应：
1. **路由处理**：根据请求路径和方法，确定调用哪个处理函数或控制器。
2. **业务逻辑处理**：处理业务逻辑，可能包括数据库查询、数据处理等。
3. **生成响应**：生成 HTTP 响应报文，包括状态行、响应头和响应体。

### 6. **发送响应**

服务器将生成的 HTTP 响应报文通过 TCP 连接发送回客户端。响应报文包括：
- **状态行**：如 `HTTP/1.1 200 OK`
- **响应头**：如 `Content-Type: text/html`、`Content-Length`、`Set-Cookie` 等
- **响应体**：包含实际的网页内容，如 HTML、CSS、JavaScript、图像等

### 7. **浏览器渲染页面**

浏览器收到响应后，开始渲染网页。渲染过程包括以下步骤：

1. **构建 DOM 树**：
    - 浏览器解析 HTML 文档，创建 Document Object Model（DOM）树，表示 HTML 文档的结构和内容。

2. **构建 CSSOM 树**：
    - 浏览器解析 CSS 文件和内联样式，创建 CSS Object Model（CSSOM）树，表示样式信息。

3. **合成渲染树**：
    - 将 DOM 树和 CSSOM 树合并，生成渲染树。渲染树包含每个节点的样式和布局信息。

4. **布局（重排）**：
    - 浏览器计算每个节点的位置和大小，确定页面布局。

5. **绘制**：
    - 将渲染树中的节点绘制到屏幕上，显示网页内容。

### 8. **执行 JavaScript**

浏览器会下载并执行网页中的 JavaScript 代码。JavaScript 可能会操作 DOM，更新页面内容，处理用户交互，发送异步请求等。

### 9. **处理其他资源请求**

在解析 HTML 时，浏览器会发现需要加载的其他资源（如 CSS 文件、JavaScript 文件、图像等），并发起相应的请求。这些请求大多是并行的，以提高加载速度。

### 10. **用户交互**

网页渲染完成后，用户可以与页面交互（如点击、滚动等）。浏览器会根据用户的操作更新页面，包括重排和重绘。

### 总结

整个过程涉及多种技术和协议，从输入 URL 到网页渲染完成，浏览器、操作系统和网络服务之间协同工作，确保最终将网页正确地展示给用户。这个流程的各个阶段都至关重要，任何一环出现问题都会影响用户体验。

这就是当你在浏览器中输入 URL 并按下回车键时，浏览器背后所发生的详细步骤。

# 描述 SSR 和 CSR 之间的区别。讨论其优缺点。
### 服务器端渲染 (Server-Side Rendering, SSR) 和 客户端渲染 (Client-Side Rendering, CSR) 的区别

**服务器端渲染 (SSR)** 是指在服务器上生成 HTML，然后将生成的 HTML 发送到客户端。客户端只需接收并显示这些 HTML 内容。

**客户端渲染 (CSR)** 是指在客户端（通常是浏览器）上生成 HTML 内容。初始页面是一个最小的 HTML 骨架，主要的内容通过 JavaScript 在客户端生成。

### SSR 和 CSR 的具体区别

#### 服务器端渲染 (SSR)

1. **工作原理**：
    - 用户请求页面。
    - 服务器处理请求，执行应用逻辑。
    - 服务器生成完整的 HTML 页面。
    - 服务器将生成的 HTML 页面发送给客户端。
    - 浏览器显示接收到的完整 HTML 页面。

2. **优点**：
    - **快速首次渲染**：因为完整的 HTML 是由服务器生成并发送的，浏览器可以立即显示内容，尤其对用户第一次访问时更友好。
    - **SEO 友好**：搜索引擎可以轻松地抓取和索引完整的 HTML 内容，有助于提高网站的搜索引擎排名。
    - **更好的性能**：在低性能设备上表现更好，因为主要的渲染工作由服务器完成。

3. **缺点**：
    - **服务器压力大**：每个请求都需要服务器生成完整的 HTML 页面，服务器负载高，尤其是高并发场景下。
    - **较差的用户交互体验**：页面间的切换通常需要完全刷新，用户体验较差。
    - **开发复杂度高**：需要处理更多的服务器端逻辑，尤其是在使用现代前端框架时，需要额外的配置和工具链支持 SSR。

#### 客户端渲染 (CSR)

1. **工作原理**：
    - 用户请求页面。
    - 服务器返回一个基本的 HTML 文件，其中包含一个指向 JavaScript 文件的引用。
    - 浏览器下载和执行 JavaScript 文件。
    - JavaScript 文件在客户端生成并插入 HTML 内容。
    - 浏览器显示由 JavaScript 动态生成的页面内容。

2. **优点**：
    - **减少服务器负载**：初始请求只是一个简单的 HTML 文件和静态资源，服务器压力较小。
    - **更好的用户交互体验**：页面间的切换更流畅，无需完全刷新，用户体验更好。
    - **开发灵活性高**：现代前端框架（如 React、Vue、Angular）提供了丰富的工具和生态系统，便于开发和维护复杂的单页应用（SPA）。

3. **缺点**：
    - **首次加载时间较长**：初始页面需要加载大量的 JavaScript 文件，首次渲染可能较慢。
    - **SEO 不友好**：搜索引擎对纯客户端渲染的内容抓取和索引较为困难，需要额外的处理（如使用预渲染或动态渲染）。
    - **依赖于客户端性能**：页面渲染工作在客户端完成，低性能设备可能会导致渲染速度慢，用户体验差。

### SSR 和 CSR 的选择

#### 选择 SSR 的场景：
- **SEO 要求高**：内容需要被搜索引擎抓取和索引，比如博客、新闻网站。
- **首次渲染速度要求高**：需要快速展示内容，比如电商网站的产品页。
- **服务器资源充足**：能够处理高并发和高负载的服务器环境。

#### 选择 CSR 的场景：
- **高交互性需求**：用户需要频繁交互，页面切换流畅，比如单页应用（SPA）。
- **开发效率要求高**：需要快速开发和迭代的项目，使用现代前端框架和工具链。
- **服务器资源有限**：服务器负载较重，希望将部分计算转移到客户端。

### 总结

**SSR 和 CSR 各有优缺点**，具体选择取决于项目的需求和约束。在实际开发中，往往会结合两者的优势，采用混合渲染（Hydration）的方式，即初始页面使用 SSR 生成，随后在客户端通过 CSR 提升用户交互体验。这种方式可以兼顾首次渲染速度和用户体验，同时也有利于 SEO。

# 如何提供包含多种语言内容的页面？
提供多种语言内容的页面涉及国际化（i18n）和本地化（l10n）。以下是实现多语言支持的步骤和最佳实践：

### 1. **准备和规划**

- **确定支持的语言**：根据目标用户和市场需求，确定需要支持的语言。
- **选择国际化框架或库**：选择适合的国际化框架或库，比如 i18next、react-i18next、vue-i18n、angular-i18n 等。
- **结构化文件和内容**：设计良好的文件结构以存储不同语言的内容，通常是 JSON 文件或其他格式。

### 2. **提取和管理翻译字符串**

- **提取翻译字符串**：将页面中的文本提取为翻译字符串，使用占位符替换动态内容。
  ```json
  // en.json
  {
    "welcome": "Welcome, {{name}}!",
    "description": "This is an example of internationalization."
  }
  // zh.json
  {
    "welcome": "欢迎, {{name}}!",
    "description": "这是国际化的示例。"
  }
  ```

### 3. **配置国际化库**

- 以 React 应用为例，使用 i18next 和 react-i18next：
  ```bash
  npm install i18next react-i18next
  ```

  ```javascript
  // i18n.js
  import i18n from 'i18next';
  import { initReactI18next } from 'react-i18next';
  import en from './locales/en.json';
  import zh from './locales/zh.json';

  i18n
    .use(initReactI18next)
    .init({
      resources: {
        en: { translation: en },
        zh: { translation: zh }
      },
      lng: 'en',
      fallbackLng: 'en',
      interpolation: {
        escapeValue: false
      }
    });

  export default i18n;
  ```

### 4. **在组件中使用翻译**

在 React 组件中使用 `useTranslation` 钩子：
  ```javascript
  import React from 'react';
  import { useTranslation } from 'react-i18next';

  const MyComponent = () => {
    const { t } = useTranslation();

    return (
      <div>
        <h1>{t('welcome', { name: 'John' })}</h1>
        <p>{t('description')}</p>
      </div>
    );
  };

  export default MyComponent;
  ```

### 5. **语言切换**

提供语言切换功能，让用户选择他们的偏好语言：
  ```javascript
  const LanguageSwitcher = () => {
    const { i18n } = useTranslation();

    const changeLanguage = (lng) => {
      i18n.changeLanguage(lng);
    };

    return (
      <div>
        <button onClick={() => changeLanguage('en')}>English</button>
        <button onClick={() => changeLanguage('zh')}>中文</button>
      </div>
    );
  };

  export default LanguageSwitcher;
  ```

### 6. **处理日期、时间和货币格式**

- 使用库如 `moment.js`、`date-fns`、`Intl` API 来处理不同语言的日期、时间和货币格式。
  ```javascript
  const date = new Date();
  const formattedDate = new Intl.DateTimeFormat('zh-CN').format(date);
  console.log(formattedDate); // 2024/5/23
  ```

### 7. **搜索引擎优化 (SEO)**

- **hreflang 标签**：在 HTML `<head>` 中使用 `hreflang` 标签告诉搜索引擎页面的语言和地区版本。
  ```html
  <link rel="alternate" href="https://example.com/en" hreflang="en">
  <link rel="alternate" href="https://example.com/zh" hreflang="zh">
  ```

- **URL 结构**：设计 URL 结构以反映不同语言，比如 `https://example.com/en/` 和 `https://example.com/zh/`。

### 8. **服务器端渲染 (SSR) 支持**

- 在使用 SSR 的框架如 Next.js 时，确保服务器端也能正确处理语言和内容。
  ```javascript
  // next.config.js
  module.exports = {
    i18n: {
      locales: ['en', 'zh'],
      defaultLocale: 'en'
    }
  };
  ```

### 9. **测试**

- 测试每种语言的页面，确保翻译准确且没有破坏布局。
- 使用工具如翻译管理平台（如 Transifex、Crowdin）来管理和更新翻译。

### 10. **用户体验**

- 保存用户选择的语言偏好，可以使用 Cookies 或 localStorage。
  ```javascript
  // 保存用户选择的语言
  localStorage.setItem('language', 'zh');

  // 页面加载时设置语言
  const language = localStorage.getItem('language') || 'en';
  i18n.changeLanguage(language);
  ```

通过这些步骤，你可以创建一个多语言支持的网页，提升用户体验并覆盖更广泛的用户群体。

# 描述 localStorage和sessionStorage之间的区别
`localStorage` 和 `sessionStorage` 都是 HTML5 提供的 Web Storage API 的一部分，它们都允许在浏览器中存储数据。它们之间的区别主要体现在数据的生命周期和作用域上：

### 1. 生命周期

- **localStorage**：存储在 `localStorage` 中的数据没有过期时间，会一直保留在浏览器中，除非被显式删除。

- **sessionStorage**：存储在 `sessionStorage` 中的数据仅在当前会话（当前标签页或窗口）有效。一旦会话结束（关闭标签页或窗口），数据就会被销毁。

### 2. 作用域

- **localStorage**：存储在 `localStorage` 中的数据在同一域名下的所有页面和窗口中都是共享的。即使是不同的标签页或窗口也可以访问相同的 `localStorage` 数据。

- **sessionStorage**：存储在 `sessionStorage` 中的数据仅在同一会话中有效。每个标签页或窗口都有自己独立的 `sessionStorage` 存储空间，页面之间无法共享数据。

### 3. 使用场景

- **localStorage** 适用于需要持久保存的数据，比如用户的偏好设置、登录凭据等。因为数据不会过期，可以在用户下次访问时保持状态。

- **sessionStorage** 适用于临时保存的数据，比如表单数据、页面状态等。因为数据仅在当前会话中有效，关闭标签页或窗口时就会自动销毁，不会留下垃圾数据。

总的来说，`localStorage` 和 `sessionStorage` 都是用于在浏览器中存储数据的方式，但它们的生命周期和作用域不同，适用于不同的使用场景。

# 什么是渐进式渲染？
渐进式渲染是一种通过在网页加载过程中逐步显示内容的策略，以改善用户体验和页面性能的方法。它的核心思想是尽快展示页面的部分内容，而不是等待整个页面完全加载后再显示。

### 渐进式渲染的特点：

1. **分阶段加载**：页面内容被分为多个部分，每个部分根据其重要性和优先级进行加载和渲染，而不是等待整个页面内容加载完成。

2. **逐步显示**：随着内容逐渐加载完成，用户能够看到页面上越来越多的内容，从而获得更快的视觉反馈。

3. **优先加载关键内容**：首先加载并渲染对用户体验至关重要的内容，如页面主体结构、标题、关键文本等。

4. **增量渲染**：页面内容可以通过 JavaScript 动态加载，例如懒加载图片、无限滚动列表等，进一步提升性能和用户体验。

### 渐进式渲染的优势：

- **更快的首次渲染**：用户能够更快地看到页面内容，减少等待时间，提升用户满意度和留存率。

- **更好的用户体验**：逐步显示页面内容可以给用户更好的反馈，让用户感觉页面加载速度更快，提升整体体验。

- **更好的性能表现**：通过优先加载和渲染关键内容，可以减少页面加载时间，降低服务器和客户端的负载。

### 示例：

- **渐进式图像加载**：图片可以首先展示模糊或低分辨率的预览图，然后在后台逐步加载高分辨率的图像，提供更快的视觉反馈。

- **无限滚动列表**：在滚动时动态加载列表项，以提供更快的响应时间，并避免一次性加载大量数据导致页面卡顿。

总之，渐进式渲染是一种优化页面加载和性能的方法，它可以通过逐步显示页面内容，提升用户体验、减少等待时间，同时降低服务器和客户端的负载。

# HTTP和HTTPS有什么区别

**HTTP和HTTPS是什么？**

我们都知道使用浏览器访问一个网站页面，需要知道该网站的域名，在浏览器的地址栏中我们会看到一串URL，如图

![img](https://pic1.zhimg.com/80/v2-e099fec8444c597b07fd9ca6d730c7ac_720w.jpg)

网站的URL会分为两部分：通信协议和域名地址。

域名地址都很好理解，不同的域名地址表示网站中不同的页面，而通信协议，简单来说就是浏览器和服务器之间沟通的语言。网站中的通信协议一般就是HTTP协议和HTTPS协议。两者分别是什么，有什么区别呢？

![img](https://pic4.zhimg.com/80/v2-6e276cf4bc8781231d0b24a8be43dc9b_720w.jpg)

**HTTP协议**

HTTP协议也就是超文本传输协议，是一种使用明文数据传输的网络协议。一直以来HTTP协议都是最主流的网页协议，HTTP协议被用于在Web浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。

![img](https://pic1.zhimg.com/80/v2-4ea0431a093e1a0a6d76541ca06ce4e0_720w.jpg)

互联网发展到今天，HTTP协议的明文传输会让用户存在非常大的安全隐患。试想一下，假如你在一个HTTP协议的网站上面购物，你需要在页面上输入你的银行卡号和密码，然后你把数据提交到服务器实现购买。假如这个环节稍有不慎，你的传输数据被第三者给截获了，由于HTTP明文数据传输的原因，你的银行卡号和密码，将会被这个截获人所得到。现在你还敢在一个HTTP的网站上面购物吗？你还会在一个HTTP的网站上面留下你的个人信息吗？

**HTTPS协议**

为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。HTTPS协议可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密。在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息仍然是安全的。这就是HTTP和HTTPS的最大区别。

![img](https://pic3.zhimg.com/80/v2-29afec355e17162c8f7f648ddabded02_720w.jpg)

HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，很多大型互联网网站，如百度、淘宝、腾讯很早就已经把HTTP换成HTTPS了。

**HTTP和HTTPS的区别**

![img](https://pic2.zhimg.com/80/v2-9556fa61ac7262a18bc639db29362669_720w.jpg)

1.安全性不同

https://前缀表明是用SSL (安全套接字)或TSL加密的，你的电脑与服务器之间收发的信息传输将更加安全。当你使用浏览器访问一个HTTP网站的时候，你会发现浏览器会对该HTTP网站显示“不安全”的安全警告，提示用户当前所访问的网站可能会存在风险。



![img](https://pic1.zhimg.com/80/v2-4ce6e7c3c57e75bcc90fdf10eb992edc_720w.jpg)

而假如你访问的是一个HTTPS网站时，情况却是完全不一样。你会发现浏览器的地址栏会变成绿色，企业名称会展示在地址栏中，地址栏上面还会出现一把“安全锁”的图标。这些都会给予用户很大的视觉上的安全体验。

![img](https://pic4.zhimg.com/80/v2-0598eaffd57c97632a8fac637d82a1df_720w.jpg)



2.网站申请流程不同

https协议需要到CA申请证书，一般免费证书很少，需要交费，Web服务器启用SSL需要获得一个服务器证书并将该证书与要使用SSL的服务器绑定。

3.默认端口不同

http和https使用的是完全不同的连接方式，同时使用的端口也不同，http使用的是80端口，https使用的是443端口。在网络模型中，HTTP工作于应用层，而HTTPS工作在传输层。

4.对搜索排名的提升

这也是很多站长所关注的地方。百度和谷歌两大搜索引擎都已经明确表示，HTTPS网站将会作为搜索排名的一个重要权重指标。也就是说HTTPS网站比起HTTP网站在搜索排名中更有优势。

HTTPS网站相比起HTTP网站拥有着多种的优势，HTTP明显已经不能适应当今这个互联网时代，可以预见到HTTP在不久的将来将会全面被HTTPS所取代。

# HTTP组成

每条HTTP报文都包含一个来自客户端的请求，或者一条来自服务器的响应。HTTP报文分两类：请求报文和响应报文。不管是请求报文还是响应报文每条HTTP报文是由3部分组成，分别是：**1、起始行 2、首部 3、主体**



**一、起始行**

**请求行和响应行**

**请求行：**请求报文请求服务器对资源进行一些操作。通俗讲就是客户端想服务器发起请求的请求命令。包含了

方法：如：get、post等

请求URL：如：/src/test.pdf

版本号：版本号是指HTTP/1.1或HTTP/2.0等



![img](https://pic2.zhimg.com/80/v2-c0382b0bbf8cc4bdb4a3e84588adb231_720w.jpg)



**响应行：**响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。包含了响应报文使用的HTTP版本，状态码（如：200、404等），以及描述操作状态的文本形式的原因短语。

![img](https://pic3.zhimg.com/80/v2-5f1fc1357a2b103dffb9978c04089a62_720w.jpg)



**版本号：**版本号是指HTTP/1.1或HTTP/2.0等

状态码大致分5类：

1-199：信息提示。请求已被接受，需要进一步处理。

200-299：成功。请求已被接受，处理。

300-399：重定向。最常见的重定向就是304，本地已缓存返回内容，所以浏览器直接从本地取内容而不是从服务器重新拉去。

400-499：客户端错误。最常见的是404，服务器没有找到内容，说明你请求的url不对，服务器上并没有对应的内容。

500-599：服务器错误。代表服务器在处理请求过程中有错误或异常状态发生。

常见的请求状态码：

200：请求已成功，请求所需要的请求头和相应数据随此请求返回。202：服务器已接受请求，但是尚未处理。301：永久移动

302：临时移动

304：get请求，且该请求已被允许，但是所请求的内容和上次请求的内容并没有发生改变，服务器返回该状态码，浏览器抓取已上次请求的已缓存的文件。

400：由于包含语法错误，该请求不能被服务器理解。

401：当前请求需要用户认证，该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。

403：服务器已经理解请求，但是拒绝了它。

404：请求失败，请求所需要的资源在服务器上并为被发现。

500：服务器遇到了一个未曾预料的情况。

503：由于临时的服务器维护或过载，服务器当前无法处理请求。



**短语：**它为状态码提供了文本形式的解释（比如：HTTP/1.0 200 OK ,OK就是原因短语）



**二、首部**

首部分类：**通用首部**（既可以出现在请求报文中，也可以出现在响应报文中）、**请求首部**、**响应首部**、**实体首部**（描述主题的长度和内容，或者资源本身）、**扩展首部**

在这里简单列一些常见的首部

**通用首部**

cache-control：用于传输对象的缓存信息。

Date: 用来给出报文创建的日期和时间。



**请求首部：**

Accept：客户端用Accept首部来通知服务器可以接受哪些媒体类型。例如：Accept: text/*, image/*、Accept: text/*, image/gif, image/jpeg; q=1等

Accept-Charset:用来通知服务器它可以接受哪些字符集或哪些是优选字符集。例如：Accept-Charset: iso-latin-1

Accept-Encoding:客户端用来告知服务器它可以接受哪些编码方式。

Accept-language：用来告诉服务器可接受或优选接受哪些语言。

Authorization：客户端用来向服务器回应自己的身体的验证信息。

From：用来说明请求来自何方。

If-Modified-since：用来发起条件请求。

If-Match

If-None-Match



**响应首部：**

Age：告诉接受端响应已产生了多长时间。

Allow：用于通知客户端可以对特定资源使用哪些HTTP方法。例如：Allow: GET, HEAD

实体首部：

Content-Encoding：用于说明是否对某对象进行过编码。

Content-Language：用来告诉对方，想要理解对象的客户端，应该理解哪种自然语言。

Content-Length：用来说明实体主体部分的长度和尺寸。

Content-Type：用来说明报文中对象的媒体类型。例如：Content-Type: text/html; charset=iso-latin-1

ETag：为报文中包含的实体提供了实体标记。实体标记实际上就是一种标识资源的方式。

Expiress：给出了响应失效的日期和时间。这样，像浏览器这样的客户端就可以缓存一份副本，在这个时间到期之前，不用去询问服务器它是否失效。

Last-Modified

常用的首部大概就这么多，还有好多没有列出来的，请大家自行查找。Expiress、cache-control、Age、ETag、If-None-Math、Last-Modified、If-Modified-since这些是和缓存相关的一些首部，并没有过多的解释，因为我们公众号的上一篇文章有讲到缓存，如果大家感兴趣可以看一下上一篇文章，再次附一张从网络上找到的一个很好解释缓存的一张图片。



![img](https://pic3.zhimg.com/80/v2-5ade6a4af915f2527fb7413ff483df46_720w.jpg)







**三、实体**

实体就是HTTP要传输的内容。

# Http协议中Http1.0与1.1区别

·     在http1.0中，当建立连接后，客户端发送一个请求，服务器端返回一个信息后就关闭连接，当浏览器下次请求的时候又要建立连接，显然这种不断建立连接的方式，会造成很多问题。

·     在http1.1中，引入了持续连接的概念，通过这种连接，浏览器可以建立一个连接之后，发送请求并得到返回信息，然后继续发送请求再次等到返回信息，也就是说客户端可以连续发送多个请求，而不用等待每一个响应的到来。

# Http协议首部字段

1、通用首部字段（请求报文与响应报文都会使用的首部字段）

·     Date：创建报文时间

·     Connection：连接的管理

·     Cache-Control：缓存的控制

·     Transfer-Encoding：报文主体的传输编码方式

2、请求首部字段（请求报文会使用的首部字段）

·     Host：请求资源所在服务器

·     Accept：可处理的媒体类型

·     Accept-Charset：可接收的字符集

·     Accept-Encoding：可接受的内容编码

·     Accept-Language：可接受的自然语言

3、响应首部字段（响应报文会使用的首部字段）

·     Accept-Ranges：可接受的字节范围

·     Location：令客户端重新定向到的URI

·     Server：HTTP服务器的安装信息

4、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）

·     Allow：资源可支持的HTTP方法

·     Content-Type：实体主类的类型

·     Content-Encoding：实体主体适用的编码方式

·     Content-Language：实体主体的自然语言

·     Content-Length：实体主体的的字节数

·     Content-Range：实体主体的位置范围，一般用于发出部分请求时使用

# Http状态码

- 200("OK")
  一切正常。实体主体中的文档（若存在的话）是某资源的表示。

- 500("Bad Request")
  客户端方面的问题。实体主题中的文档（若存在的话）是一个错误消息。希望客户端能够理解此错误消息，并改正问题。

- 500("Internal Server Error")
  服务期方面的问题。实体主体中的文档（如果存在的话）是一个错误消息。该错误消息通常无济于事，因为客户端无法修复服务器方面的问题。

- 503 服务器维护

- 301重定向。永久移动

- 302重定向。临时移动

  这种情况下，服务器返回的头部信息中会包含一个 Location 字段，内容是重定向到的url。

- 303查看其它地址。与301类似。使用GET和POST请求查看

- 304未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源

- 400 客户端请求的语法错误，服务器无法理解

- 401 请求要求用户的身份认证

- 403 服务器理解请求客户端的请求，但是拒绝执行此请求

- 404("Not Found") 和410("Gone")

当客户端所请求的URI不对应于任何资源时，发送此响应代码。404用于服务器端不知道客户端要请求哪个资源的情况；410用于服务器端知道客户端所请求的资源曾经存在，但现在已经不存在了的情况。

# href与src的区别

我们在开发页面的时候，有时候需要需要引用一些外部的资源，经常分不清href与src，下面我们就来谈谈它们之间到底分别是什么，这样使用的时候就做到心中有数。

1.href：Hypertext Reference的缩写，超文本引用，它指向一些网络资源，建立和当前元素或者说是本文档的链接关系。在加载它的时候，不会停止对当前文档的处理，浏览器会继续往下走。常用在a、link等标签。

```html
<a href="http://www.baidu.com"></a>
<link type="text/css" rel="stylesheet" href="common.css">
```

如上面所显示的那样，当浏览器加载到link标签时，会识别这是CSS文档，并行下载该CSS文档，但并不会停止对当前页面后续内容的加载。这也是不建议使用@import加载CSS的原因。

2.src：source的缩写，表示的是对资源的引用，它指向的内容会嵌入到当前标签所在的位置。由于src的内容是页面必不可少的一部分，因此浏览器在解析src时会停下来对后续文档的处理，直到src的内容加载完毕。常用在script、img、iframe标签中，我们建议js文件放在HTML文档的最后面。如果js文件放在了head标签中，可以使用window.onload实现js的最后加载。

```html
<img src="img/girl.jpg">
<frame src="top.html">
<iframe src="top.html">
<script src="show.js">
```

总结：href用于建立当前页面与引用资源之间的关系（链接），而src则会替换当前标签。遇到href，页面会并行加载后续内容；而src则不同，浏览器需要加载完毕src的内容才会继续往下走。

# script标签中的async和defer

### defer

如果script标签设置了该属性，则浏览器会异步的下载该文件并且不会影响到后续DOM的渲染；
如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script；
defer脚本会在文档渲染完毕后，DOMContentLoaded事件调用前执行。

### async

async的设置，会使得script脚本异步的加载并在允许的情况下执行
async的执行，并不会按着script在页面中的顺序来执行，而是谁先加载完谁执行。


